// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/bbernstein/lacylights-go/internal/database/models"
)

type BulkCueCreateInput struct {
	Cues []*CreateCueInput `json:"cues"`
}

type BulkCueListCreateInput struct {
	CueLists []*CreateCueListInput `json:"cueLists"`
}

type BulkCueListUpdateInput struct {
	CueLists []*CueListUpdateItem `json:"cueLists"`
}

type BulkCueUpdateInput struct {
	CueIds      []string                       `json:"cueIds"`
	FadeInTime  graphql.Omittable[*float64]    `json:"fadeInTime,omitempty"`
	FadeOutTime graphql.Omittable[*float64]    `json:"fadeOutTime,omitempty"`
	FollowTime  graphql.Omittable[*float64]    `json:"followTime,omitempty"`
	EasingType  graphql.Omittable[*EasingType] `json:"easingType,omitempty"`
}

type BulkDeleteResult struct {
	DeletedCount int      `json:"deletedCount"`
	DeletedIds   []string `json:"deletedIds"`
}

type BulkFixtureCreateInput struct {
	Fixtures []*CreateFixtureInstanceInput `json:"fixtures"`
}

type BulkFixtureDefinitionCreateInput struct {
	Definitions []*CreateFixtureDefinitionInput `json:"definitions"`
}

type BulkFixtureDefinitionUpdateInput struct {
	Definitions []*FixtureDefinitionUpdateItem `json:"definitions"`
}

type BulkFixtureUpdateInput struct {
	Fixtures []*FixtureUpdateItem `json:"fixtures"`
}

type BulkProjectCreateInput struct {
	Projects []*CreateProjectInput `json:"projects"`
}

type BulkProjectUpdateInput struct {
	Projects []*ProjectUpdateItem `json:"projects"`
}

type BulkSceneBoardButtonCreateInput struct {
	Buttons []*CreateSceneBoardButtonInput `json:"buttons"`
}

type BulkSceneBoardButtonUpdateInput struct {
	Buttons []*SceneBoardButtonUpdateItem `json:"buttons"`
}

type BulkSceneBoardCreateInput struct {
	SceneBoards []*CreateSceneBoardInput `json:"sceneBoards"`
}

type BulkSceneBoardUpdateInput struct {
	SceneBoards []*SceneBoardUpdateItem `json:"sceneBoards"`
}

type BulkSceneCreateInput struct {
	Scenes []*CreateSceneInput `json:"scenes"`
}

type BulkSceneUpdateInput struct {
	Scenes []*SceneUpdateItem `json:"scenes"`
}

type ChannelAssignmentInput struct {
	ProjectID       string                  `json:"projectId"`
	Universe        graphql.Omittable[*int] `json:"universe,omitempty"`
	StartingChannel graphql.Omittable[*int] `json:"startingChannel,omitempty"`
	FixtureSpecs    []*FixtureSpecInput     `json:"fixtureSpecs"`
}

type ChannelAssignmentSuggestion struct {
	Universe                   int                         `json:"universe"`
	Assignments                []*FixtureChannelAssignment `json:"assignments"`
	TotalChannelsNeeded        int                         `json:"totalChannelsNeeded"`
	AvailableChannelsRemaining int                         `json:"availableChannelsRemaining"`
}

type ChannelFadeBehaviorInput struct {
	ChannelID    string       `json:"channelId"`
	FadeBehavior FadeBehavior `json:"fadeBehavior"`
}

type ChannelMapFixture struct {
	ID           string      `json:"id"`
	Name         string      `json:"name"`
	Type         FixtureType `json:"type"`
	StartChannel int         `json:"startChannel"`
	EndChannel   int         `json:"endChannel"`
	ChannelCount int         `json:"channelCount"`
}

type ChannelMapResult struct {
	ProjectID string                `json:"projectId"`
	Universes []*UniverseChannelMap `json:"universes"`
}

type ChannelUsage struct {
	FixtureID   string      `json:"fixtureId"`
	FixtureName string      `json:"fixtureName"`
	ChannelType ChannelType `json:"channelType"`
}

type ChannelValueInput struct {
	Offset int `json:"offset"`
	Value  int `json:"value"`
}

type CreateChannelDefinitionInput struct {
	Name         string                           `json:"name"`
	Type         ChannelType                      `json:"type"`
	Offset       int                              `json:"offset"`
	MinValue     int                              `json:"minValue"`
	MaxValue     int                              `json:"maxValue"`
	DefaultValue int                              `json:"defaultValue"`
	FadeBehavior graphql.Omittable[*FadeBehavior] `json:"fadeBehavior,omitempty"`
	IsDiscrete   graphql.Omittable[*bool]         `json:"isDiscrete,omitempty"`
}

type CreateCueInput struct {
	Name        string                         `json:"name"`
	CueNumber   float64                        `json:"cueNumber"`
	CueListID   string                         `json:"cueListId"`
	SceneID     string                         `json:"sceneId"`
	FadeInTime  float64                        `json:"fadeInTime"`
	FadeOutTime float64                        `json:"fadeOutTime"`
	FollowTime  graphql.Omittable[*float64]    `json:"followTime,omitempty"`
	EasingType  graphql.Omittable[*EasingType] `json:"easingType,omitempty"`
	Notes       graphql.Omittable[*string]     `json:"notes,omitempty"`
}

type CreateCueListInput struct {
	Name        string                     `json:"name"`
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	Loop        graphql.Omittable[*bool]   `json:"loop,omitempty"`
	ProjectID   string                     `json:"projectId"`
}

type CreateFixtureDefinitionInput struct {
	Manufacturer string                          `json:"manufacturer"`
	Model        string                          `json:"model"`
	Type         FixtureType                     `json:"type"`
	Channels     []*CreateChannelDefinitionInput `json:"channels"`
}

type CreateFixtureInstanceInput struct {
	Name         string                      `json:"name"`
	Description  graphql.Omittable[*string]  `json:"description,omitempty"`
	DefinitionID string                      `json:"definitionId"`
	ModeID       graphql.Omittable[*string]  `json:"modeId,omitempty"`
	ProjectID    string                      `json:"projectId"`
	Universe     int                         `json:"universe"`
	StartChannel int                         `json:"startChannel"`
	Tags         graphql.Omittable[[]string] `json:"tags,omitempty"`
}

type CreateProjectInput struct {
	Name        string                     `json:"name"`
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type CreateSceneBoardButtonInput struct {
	SceneBoardID string                     `json:"sceneBoardId"`
	SceneID      string                     `json:"sceneId"`
	LayoutX      int                        `json:"layoutX"`
	LayoutY      int                        `json:"layoutY"`
	Width        graphql.Omittable[*int]    `json:"width,omitempty"`
	Height       graphql.Omittable[*int]    `json:"height,omitempty"`
	Color        graphql.Omittable[*string] `json:"color,omitempty"`
	Label        graphql.Omittable[*string] `json:"label,omitempty"`
}

type CreateSceneBoardInput struct {
	Name            string                      `json:"name"`
	Description     graphql.Omittable[*string]  `json:"description,omitempty"`
	ProjectID       string                      `json:"projectId"`
	DefaultFadeTime graphql.Omittable[*float64] `json:"defaultFadeTime,omitempty"`
	GridSize        graphql.Omittable[*int]     `json:"gridSize,omitempty"`
	CanvasWidth     graphql.Omittable[*int]     `json:"canvasWidth,omitempty"`
	CanvasHeight    graphql.Omittable[*int]     `json:"canvasHeight,omitempty"`
}

type CreateSceneInput struct {
	Name          string                     `json:"name"`
	Description   graphql.Omittable[*string] `json:"description,omitempty"`
	ProjectID     string                     `json:"projectId"`
	FixtureValues []*FixtureValueInput       `json:"fixtureValues"`
}

type CueListPlaybackStatus struct {
	CueListID       string `json:"cueListId"`
	CurrentCueIndex *int   `json:"currentCueIndex,omitempty"`
	// True when a scene's values are currently active on DMX fixtures (stays true after fade completes until stopped)
	IsPlaying bool `json:"isPlaying"`
	// True when a fade-in transition is in progress
	IsFading     bool        `json:"isFading"`
	CurrentCue   *models.Cue `json:"currentCue,omitempty"`
	NextCue      *models.Cue `json:"nextCue,omitempty"`
	PreviousCue  *models.Cue `json:"previousCue,omitempty"`
	FadeProgress *float64    `json:"fadeProgress,omitempty"`
	LastUpdated  string      `json:"lastUpdated"`
}

type CueListSummary struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	Description   *string `json:"description,omitempty"`
	CueCount      int     `json:"cueCount"`
	TotalDuration float64 `json:"totalDuration"`
	Loop          bool    `json:"loop"`
	CreatedAt     string  `json:"createdAt"`
}

type CueListUpdateItem struct {
	CueListID   string                     `json:"cueListId"`
	Name        graphql.Omittable[*string] `json:"name,omitempty"`
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	Loop        graphql.Omittable[*bool]   `json:"loop,omitempty"`
}

type CueOrderInput struct {
	CueID     string  `json:"cueId"`
	CueNumber float64 `json:"cueNumber"`
}

type CuePage struct {
	Cues       []*models.Cue  `json:"cues"`
	Pagination PaginationInfo `json:"pagination"`
}

type CueUsageSummary struct {
	CueID       string  `json:"cueId"`
	CueNumber   float64 `json:"cueNumber"`
	CueName     string  `json:"cueName"`
	CueListID   string  `json:"cueListId"`
	CueListName string  `json:"cueListName"`
}

type ExportOptionsInput struct {
	Description     graphql.Omittable[*string] `json:"description,omitempty"`
	IncludeFixtures graphql.Omittable[*bool]   `json:"includeFixtures,omitempty"`
	IncludeScenes   graphql.Omittable[*bool]   `json:"includeScenes,omitempty"`
	IncludeCueLists graphql.Omittable[*bool]   `json:"includeCueLists,omitempty"`
}

type ExportResult struct {
	ProjectID   string      `json:"projectId"`
	ProjectName string      `json:"projectName"`
	JSONContent string      `json:"jsonContent"`
	Stats       ExportStats `json:"stats"`
}

type ExportStats struct {
	FixtureDefinitionsCount int `json:"fixtureDefinitionsCount"`
	FixtureInstancesCount   int `json:"fixtureInstancesCount"`
	ScenesCount             int `json:"scenesCount"`
	CueListsCount           int `json:"cueListsCount"`
	CuesCount               int `json:"cuesCount"`
}

type FixtureChannelAssignment struct {
	FixtureName  string  `json:"fixtureName"`
	Manufacturer string  `json:"manufacturer"`
	Model        string  `json:"model"`
	Mode         *string `json:"mode,omitempty"`
	StartChannel int     `json:"startChannel"`
	EndChannel   int     `json:"endChannel"`
	ChannelCount int     `json:"channelCount"`
	ChannelRange string  `json:"channelRange"`
}

type FixtureDefinitionFilter struct {
	Manufacturer graphql.Omittable[*string]       `json:"manufacturer,omitempty"`
	Model        graphql.Omittable[*string]       `json:"model,omitempty"`
	Type         graphql.Omittable[*FixtureType]  `json:"type,omitempty"`
	IsBuiltIn    graphql.Omittable[*bool]         `json:"isBuiltIn,omitempty"`
	ChannelTypes graphql.Omittable[[]ChannelType] `json:"channelTypes,omitempty"`
}

type FixtureDefinitionUpdateItem struct {
	DefinitionID string                          `json:"definitionId"`
	Manufacturer graphql.Omittable[*string]      `json:"manufacturer,omitempty"`
	Model        graphql.Omittable[*string]      `json:"model,omitempty"`
	Type         graphql.Omittable[*FixtureType] `json:"type,omitempty"`
}

type FixtureFilterInput struct {
	Type         graphql.Omittable[*FixtureType] `json:"type,omitempty"`
	Universe     graphql.Omittable[*int]         `json:"universe,omitempty"`
	Tags         graphql.Omittable[[]string]     `json:"tags,omitempty"`
	Manufacturer graphql.Omittable[*string]      `json:"manufacturer,omitempty"`
	Model        graphql.Omittable[*string]      `json:"model,omitempty"`
}

type FixtureInstancePage struct {
	Fixtures   []*models.FixtureInstance `json:"fixtures"`
	Pagination PaginationInfo            `json:"pagination"`
}

type FixtureMapping struct {
	LacyLightsKey   string `json:"lacyLightsKey"`
	QlcManufacturer string `json:"qlcManufacturer"`
	QlcModel        string `json:"qlcModel"`
	QlcMode         string `json:"qlcMode"`
}

type FixtureMappingInput struct {
	LacyLightsKey   string `json:"lacyLightsKey"`
	QlcManufacturer string `json:"qlcManufacturer"`
	QlcModel        string `json:"qlcModel"`
	QlcMode         string `json:"qlcMode"`
}

type FixtureMappingSuggestion struct {
	Fixture     LacyLightsFixture       `json:"fixture"`
	Suggestions []*QLCFixtureDefinition `json:"suggestions"`
}

type FixtureOrderInput struct {
	FixtureID string `json:"fixtureId"`
	Order     int    `json:"order"`
}

type FixturePositionInput struct {
	FixtureID      string                      `json:"fixtureId"`
	LayoutX        float64                     `json:"layoutX"`
	LayoutY        float64                     `json:"layoutY"`
	LayoutRotation graphql.Omittable[*float64] `json:"layoutRotation,omitempty"`
}

type FixtureSpecInput struct {
	Name         string                     `json:"name"`
	Manufacturer string                     `json:"manufacturer"`
	Model        string                     `json:"model"`
	Mode         graphql.Omittable[*string] `json:"mode,omitempty"`
	ChannelCount graphql.Omittable[*int]    `json:"channelCount,omitempty"`
}

type FixtureUpdateItem struct {
	FixtureID      string                      `json:"fixtureId"`
	Name           graphql.Omittable[*string]  `json:"name,omitempty"`
	Description    graphql.Omittable[*string]  `json:"description,omitempty"`
	Universe       graphql.Omittable[*int]     `json:"universe,omitempty"`
	StartChannel   graphql.Omittable[*int]     `json:"startChannel,omitempty"`
	Tags           graphql.Omittable[[]string] `json:"tags,omitempty"`
	LayoutX        graphql.Omittable[*float64] `json:"layoutX,omitempty"`
	LayoutY        graphql.Omittable[*float64] `json:"layoutY,omitempty"`
	LayoutRotation graphql.Omittable[*float64] `json:"layoutRotation,omitempty"`
}

type FixtureUsage struct {
	FixtureID   string             `json:"fixtureId"`
	FixtureName string             `json:"fixtureName"`
	Scenes      []*SceneSummary    `json:"scenes"`
	Cues        []*CueUsageSummary `json:"cues"`
}

type FixtureValueInput struct {
	FixtureID  string                  `json:"fixtureId"`
	Channels   []*ChannelValueInput    `json:"channels"`
	SceneOrder graphql.Omittable[*int] `json:"sceneOrder,omitempty"`
}

type ImportOFLFixtureInput struct {
	Manufacturer   string                   `json:"manufacturer"`
	OflFixtureJSON string                   `json:"oflFixtureJson"`
	Replace        graphql.Omittable[*bool] `json:"replace,omitempty"`
}

type ImportOptionsInput struct {
	Mode                    ImportMode                                  `json:"mode"`
	TargetProjectID         graphql.Omittable[*string]                  `json:"targetProjectId,omitempty"`
	ProjectName             graphql.Omittable[*string]                  `json:"projectName,omitempty"`
	FixtureConflictStrategy graphql.Omittable[*FixtureConflictStrategy] `json:"fixtureConflictStrategy,omitempty"`
	ImportBuiltInFixtures   graphql.Omittable[*bool]                    `json:"importBuiltInFixtures,omitempty"`
}

type ImportResult struct {
	ProjectID string      `json:"projectId"`
	Stats     ImportStats `json:"stats"`
	Warnings  []string    `json:"warnings"`
}

type ImportStats struct {
	FixtureDefinitionsCreated int `json:"fixtureDefinitionsCreated"`
	FixtureInstancesCreated   int `json:"fixtureInstancesCreated"`
	ScenesCreated             int `json:"scenesCreated"`
	CueListsCreated           int `json:"cueListsCreated"`
	CuesCreated               int `json:"cuesCreated"`
}

type LacyLightsFixture struct {
	Manufacturer string `json:"manufacturer"`
	Model        string `json:"model"`
}

type Mutation struct {
}

type NetworkInterfaceOption struct {
	Name          string `json:"name"`
	Address       string `json:"address"`
	Broadcast     string `json:"broadcast"`
	Description   string `json:"description"`
	InterfaceType string `json:"interfaceType"`
}

// Information about a fixture that may need updating
type OFLFixtureUpdate struct {
	// Unique key (manufacturer/model)
	FixtureKey string `json:"fixtureKey"`
	// Manufacturer name
	Manufacturer string `json:"manufacturer"`
	// Model name
	Model string `json:"model"`
	// Type of change
	ChangeType OFLFixtureChangeType `json:"changeType"`
	// Whether this fixture is currently in use by any project
	IsInUse bool `json:"isInUse"`
	// Number of instances using this definition
	InstanceCount int `json:"instanceCount"`
	// Current hash (null if new)
	CurrentHash *string `json:"currentHash,omitempty"`
	// New hash from OFL
	NewHash string `json:"newHash"`
}

// Options for triggering an OFL import
type OFLImportOptionsInput struct {
	// Force reimport of all fixtures, even if unchanged
	ForceReimport graphql.Omittable[*bool] `json:"forceReimport,omitempty"`
	// Update fixtures that are currently in use by projects
	UpdateInUseFixtures graphql.Omittable[*bool] `json:"updateInUseFixtures,omitempty"`
	// Only import specific manufacturers (empty = all)
	Manufacturers graphql.Omittable[[]string] `json:"manufacturers,omitempty"`
	// Prefer bundled data over fetching from GitHub
	PreferBundled graphql.Omittable[*bool] `json:"preferBundled,omitempty"`
}

// Final result of an OFL import operation
type OFLImportResult struct {
	Success      bool           `json:"success"`
	Stats        OFLImportStats `json:"stats"`
	ErrorMessage *string        `json:"errorMessage,omitempty"`
	OflVersion   string         `json:"oflVersion"`
}

// Statistics about an OFL import
type OFLImportStats struct {
	TotalProcessed    int     `json:"totalProcessed"`
	SuccessfulImports int     `json:"successfulImports"`
	FailedImports     int     `json:"failedImports"`
	SkippedDuplicates int     `json:"skippedDuplicates"`
	UpdatedFixtures   int     `json:"updatedFixtures"`
	DurationSeconds   float64 `json:"durationSeconds"`
}

// Real-time status of an OFL import operation
type OFLImportStatus struct {
	// Whether an import is currently in progress
	IsImporting bool `json:"isImporting"`
	// Current phase of the import
	Phase OFLImportPhase `json:"phase"`
	// Total number of fixtures to import
	TotalFixtures int `json:"totalFixtures"`
	// Number of fixtures successfully imported
	ImportedCount int `json:"importedCount"`
	// Number of fixtures that failed to import
	FailedCount int `json:"failedCount"`
	// Number of fixtures skipped (already exist)
	SkippedCount int `json:"skippedCount"`
	// Percentage complete (0-100)
	PercentComplete float64 `json:"percentComplete"`
	// Name of the current fixture being imported
	CurrentFixture *string `json:"currentFixture,omitempty"`
	// Current manufacturer being processed
	CurrentManufacturer *string `json:"currentManufacturer,omitempty"`
	// Estimated seconds remaining (null if unknown)
	EstimatedSecondsRemaining *int `json:"estimatedSecondsRemaining,omitempty"`
	// Error message if phase is FAILED
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// When the import started
	StartedAt *string `json:"startedAt,omitempty"`
	// When the import completed (if done)
	CompletedAt *string `json:"completedAt,omitempty"`
	// OFL version/commit being imported
	OflVersion *string `json:"oflVersion,omitempty"`
	// Whether using bundled data (offline) or fetched from GitHub
	UsingBundledData bool `json:"usingBundledData"`
}

// Result of checking for OFL updates
type OFLUpdateCheckResult struct {
	// Total fixtures in current database
	CurrentFixtureCount int `json:"currentFixtureCount"`
	// Total fixtures in OFL source
	OflFixtureCount int `json:"oflFixtureCount"`
	// Number of new fixtures available
	NewFixtureCount int `json:"newFixtureCount"`
	// Number of changed fixtures
	ChangedFixtureCount int `json:"changedFixtureCount"`
	// Number of changed fixtures that are in use
	ChangedInUseCount int `json:"changedInUseCount"`
	// Detailed list of fixture changes (limited)
	FixtureUpdates []*OFLFixtureUpdate `json:"fixtureUpdates"`
	// OFL version/commit being checked
	OflVersion string `json:"oflVersion"`
	// When this check was performed
	CheckedAt string `json:"checkedAt"`
}

type PaginationInfo struct {
	Total      int  `json:"total"`
	Page       int  `json:"page"`
	PerPage    int  `json:"perPage"`
	TotalPages int  `json:"totalPages"`
	HasMore    bool `json:"hasMore"`
}

type ProjectUpdateItem struct {
	ProjectID   string                     `json:"projectId"`
	Name        graphql.Omittable[*string] `json:"name,omitempty"`
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type QLCExportResult struct {
	ProjectName  string `json:"projectName"`
	XMLContent   string `json:"xmlContent"`
	FixtureCount int    `json:"fixtureCount"`
	SceneCount   int    `json:"sceneCount"`
	CueListCount int    `json:"cueListCount"`
}

type QLCFixtureDefinition struct {
	Manufacturer string            `json:"manufacturer"`
	Model        string            `json:"model"`
	Type         string            `json:"type"`
	Modes        []*QLCFixtureMode `json:"modes"`
}

type QLCFixtureMappingResult struct {
	ProjectID          string                      `json:"projectId"`
	LacyLightsFixtures []*LacyLightsFixture        `json:"lacyLightsFixtures"`
	Suggestions        []*FixtureMappingSuggestion `json:"suggestions"`
	DefaultMappings    []*FixtureMapping           `json:"defaultMappings"`
}

type QLCFixtureMode struct {
	Name         string `json:"name"`
	ChannelCount int    `json:"channelCount"`
}

type QLCImportResult struct {
	Project          models.Project `json:"project"`
	OriginalFileName string         `json:"originalFileName"`
	FixtureCount     int            `json:"fixtureCount"`
	SceneCount       int            `json:"sceneCount"`
	CueListCount     int            `json:"cueListCount"`
	Warnings         []string       `json:"warnings"`
}

type Query struct {
}

type RepositoryVersion struct {
	Repository      string `json:"repository"`
	Installed       string `json:"installed"`
	Latest          string `json:"latest"`
	UpdateAvailable bool   `json:"updateAvailable"`
}

type SceneBoardButtonPositionInput struct {
	ButtonID string `json:"buttonId"`
	LayoutX  int    `json:"layoutX"`
	LayoutY  int    `json:"layoutY"`
}

type SceneBoardButtonUpdateItem struct {
	ButtonID string                     `json:"buttonId"`
	LayoutX  graphql.Omittable[*int]    `json:"layoutX,omitempty"`
	LayoutY  graphql.Omittable[*int]    `json:"layoutY,omitempty"`
	Width    graphql.Omittable[*int]    `json:"width,omitempty"`
	Height   graphql.Omittable[*int]    `json:"height,omitempty"`
	Color    graphql.Omittable[*string] `json:"color,omitempty"`
	Label    graphql.Omittable[*string] `json:"label,omitempty"`
}

type SceneBoardUpdateItem struct {
	SceneBoardID    string                      `json:"sceneBoardId"`
	Name            graphql.Omittable[*string]  `json:"name,omitempty"`
	Description     graphql.Omittable[*string]  `json:"description,omitempty"`
	DefaultFadeTime graphql.Omittable[*float64] `json:"defaultFadeTime,omitempty"`
	GridSize        graphql.Omittable[*int]     `json:"gridSize,omitempty"`
	CanvasWidth     graphql.Omittable[*int]     `json:"canvasWidth,omitempty"`
	CanvasHeight    graphql.Omittable[*int]     `json:"canvasHeight,omitempty"`
}

type SceneComparison struct {
	Scene1                SceneSummary       `json:"scene1"`
	Scene2                SceneSummary       `json:"scene2"`
	Differences           []*SceneDifference `json:"differences"`
	IdenticalFixtureCount int                `json:"identicalFixtureCount"`
	DifferentFixtureCount int                `json:"differentFixtureCount"`
}

type SceneDifference struct {
	FixtureID      string         `json:"fixtureId"`
	FixtureName    string         `json:"fixtureName"`
	DifferenceType DifferenceType `json:"differenceType"`
	Scene1Values   []int          `json:"scene1Values,omitempty"`
	Scene2Values   []int          `json:"scene2Values,omitempty"`
}

type SceneFilterInput struct {
	NameContains graphql.Omittable[*string] `json:"nameContains,omitempty"`
	UsesFixture  graphql.Omittable[*string] `json:"usesFixture,omitempty"`
}

type SceneFixtureSummary struct {
	FixtureID   string      `json:"fixtureId"`
	FixtureName string      `json:"fixtureName"`
	FixtureType FixtureType `json:"fixtureType"`
}

type ScenePage struct {
	Scenes     []*SceneSummary `json:"scenes"`
	Pagination PaginationInfo  `json:"pagination"`
}

type SceneSummary struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Description  *string `json:"description,omitempty"`
	FixtureCount int     `json:"fixtureCount"`
	CreatedAt    string  `json:"createdAt"`
	UpdatedAt    string  `json:"updatedAt"`
}

type SceneUpdateItem struct {
	SceneID     string                     `json:"sceneId"`
	Name        graphql.Omittable[*string] `json:"name,omitempty"`
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type SceneUsage struct {
	SceneID   string             `json:"sceneId"`
	SceneName string             `json:"sceneName"`
	Cues      []*CueUsageSummary `json:"cues"`
}

type Subscription struct {
}

type SystemInfo struct {
	ArtnetBroadcastAddress string `json:"artnetBroadcastAddress"`
	ArtnetEnabled          bool   `json:"artnetEnabled"`
}

type SystemVersionInfo struct {
	Repositories               []*RepositoryVersion `json:"repositories"`
	LastChecked                string               `json:"lastChecked"`
	VersionManagementSupported bool                 `json:"versionManagementSupported"`
}

type UniverseChannelMap struct {
	Universe          int                  `json:"universe"`
	Fixtures          []*ChannelMapFixture `json:"fixtures"`
	ChannelUsage      []*ChannelUsage      `json:"channelUsage"`
	AvailableChannels int                  `json:"availableChannels"`
	UsedChannels      int                  `json:"usedChannels"`
}

type UniverseOutput struct {
	Universe int   `json:"universe"`
	Channels []int `json:"channels"`
}

type UpdateFixtureInstanceInput struct {
	Name           graphql.Omittable[*string]  `json:"name,omitempty"`
	Description    graphql.Omittable[*string]  `json:"description,omitempty"`
	DefinitionID   graphql.Omittable[*string]  `json:"definitionId,omitempty"`
	ModeID         graphql.Omittable[*string]  `json:"modeId,omitempty"`
	Universe       graphql.Omittable[*int]     `json:"universe,omitempty"`
	StartChannel   graphql.Omittable[*int]     `json:"startChannel,omitempty"`
	Tags           graphql.Omittable[[]string] `json:"tags,omitempty"`
	ProjectOrder   graphql.Omittable[*int]     `json:"projectOrder,omitempty"`
	LayoutX        graphql.Omittable[*float64] `json:"layoutX,omitempty"`
	LayoutY        graphql.Omittable[*float64] `json:"layoutY,omitempty"`
	LayoutRotation graphql.Omittable[*float64] `json:"layoutRotation,omitempty"`
}

type UpdateResult struct {
	Success         bool    `json:"success"`
	Repository      string  `json:"repository"`
	PreviousVersion string  `json:"previousVersion"`
	NewVersion      string  `json:"newVersion"`
	Message         *string `json:"message,omitempty"`
	Error           *string `json:"error,omitempty"`
}

type UpdateSceneBoardButtonInput struct {
	LayoutX graphql.Omittable[*int]    `json:"layoutX,omitempty"`
	LayoutY graphql.Omittable[*int]    `json:"layoutY,omitempty"`
	Width   graphql.Omittable[*int]    `json:"width,omitempty"`
	Height  graphql.Omittable[*int]    `json:"height,omitempty"`
	Color   graphql.Omittable[*string] `json:"color,omitempty"`
	Label   graphql.Omittable[*string] `json:"label,omitempty"`
}

type UpdateSceneBoardInput struct {
	Name            graphql.Omittable[*string]  `json:"name,omitempty"`
	Description     graphql.Omittable[*string]  `json:"description,omitempty"`
	DefaultFadeTime graphql.Omittable[*float64] `json:"defaultFadeTime,omitempty"`
	GridSize        graphql.Omittable[*int]     `json:"gridSize,omitempty"`
	CanvasWidth     graphql.Omittable[*int]     `json:"canvasWidth,omitempty"`
	CanvasHeight    graphql.Omittable[*int]     `json:"canvasHeight,omitempty"`
}

type UpdateSceneInput struct {
	Name          graphql.Omittable[*string]              `json:"name,omitempty"`
	Description   graphql.Omittable[*string]              `json:"description,omitempty"`
	FixtureValues graphql.Omittable[[]*FixtureValueInput] `json:"fixtureValues,omitempty"`
}

type UpdateSettingInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type WiFiConnectionResult struct {
	Success   bool    `json:"success"`
	Message   *string `json:"message,omitempty"`
	Connected bool    `json:"connected"`
}

type WiFiNetwork struct {
	Ssid           string           `json:"ssid"`
	SignalStrength int              `json:"signalStrength"`
	Frequency      string           `json:"frequency"`
	Security       WiFiSecurityType `json:"security"`
	InUse          bool             `json:"inUse"`
	Saved          bool             `json:"saved"`
}

type WiFiStatus struct {
	Available      bool    `json:"available"`
	Enabled        bool    `json:"enabled"`
	Connected      bool    `json:"connected"`
	Ssid           *string `json:"ssid,omitempty"`
	SignalStrength *int    `json:"signalStrength,omitempty"`
	IPAddress      *string `json:"ipAddress,omitempty"`
	MacAddress     *string `json:"macAddress,omitempty"`
	Frequency      *string `json:"frequency,omitempty"`
}

type ChannelType string

const (
	ChannelTypeIntensity  ChannelType = "INTENSITY"
	ChannelTypeRed        ChannelType = "RED"
	ChannelTypeGreen      ChannelType = "GREEN"
	ChannelTypeBlue       ChannelType = "BLUE"
	ChannelTypeWhite      ChannelType = "WHITE"
	ChannelTypeAmber      ChannelType = "AMBER"
	ChannelTypeUv         ChannelType = "UV"
	ChannelTypePan        ChannelType = "PAN"
	ChannelTypeTilt       ChannelType = "TILT"
	ChannelTypeZoom       ChannelType = "ZOOM"
	ChannelTypeFocus      ChannelType = "FOCUS"
	ChannelTypeIris       ChannelType = "IRIS"
	ChannelTypeGobo       ChannelType = "GOBO"
	ChannelTypeColorWheel ChannelType = "COLOR_WHEEL"
	ChannelTypeEffect     ChannelType = "EFFECT"
	ChannelTypeStrobe     ChannelType = "STROBE"
	ChannelTypeMacro      ChannelType = "MACRO"
	ChannelTypeOther      ChannelType = "OTHER"
)

var AllChannelType = []ChannelType{
	ChannelTypeIntensity,
	ChannelTypeRed,
	ChannelTypeGreen,
	ChannelTypeBlue,
	ChannelTypeWhite,
	ChannelTypeAmber,
	ChannelTypeUv,
	ChannelTypePan,
	ChannelTypeTilt,
	ChannelTypeZoom,
	ChannelTypeFocus,
	ChannelTypeIris,
	ChannelTypeGobo,
	ChannelTypeColorWheel,
	ChannelTypeEffect,
	ChannelTypeStrobe,
	ChannelTypeMacro,
	ChannelTypeOther,
}

func (e ChannelType) IsValid() bool {
	switch e {
	case ChannelTypeIntensity, ChannelTypeRed, ChannelTypeGreen, ChannelTypeBlue, ChannelTypeWhite, ChannelTypeAmber, ChannelTypeUv, ChannelTypePan, ChannelTypeTilt, ChannelTypeZoom, ChannelTypeFocus, ChannelTypeIris, ChannelTypeGobo, ChannelTypeColorWheel, ChannelTypeEffect, ChannelTypeStrobe, ChannelTypeMacro, ChannelTypeOther:
		return true
	}
	return false
}

func (e ChannelType) String() string {
	return string(e)
}

func (e *ChannelType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelType", str)
	}
	return nil
}

func (e ChannelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChannelType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChannelType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DifferenceType string

const (
	DifferenceTypeValuesChanged DifferenceType = "VALUES_CHANGED"
	DifferenceTypeOnlyInScene1  DifferenceType = "ONLY_IN_SCENE1"
	DifferenceTypeOnlyInScene2  DifferenceType = "ONLY_IN_SCENE2"
)

var AllDifferenceType = []DifferenceType{
	DifferenceTypeValuesChanged,
	DifferenceTypeOnlyInScene1,
	DifferenceTypeOnlyInScene2,
}

func (e DifferenceType) IsValid() bool {
	switch e {
	case DifferenceTypeValuesChanged, DifferenceTypeOnlyInScene1, DifferenceTypeOnlyInScene2:
		return true
	}
	return false
}

func (e DifferenceType) String() string {
	return string(e)
}

func (e *DifferenceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DifferenceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DifferenceType", str)
	}
	return nil
}

func (e DifferenceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DifferenceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DifferenceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EasingType string

const (
	EasingTypeLinear             EasingType = "LINEAR"
	EasingTypeEaseInOutCubic     EasingType = "EASE_IN_OUT_CUBIC"
	EasingTypeEaseInOutSine      EasingType = "EASE_IN_OUT_SINE"
	EasingTypeEaseOutExponential EasingType = "EASE_OUT_EXPONENTIAL"
	EasingTypeBezier             EasingType = "BEZIER"
	EasingTypeSCurve             EasingType = "S_CURVE"
)

var AllEasingType = []EasingType{
	EasingTypeLinear,
	EasingTypeEaseInOutCubic,
	EasingTypeEaseInOutSine,
	EasingTypeEaseOutExponential,
	EasingTypeBezier,
	EasingTypeSCurve,
}

func (e EasingType) IsValid() bool {
	switch e {
	case EasingTypeLinear, EasingTypeEaseInOutCubic, EasingTypeEaseInOutSine, EasingTypeEaseOutExponential, EasingTypeBezier, EasingTypeSCurve:
		return true
	}
	return false
}

func (e EasingType) String() string {
	return string(e)
}

func (e *EasingType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EasingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EasingType", str)
	}
	return nil
}

func (e EasingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EasingType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EasingType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Determines how a channel behaves during scene transitions.
// FADE - Interpolate smoothly between values (default for intensity, colors)
// SNAP - Jump to target value at start of transition (for gobos, macros, effects)
// SNAP_END - Jump to target value at end of transition
type FadeBehavior string

const (
	FadeBehaviorFade    FadeBehavior = "FADE"
	FadeBehaviorSnap    FadeBehavior = "SNAP"
	FadeBehaviorSnapEnd FadeBehavior = "SNAP_END"
)

var AllFadeBehavior = []FadeBehavior{
	FadeBehaviorFade,
	FadeBehaviorSnap,
	FadeBehaviorSnapEnd,
}

func (e FadeBehavior) IsValid() bool {
	switch e {
	case FadeBehaviorFade, FadeBehaviorSnap, FadeBehaviorSnapEnd:
		return true
	}
	return false
}

func (e FadeBehavior) String() string {
	return string(e)
}

func (e *FadeBehavior) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FadeBehavior(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FadeBehavior", str)
	}
	return nil
}

func (e FadeBehavior) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FadeBehavior) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FadeBehavior) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FixtureConflictStrategy string

const (
	FixtureConflictStrategySkip    FixtureConflictStrategy = "SKIP"
	FixtureConflictStrategyReplace FixtureConflictStrategy = "REPLACE"
	FixtureConflictStrategyError   FixtureConflictStrategy = "ERROR"
)

var AllFixtureConflictStrategy = []FixtureConflictStrategy{
	FixtureConflictStrategySkip,
	FixtureConflictStrategyReplace,
	FixtureConflictStrategyError,
}

func (e FixtureConflictStrategy) IsValid() bool {
	switch e {
	case FixtureConflictStrategySkip, FixtureConflictStrategyReplace, FixtureConflictStrategyError:
		return true
	}
	return false
}

func (e FixtureConflictStrategy) String() string {
	return string(e)
}

func (e *FixtureConflictStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixtureConflictStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixtureConflictStrategy", str)
	}
	return nil
}

func (e FixtureConflictStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FixtureConflictStrategy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FixtureConflictStrategy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FixtureType string

const (
	FixtureTypeLedPar     FixtureType = "LED_PAR"
	FixtureTypeMovingHead FixtureType = "MOVING_HEAD"
	FixtureTypeStrobe     FixtureType = "STROBE"
	FixtureTypeDimmer     FixtureType = "DIMMER"
	FixtureTypeOther      FixtureType = "OTHER"
)

var AllFixtureType = []FixtureType{
	FixtureTypeLedPar,
	FixtureTypeMovingHead,
	FixtureTypeStrobe,
	FixtureTypeDimmer,
	FixtureTypeOther,
}

func (e FixtureType) IsValid() bool {
	switch e {
	case FixtureTypeLedPar, FixtureTypeMovingHead, FixtureTypeStrobe, FixtureTypeDimmer, FixtureTypeOther:
		return true
	}
	return false
}

func (e FixtureType) String() string {
	return string(e)
}

func (e *FixtureType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixtureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixtureType", str)
	}
	return nil
}

func (e FixtureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FixtureType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FixtureType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ImportMode string

const (
	ImportModeCreate ImportMode = "CREATE"
	ImportModeMerge  ImportMode = "MERGE"
)

var AllImportMode = []ImportMode{
	ImportModeCreate,
	ImportModeMerge,
}

func (e ImportMode) IsValid() bool {
	switch e {
	case ImportModeCreate, ImportModeMerge:
		return true
	}
	return false
}

func (e ImportMode) String() string {
	return string(e)
}

func (e *ImportMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportMode", str)
	}
	return nil
}

func (e ImportMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImportMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImportMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of fixture change detected during OFL update check
type OFLFixtureChangeType string

const (
	OFLFixtureChangeTypeNew       OFLFixtureChangeType = "NEW"
	OFLFixtureChangeTypeUpdated   OFLFixtureChangeType = "UPDATED"
	OFLFixtureChangeTypeUnchanged OFLFixtureChangeType = "UNCHANGED"
)

var AllOFLFixtureChangeType = []OFLFixtureChangeType{
	OFLFixtureChangeTypeNew,
	OFLFixtureChangeTypeUpdated,
	OFLFixtureChangeTypeUnchanged,
}

func (e OFLFixtureChangeType) IsValid() bool {
	switch e {
	case OFLFixtureChangeTypeNew, OFLFixtureChangeTypeUpdated, OFLFixtureChangeTypeUnchanged:
		return true
	}
	return false
}

func (e OFLFixtureChangeType) String() string {
	return string(e)
}

func (e *OFLFixtureChangeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OFLFixtureChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OFLFixtureChangeType", str)
	}
	return nil
}

func (e OFLFixtureChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OFLFixtureChangeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OFLFixtureChangeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Phases of the OFL import process
type OFLImportPhase string

const (
	OFLImportPhaseIdle        OFLImportPhase = "IDLE"
	OFLImportPhaseDownloading OFLImportPhase = "DOWNLOADING"
	OFLImportPhaseExtracting  OFLImportPhase = "EXTRACTING"
	OFLImportPhaseParsing     OFLImportPhase = "PARSING"
	OFLImportPhaseImporting   OFLImportPhase = "IMPORTING"
	OFLImportPhaseComplete    OFLImportPhase = "COMPLETE"
	OFLImportPhaseFailed      OFLImportPhase = "FAILED"
	OFLImportPhaseCancelled   OFLImportPhase = "CANCELLED"
)

var AllOFLImportPhase = []OFLImportPhase{
	OFLImportPhaseIdle,
	OFLImportPhaseDownloading,
	OFLImportPhaseExtracting,
	OFLImportPhaseParsing,
	OFLImportPhaseImporting,
	OFLImportPhaseComplete,
	OFLImportPhaseFailed,
	OFLImportPhaseCancelled,
}

func (e OFLImportPhase) IsValid() bool {
	switch e {
	case OFLImportPhaseIdle, OFLImportPhaseDownloading, OFLImportPhaseExtracting, OFLImportPhaseParsing, OFLImportPhaseImporting, OFLImportPhaseComplete, OFLImportPhaseFailed, OFLImportPhaseCancelled:
		return true
	}
	return false
}

func (e OFLImportPhase) String() string {
	return string(e)
}

func (e *OFLImportPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OFLImportPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OFLImportPhase", str)
	}
	return nil
}

func (e OFLImportPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OFLImportPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OFLImportPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ProjectRole string

const (
	ProjectRoleOwner  ProjectRole = "OWNER"
	ProjectRoleEditor ProjectRole = "EDITOR"
	ProjectRoleViewer ProjectRole = "VIEWER"
)

var AllProjectRole = []ProjectRole{
	ProjectRoleOwner,
	ProjectRoleEditor,
	ProjectRoleViewer,
}

func (e ProjectRole) IsValid() bool {
	switch e {
	case ProjectRoleOwner, ProjectRoleEditor, ProjectRoleViewer:
		return true
	}
	return false
}

func (e ProjectRole) String() string {
	return string(e)
}

func (e *ProjectRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectRole", str)
	}
	return nil
}

func (e ProjectRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProjectRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProjectRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SceneSortField string

const (
	SceneSortFieldName      SceneSortField = "NAME"
	SceneSortFieldCreatedAt SceneSortField = "CREATED_AT"
	SceneSortFieldUpdatedAt SceneSortField = "UPDATED_AT"
)

var AllSceneSortField = []SceneSortField{
	SceneSortFieldName,
	SceneSortFieldCreatedAt,
	SceneSortFieldUpdatedAt,
}

func (e SceneSortField) IsValid() bool {
	switch e {
	case SceneSortFieldName, SceneSortFieldCreatedAt, SceneSortFieldUpdatedAt:
		return true
	}
	return false
}

func (e SceneSortField) String() string {
	return string(e)
}

func (e *SceneSortField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SceneSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SceneSortField", str)
	}
	return nil
}

func (e SceneSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SceneSortField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SceneSortField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserRole string

const (
	UserRoleAdmin UserRole = "ADMIN"
	UserRoleUser  UserRole = "USER"
)

var AllUserRole = []UserRole{
	UserRoleAdmin,
	UserRoleUser,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAdmin, UserRoleUser:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WiFiSecurityType string

const (
	WiFiSecurityTypeOpen    WiFiSecurityType = "OPEN"
	WiFiSecurityTypeWep     WiFiSecurityType = "WEP"
	WiFiSecurityTypeWpaPsk  WiFiSecurityType = "WPA_PSK"
	WiFiSecurityTypeWpaEap  WiFiSecurityType = "WPA_EAP"
	WiFiSecurityTypeWpa3Psk WiFiSecurityType = "WPA3_PSK"
	WiFiSecurityTypeWpa3Eap WiFiSecurityType = "WPA3_EAP"
	WiFiSecurityTypeOwe     WiFiSecurityType = "OWE"
)

var AllWiFiSecurityType = []WiFiSecurityType{
	WiFiSecurityTypeOpen,
	WiFiSecurityTypeWep,
	WiFiSecurityTypeWpaPsk,
	WiFiSecurityTypeWpaEap,
	WiFiSecurityTypeWpa3Psk,
	WiFiSecurityTypeWpa3Eap,
	WiFiSecurityTypeOwe,
}

func (e WiFiSecurityType) IsValid() bool {
	switch e {
	case WiFiSecurityTypeOpen, WiFiSecurityTypeWep, WiFiSecurityTypeWpaPsk, WiFiSecurityTypeWpaEap, WiFiSecurityTypeWpa3Psk, WiFiSecurityTypeWpa3Eap, WiFiSecurityTypeOwe:
		return true
	}
	return false
}

func (e WiFiSecurityType) String() string {
	return string(e)
}

func (e *WiFiSecurityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WiFiSecurityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WiFiSecurityType", str)
	}
	return nil
}

func (e WiFiSecurityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WiFiSecurityType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WiFiSecurityType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
