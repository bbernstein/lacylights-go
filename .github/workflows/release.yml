name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      is_prerelease:
        description: 'Create prerelease (beta) version'
        required: true
        type: boolean
        default: false
      release_name:
        description: 'Release name (optional - leave blank for auto-generated)'
        required: false
        type: string

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    env:
      COMPONENT: go
      BETA_VERSION_PATTERN: '^([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$'
      BETA_SUFFIX_PATTERN: '-beta\.[0-9]+$'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run tests before release
        run: go test -v ./...
        env:
          ARTNET_ENABLED: 'false'

      - name: Get current version
        id: current_version
        run: |
          # Get current version from latest tag
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_TAG#v}
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          VERSION_BUMP="${{ inputs.version_bump }}"
          IS_PRERELEASE="${{ inputs.is_prerelease }}"

          echo "Current version: $CURRENT_VERSION"
          echo "Version bump: $VERSION_BUMP"
          echo "Is prerelease: $IS_PRERELEASE"

          # Detect if current version is a beta (semver format: X.Y.Z-beta.[N])
          if [[ "$CURRENT_VERSION" =~ $BETA_VERSION_PATTERN ]]; then
            IS_CURRENT_BETA=true
            BASE_VERSION="${BASH_REMATCH[1]}"
            BETA_NUMBER="${BASH_REMATCH[2]}"
            echo "Detected beta: base=$BASE_VERSION, beta=$BETA_NUMBER"
          else
            IS_CURRENT_BETA=false
            BASE_VERSION="$CURRENT_VERSION"
            echo "Detected stable: $BASE_VERSION"
          fi

          # Parse base version
          IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"

          # Decision logic (semver-compatible)
          if [ "$IS_PRERELEASE" = "true" ]; then
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Next Beta (increment beta, ignore version_bump)
              BETA_NUMBER=$((BETA_NUMBER + 1))
              NEW_VERSION="${BASE_VERSION}-beta.${BETA_NUMBER}"
              echo "Scenario: Beta -> Next Beta"
            else
              # Stable -> First Beta (apply version_bump, add -beta.1)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.1"
              echo "Scenario: Stable -> First Beta"
            fi
          else
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Stable (finalize by removing beta suffix)
              NEW_VERSION="$BASE_VERSION"
              echo "Scenario: Beta -> Stable Finalization"
            else
              # Stable -> Stable (normal version bump)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
              echo "Scenario: Stable -> Stable"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Detect prerelease status
        id: prerelease_check
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          if [[ "$VERSION" =~ $BETA_SUFFIX_PATTERN ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "Detected prerelease (beta) version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "Detected stable version"
          fi

      - name: Build binaries
        run: |
          set -e
          mkdir -p dist

          # Build for multiple platforms
          PLATFORMS=(
            "linux/amd64"
            "linux/arm64"
            "linux/arm"
            "darwin/amd64"
            "darwin/arm64"
          )

          for PLATFORM in "${PLATFORMS[@]}"; do
            GOOS="${PLATFORM%/*}"
            GOARCH="${PLATFORM#*/}"
            OUTPUT="dist/lacylights-${GOOS}-${GOARCH}"

            if [ "$GOARCH" = "arm" ]; then
              GOARM=7 GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            else
              GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            fi

            echo "Built $OUTPUT"
          done

      - name: Create archives
        run: |
          cd dist
          for binary in lacylights-*; do
            tar -czf "${binary}.tar.gz" "$binary"
            rm "$binary"
          done

      - name: Create Git tag
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Check if tag exists, skip creation if it does (idempotent)
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists. Skipping creation."
          else
            git tag -a "v${VERSION}" -m "Release v${VERSION}"

            # Push with retry logic
            for i in 1 2 3; do
              if git push origin "v${VERSION}"; then
                echo "Successfully pushed tag"
                break
              fi
              echo "Push attempt $i failed, retrying..."
              sleep 5
            done
          fi

      - name: Determine release name
        id: release_name
        run: |
          if [ -z "${{ inputs.release_name }}" ]; then
            echo "name=v${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ inputs.release_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const tagName = 'v${{ steps.new_version.outputs.version }}';
            const fs = require('fs');
            const path = require('path');

            // Check if release already exists
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              core.info(`Release ${tagName} already exists. Skipping creation.`);
              return;
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            // Create the release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: '${{ steps.release_name.outputs.name }}',
              draft: false,
              prerelease: ${{ steps.prerelease_check.outputs.is_prerelease == 'true' }},
              generate_release_notes: true
            });

            // Upload assets
            const distDir = 'dist';
            const files = fs.readdirSync(distDir).filter(f => f.endsWith('.tar.gz'));

            for (const file of files) {
              const filePath = path.join(distDir, file);
              const fileContent = fs.readFileSync(filePath);

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: file,
                data: fileContent
              });

              core.info(`Uploaded ${file}`);
            }

      - name: Output summary
        run: |
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"

          echo "## Release Created Successfully! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ steps.new_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** v${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

          if [ "$IS_PRERELEASE" = "true" ]; then
            echo "**Type:** ðŸ§ª Prerelease (Beta)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Type:** âœ… Stable Release" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:**" >> $GITHUB_STEP_SUMMARY
          for f in dist/*.tar.gz; do
            echo "- $(basename $f)" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new_version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
