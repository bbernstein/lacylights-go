name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      is_prerelease:
        description: 'Create prerelease (beta) version'
        required: true
        type: boolean
        default: false
      release_name:
        description: 'Release name (optional - leave blank for auto-generated)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    env:
      COMPONENT: go
      BETA_VERSION_PATTERN: '^([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$'
      BETA_SUFFIX_PATTERN: '-beta\.[0-9]+$'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run tests before release
        run: go test -v ./...
        env:
          ARTNET_ENABLED: 'false'

      - name: Get current version
        id: current_version
        run: |
          # Get all version tags and find highest stable and highest beta separately
          # This fixes issues where git's version sort doesn't follow semver rules
          ALL_TAGS=$(git tag -l 'v*' | sed 's/^v//')

          echo "All version tags:"
          echo "$ALL_TAGS" | head -10

          # Find highest stable version (no prerelease suffix)
          HIGHEST_STABLE=$(echo "$ALL_TAGS" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n 1 || echo "")

          # Find highest beta version
          HIGHEST_BETA=$(echo "$ALL_TAGS" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+-beta\.[0-9]+$' | sort -V | tail -n 1 || echo "")

          echo "Highest stable: ${HIGHEST_STABLE:-none}"
          echo "Highest beta: ${HIGHEST_BETA:-none}"

          # Export both for use in version calculation
          echo "highest_stable=${HIGHEST_STABLE}" >> $GITHUB_OUTPUT
          echo "highest_beta=${HIGHEST_BETA}" >> $GITHUB_OUTPUT

          # Determine "current" version for display (highest of either)
          if [ -n "$HIGHEST_STABLE" ] && [ -n "$HIGHEST_BETA" ]; then
            # Compare base versions
            BETA_BASE=$(echo "$HIGHEST_BETA" | sed 's/-beta\.[0-9]*$//')
            if [ "$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | tail -n 1)" = "$HIGHEST_STABLE" ]; then
              CURRENT_VERSION="$HIGHEST_STABLE"
            else
              CURRENT_VERSION="$HIGHEST_BETA"
            fi
          elif [ -n "$HIGHEST_BETA" ]; then
            CURRENT_VERSION="$HIGHEST_BETA"
          elif [ -n "$HIGHEST_STABLE" ]; then
            CURRENT_VERSION="$HIGHEST_STABLE"
          else
            CURRENT_VERSION="0.0.0"
          fi

          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version for display: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          HIGHEST_STABLE="${{ steps.current_version.outputs.highest_stable }}"
          HIGHEST_BETA="${{ steps.current_version.outputs.highest_beta }}"
          VERSION_BUMP="${{ inputs.version_bump }}"
          IS_PRERELEASE="${{ inputs.is_prerelease }}"

          echo "Highest stable: ${HIGHEST_STABLE:-none}"
          echo "Highest beta: ${HIGHEST_BETA:-none}"
          echo "Version bump: $VERSION_BUMP"
          echo "Is prerelease: $IS_PRERELEASE"

          # Helper function to bump version
          bump_version() {
            local version="$1"
            local bump_type="$2"
            IFS='.' read -ra parts <<< "$version"
            local major="${parts[0]:-0}"
            local minor="${parts[1]:-0}"
            local patch="${parts[2]:-0}"

            case "$bump_type" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch) patch=$((patch + 1)) ;;
            esac
            echo "${major}.${minor}.${patch}"
          }

          # Parse beta info if exists
          BETA_BASE=""
          BETA_NUMBER=0
          if [ -n "$HIGHEST_BETA" ]; then
            if [[ "$HIGHEST_BETA" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$ ]]; then
              BETA_BASE="${BASH_REMATCH[1]}"
              BETA_NUMBER="${BASH_REMATCH[2]}"
            fi
          fi

          # Default stable to 0.0.0 if not set
          HIGHEST_STABLE="${HIGHEST_STABLE:-0.0.0}"

          if [ "$IS_PRERELEASE" = "true" ]; then
            # Creating a prerelease (beta)

            if [ -n "$BETA_BASE" ]; then
              # There's an existing beta series

              # Check if stable release exists for this beta's base version
              # Compare: is HIGHEST_STABLE >= BETA_BASE?
              STABLE_GTE_BETA_BASE="false"
              if [ "$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | tail -n 1)" = "$HIGHEST_STABLE" ] && [ "$HIGHEST_STABLE" != "0.0.0" ]; then
                # Also check they're not equal (if equal, beta is still valid)
                if [ "$HIGHEST_STABLE" != "$BETA_BASE" ] || [ "$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | head -n 1)" = "$BETA_BASE" ]; then
                  # Stable is > beta base, or stable == beta base (finalized)
                  if [ "$HIGHEST_STABLE" = "$BETA_BASE" ] || [ "$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | tail -n 1)" = "$HIGHEST_STABLE" ]; then
                    STABLE_GTE_BETA_BASE="true"
                  fi
                fi
              fi

              # Simpler check: does a stable release exist with version >= beta base?
              if [ "$HIGHEST_STABLE" != "0.0.0" ]; then
                COMPARE_RESULT=$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | tail -n 1)
                if [ "$COMPARE_RESULT" = "$HIGHEST_STABLE" ]; then
                  STABLE_GTE_BETA_BASE="true"
                fi
              fi

              echo "Beta base: $BETA_BASE, Stable >= Beta base: $STABLE_GTE_BETA_BASE"

              if [ "$STABLE_GTE_BETA_BASE" = "true" ]; then
                # Stable release exists for beta base version (or higher)
                # Start a NEW beta series from bumped stable version
                NEW_BASE=$(bump_version "$HIGHEST_STABLE" "$VERSION_BUMP")
                NEW_VERSION="${NEW_BASE}-beta.1"
                echo "Scenario: Stable exists for beta base -> New beta series from $HIGHEST_STABLE"
              else
                # No stable release for beta base yet, continue the beta series
                BETA_NUMBER=$((BETA_NUMBER + 1))
                NEW_VERSION="${BETA_BASE}-beta.${BETA_NUMBER}"
                echo "Scenario: Continue beta series -> ${BETA_BASE}-beta.${BETA_NUMBER}"
              fi
            else
              # No existing beta, start new beta series from stable
              NEW_BASE=$(bump_version "$HIGHEST_STABLE" "$VERSION_BUMP")
              NEW_VERSION="${NEW_BASE}-beta.1"
              echo "Scenario: No beta exists -> First beta from stable $HIGHEST_STABLE"
            fi
          else
            # Creating a stable release

            if [ -n "$BETA_BASE" ]; then
              # Check if this beta should be finalized
              # Only finalize if stable version is strictly less than beta base
              # (not equal to - if equal, beta was already finalized)

              if [ "$HIGHEST_STABLE" = "0.0.0" ]; then
                # No stable release yet -> finalize beta
                NEW_VERSION="$BETA_BASE"
                echo "Scenario: No stable exists -> Finalize beta to $BETA_BASE"
              elif [ "$HIGHEST_STABLE" = "$BETA_BASE" ]; then
                # Stable version equals beta base -> beta already finalized, do normal bump
                NEW_VERSION=$(bump_version "$HIGHEST_STABLE" "$VERSION_BUMP")
                echo "Scenario: Stable equals beta base ($HIGHEST_STABLE) -> Normal bump to $NEW_VERSION"
              else
                # Compare versions
                COMPARE_RESULT=$(printf '%s\n%s' "$HIGHEST_STABLE" "$BETA_BASE" | sort -V | tail -n 1)
                if [ "$COMPARE_RESULT" = "$BETA_BASE" ]; then
                  # Beta base is higher than stable -> finalize beta
                  NEW_VERSION="$BETA_BASE"
                  echo "Scenario: Beta base higher than stable -> Finalize beta to $BETA_BASE"
                else
                  # Stable is higher than beta base -> normal bump from stable
                  NEW_VERSION=$(bump_version "$HIGHEST_STABLE" "$VERSION_BUMP")
                  echo "Scenario: Stable higher than beta base -> Normal bump to $NEW_VERSION"
                fi
              fi
            else
              # No beta, normal stable bump
              NEW_VERSION=$(bump_version "$HIGHEST_STABLE" "$VERSION_BUMP")
              echo "Scenario: Normal stable bump -> $NEW_VERSION"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Detect prerelease status
        id: prerelease_check
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          if [[ "$VERSION" =~ $BETA_SUFFIX_PATTERN ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "Detected prerelease (beta) version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "Detected stable version"
          fi

      - name: Download OFL bundle
        run: |
          echo "Downloading Open Fixture Library for embedding..."
          ./scripts/download-ofl.sh
          # Verify bundle was downloaded
          if [ ! -f "internal/services/ofl/data/ofl-bundle.zip" ]; then
            echo "ERROR: OFL bundle download failed"
            exit 1
          fi
          ls -la internal/services/ofl/data/

      - name: Build binaries
        run: |
          set -e
          mkdir -p dist

          # Build for multiple platforms
          PLATFORMS=(
            "linux/amd64"
            "linux/arm64"
            "linux/arm"
            "darwin/amd64"
            "darwin/arm64"
          )

          # Capture build time once for all platforms - intentionally shared so all
          # binaries from the same release have identical timestamps for consistency
          BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          for PLATFORM in "${PLATFORMS[@]}"; do
            GOOS="${PLATFORM%/*}"
            GOARCH="${PLATFORM#*/}"
            OUTPUT="dist/lacylights-${GOOS}-${GOARCH}"

            LDFLAGS="-X main.Version=v${{ steps.new_version.outputs.version }} -X main.GitCommit=${{ github.sha }} -X main.BuildTime=${BUILD_TIME}"
            if [ "$GOARCH" = "arm" ]; then
              GOARM=7 GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "$LDFLAGS" -o "$OUTPUT" ./cmd/server
            else
              GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "$LDFLAGS" -o "$OUTPUT" ./cmd/server
            fi

            echo "Built $OUTPUT"
          done

      - name: Create archives
        run: |
          set -e
          cd dist
          for binary in lacylights-*; do
            # Create archive containing the binary
            tar -czf "${binary}.tar.gz" "$binary"
            echo "Created ${binary}.tar.gz"
          done
          # NOTE: We keep the raw binaries - they're needed for direct download by RPi

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          set -e
          cd dist

          # Calculate checksums for ALL files (archives AND raw binaries)
          # First checksums for archives
          > checksums.txt
          for archive in *.tar.gz; do
            sha256sum "$archive" >> checksums.txt
          done

          # Then checksums for raw binaries
          for binary in lacylights-*; do
            # Skip archives
            if [[ "$binary" == *.tar.gz ]]; then
              continue
            fi
            sha256sum "$binary" >> checksums.txt
          done

          cat checksums.txt

      - name: Calculate release metadata
        id: release_metadata
        run: |
          echo "release_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Build platforms metadata
        id: platforms
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Validate checksums file exists and is not empty
          if [ ! -f "dist/checksums.txt" ] || [ ! -s "dist/checksums.txt" ]; then
            echo "Error: checksums.txt is missing or empty"
            exit 1
          fi

          # Build platforms array with checksums
          PLATFORMS_JSON="[]"
          PLATFORMS_JSON_DYNAMODB="[]"

          # Process only tar.gz files for platform entries (to avoid duplicates)
          for archive in dist/*.tar.gz; do
            FILENAME=$(basename "$archive")

            # Get checksum for archive
            SHA256_ARCHIVE=$(grep " ${FILENAME}$" dist/checksums.txt | awk '{print $1}')

            if [ -z "$SHA256_ARCHIVE" ]; then
              echo "Error: No checksum found for $FILENAME"
              exit 1
            fi

            # Extract platform info from filename: lacylights-{os}-{arch}.tar.gz
            PLATFORM_INFO=$(echo "$FILENAME" | sed 's/lacylights-//' | sed 's/.tar.gz//')
            OS=$(echo "$PLATFORM_INFO" | cut -d- -f1)
            ARCH=$(echo "$PLATFORM_INFO" | cut -d- -f2)

            # Get corresponding raw binary name and checksum
            BINARY_NAME="lacylights-${OS}-${ARCH}"
            SHA256_BINARY=$(grep " ${BINARY_NAME}$" dist/checksums.txt | awk '{print $1}')

            if [ -z "$SHA256_BINARY" ]; then
              echo "Error: No checksum found for binary $BINARY_NAME"
              exit 1
            fi

            # Use portable file size command
            ARCHIVE_SIZE=$(wc -c < "dist/$FILENAME" | tr -d ' ')

            if [ ! -f "dist/$BINARY_NAME" ]; then
              echo "Error: Binary file not found: $BINARY_NAME"
              exit 1
            fi

            BINARY_SIZE=$(wc -c < "dist/$BINARY_NAME" | tr -d ' ')

            # Build platform entry for S3 JSON files - WITH VERSIONED URLs
            PLATFORM_ENTRY=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg archiveUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg binaryUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${BINARY_NAME}" \
              --arg sha256Archive "$SHA256_ARCHIVE" \
              --arg sha256Binary "$SHA256_BINARY" \
              --argjson archiveSize "$ARCHIVE_SIZE" \
              --argjson binarySize "$BINARY_SIZE" \
              --arg url "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg sha256 "$SHA256_ARCHIVE" \
              --argjson fileSize "$ARCHIVE_SIZE" \
              '{
                os: $os,
                arch: $arch,
                archiveUrl: $archiveUrl,
                binaryUrl: $binaryUrl,
                sha256Archive: $sha256Archive,
                sha256Binary: $sha256Binary,
                archiveSize: $archiveSize,
                binarySize: $binarySize,
                url: $url,
                sha256: $sha256,
                fileSize: $fileSize
              }')

            PLATFORMS_JSON=$(echo "$PLATFORMS_JSON" | jq --argjson entry "$PLATFORM_ENTRY" '. += [$entry]')

            # Build platform entry for DynamoDB (with type annotations)
            PLATFORM_ENTRY_DYNAMODB=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg archiveUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg binaryUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${BINARY_NAME}" \
              --arg sha256Archive "$SHA256_ARCHIVE" \
              --arg sha256Binary "$SHA256_BINARY" \
              --argjson archiveSize "$ARCHIVE_SIZE" \
              --argjson binarySize "$BINARY_SIZE" \
              '{
                M: {
                  os: {S: $os},
                  arch: {S: $arch},
                  archiveUrl: {S: $archiveUrl},
                  binaryUrl: {S: $binaryUrl},
                  sha256Archive: {S: $sha256Archive},
                  sha256Binary: {S: $sha256Binary},
                  archiveSize: {N: ($archiveSize | tostring)},
                  binarySize: {N: ($binarySize | tostring)},
                  url: {S: $archiveUrl},
                  sha256: {S: $sha256Archive},
                  fileSize: {N: ($archiveSize | tostring)}
                }
              }')

            PLATFORMS_JSON_DYNAMODB=$(echo "$PLATFORMS_JSON_DYNAMODB" | jq --argjson entry "$PLATFORM_ENTRY_DYNAMODB" '. += [$entry]')
          done

          # Save to file for use in subsequent steps (avoiding step output size limits)
          echo "$PLATFORMS_JSON" > platforms.json
          echo "$PLATFORMS_JSON_DYNAMODB" > platforms-dynamodb.json

          echo "platforms_file=platforms.json" >> $GITHUB_OUTPUT
          echo "platforms_dynamodb_file=platforms-dynamodb.json" >> $GITHUB_OUTPUT

          echo "Generated platforms.json:"
          cat platforms.json | jq .

      - name: Upload to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          S3_VERSION_PATH="s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/v${VERSION}"

          echo "Uploading to versioned directory: $S3_VERSION_PATH"

          # Upload archives
          echo "Uploading archives..."
          for archive in dist/*.tar.gz; do
            FILENAME=$(basename "$archive")
            aws s3 cp "$archive" \
              "${S3_VERSION_PATH}/${FILENAME}" \
              --content-type "application/gzip" \
              --cache-control "max-age=31536000, immutable"
            echo "  Uploaded archive: $FILENAME"
          done

          # Upload raw binaries
          echo "Uploading raw binaries..."
          for binary in dist/lacylights-*; do
            # Skip archives (only upload raw binaries)
            if [[ "$binary" == *.tar.gz ]]; then
              continue
            fi
            FILENAME=$(basename "$binary")
            aws s3 cp "$binary" \
              "${S3_VERSION_PATH}/${FILENAME}" \
              --content-type "application/octet-stream" \
              --cache-control "max-age=31536000, immutable"
            echo "  Uploaded binary: $FILENAME"
          done

          # Upload checksums.txt
          echo "Uploading checksums.txt..."
          aws s3 cp "dist/checksums.txt" \
            "${S3_VERSION_PATH}/checksums.txt" \
            --content-type "text/plain" \
            --cache-control "max-age=31536000, immutable"
          echo "  Uploaded checksums.txt"

          echo "All files uploaded to ${S3_VERSION_PATH}/"

      - name: Create version-specific metadata JSON
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Read platforms JSON from file
          PLATFORMS_JSON=$(cat platforms.json)

          # Create version-specific metadata JSON
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > "${VERSION}.json"

          echo "Uploading ${VERSION}.json..."
          aws s3 cp "${VERSION}.json" \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/${VERSION}.json" \
            --content-type "application/json" \
            --cache-control "max-age=31536000, immutable" \
            --metadata-directive REPLACE

          echo "${VERSION}.json uploaded"

      - name: Update latest.json
        if: ${{ steps.prerelease_check.outputs.is_prerelease == 'false' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Read platforms JSON from file
          PLATFORMS_JSON=$(cat platforms.json)

          # Create latest.json
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease false \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > latest.json

          echo "Uploading latest.json..."
          aws s3 cp latest.json \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/latest.json" \
            --content-type "application/json" \
            --cache-control "max-age=300, must-revalidate" \
            --metadata-directive REPLACE

          echo "latest.json updated"

      - name: Update prerelease.json
        if: ${{ steps.prerelease_check.outputs.is_prerelease == 'true' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Read platforms JSON from file
          PLATFORMS_JSON=$(cat platforms.json)

          # Create prerelease.json
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease true \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > prerelease.json

          echo "Uploading prerelease.json..."
          aws s3 cp prerelease.json \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/prerelease.json" \
            --content-type "application/json" \
            --cache-control "max-age=300, must-revalidate" \
            --metadata-directive REPLACE

          echo "prerelease.json updated"

      - name: Update DynamoDB
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"
          TABLE_NAME="${{ secrets.AWS_DIST_TABLE_NAME || 'lacylights-releases' }}"

          # Read platforms JSON from DynamoDB-formatted file
          PLATFORMS_JSON=$(cat platforms-dynamodb.json)

          echo "Updating DynamoDB..."

          # Create DynamoDB item
          jq -n \
            --arg tableName "$TABLE_NAME" \
            --arg component "${{ env.COMPONENT }}" \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --arg isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              TableName: $tableName,
              Item: {
                component: {S: $component},
                version: {S: $version},
                releaseDate: {S: $releaseDate},
                isPrerelease: {BOOL: ($isPrerelease == "true")},
                platforms: {L: $platforms}
              }
            }' > dynamodb-item.json

          aws dynamodb put-item --cli-input-json file://dynamodb-item.json

          echo "DynamoDB updated: component=${{ env.COMPONENT }}, version=$VERSION"

      - name: Update versions.json index
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          COMPONENT="${{ env.COMPONENT }}"
          TABLE_NAME="${{ secrets.AWS_DIST_TABLE_NAME || 'lacylights-releases' }}"

          # Validate COMPONENT matches expected values
          case "$COMPONENT" in
            go|web|mcp|rpi)
              echo "Processing versions for component: $COMPONENT"
              ;;
            *)
              echo "Error: Invalid COMPONENT value '$COMPONENT'. Expected: go, web, mcp, or rpi"
              exit 1
              ;;
          esac

          echo "Querying DynamoDB for all $COMPONENT versions from table $TABLE_NAME..."

          # Query all versions for this component from DynamoDB
          VERSIONS_DATA=$(aws dynamodb query \
            --table-name "$TABLE_NAME" \
            --key-condition-expression "component = :comp" \
            --expression-attribute-values '{":comp": {"S": "'"$COMPONENT"'"}}' \
            --projection-expression "#v, releaseDate, isPrerelease, platforms" \
            --expression-attribute-names '{"#v": "version"}' \
            --output json)

          # Validate DynamoDB response before processing with jq
          if ! echo "$VERSIONS_DATA" | jq -e '.Items and (.Items | type == "array")' > /dev/null; then
            echo "Error: Unexpected DynamoDB query response when building versions.json for $COMPONENT"
            echo "Raw response:"
            echo "$VERSIONS_DATA"
            exit 1
          fi

          # Define common sorting function for semantic versioning
          # Sorts: stable versions first (by semantic version desc), then prereleases (by semantic version desc)
          # Filters out items with null/invalid versions first
          SORT_FUNCTION='
            map(select(.version != null and (.version | test("^[0-9]+\\.[0-9]+\\.[0-9]+(-.+)?$"))))
            | sort_by(
              # Build composite sort key:
              # 1. isPrerelease (false < true) so stable come first
              # 2. -major, -minor, -patch so higher versions come first
              # 3. prerelease suffix for deterministic ordering among prereleases
              (
                .version as $v
                | ($v | split("-")[0] | split(".") | map(tonumber? // 0)) as $nums
                | [
                    (.isPrerelease // false),
                    -($nums[0] // 0),
                    -($nums[1] // 0),
                    -($nums[2] // 0),
                    ($v | split("-")[1] // "")
                  ]
              )
            )
          '

          # Build versions.json using jq with proper semver sorting
          # For Go, we include platform info since it has multi-platform builds
          if [ "$COMPONENT" = "go" ]; then
            echo "$VERSIONS_DATA" | jq '
              .Items | map({
                version: .version.S,
                releaseDate: .releaseDate.S,
                isPrerelease: (.isPrerelease.BOOL // false),
                platforms: (.platforms.L // [] | map({
                  os: .M.os.S,
                  arch: .M.arch.S,
                  url: .M.url.S,
                  sha256: .M.sha256.S,
                  fileSize: (.M.fileSize.N // "0" | tonumber)
                }))
              }) |
              '"$SORT_FUNCTION"'
            ' > versions.json
          else
            # For non-Go components, omit platform details from versions.json
            echo "$VERSIONS_DATA" | jq '
              .Items | map({
                version: .version.S,
                releaseDate: .releaseDate.S,
                isPrerelease: (.isPrerelease.BOOL // false)
              }) |
              '"$SORT_FUNCTION"'
            ' > versions.json
          fi

          # Validate that versions.json was successfully created before upload
          if [ ! -f versions.json ] || [ ! -s versions.json ]; then
            echo "Error: versions.json was not created or is empty"
            exit 1
          fi

          # Validate that versions.json contains valid JSON
          if ! jq empty versions.json >/dev/null 2>&1; then
            echo "Error: versions.json contains invalid JSON"
            echo "Contents of versions.json:"
            cat versions.json
            exit 1
          fi

          echo "Generated versions.json with $(jq length versions.json) versions"
          cat versions.json

          # Upload versions.json
          aws s3 cp versions.json \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${COMPONENT}/versions.json" \
            --content-type "application/json" \
            --cache-control "max-age=300, must-revalidate" \
            --metadata-directive REPLACE

          echo "âœ“ versions.json updated for $COMPONENT"

      - name: Create Git tag
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Check if tag exists, skip creation if it does (idempotent)
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists. Skipping creation."
          else
            git tag -a "v${VERSION}" -m "Release v${VERSION}"

            # Push with retry logic
            for i in 1 2 3; do
              if git push origin "v${VERSION}"; then
                echo "Successfully pushed tag"
                break
              fi
              echo "Push attempt $i failed, retrying..."
              sleep 5
            done
          fi

      - name: Determine release name
        id: release_name
        run: |
          if [ -z "${{ inputs.release_name }}" ]; then
            echo "name=v${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ inputs.release_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN }}
          script: |
            const tagName = 'v${{ steps.new_version.outputs.version }}';
            const fs = require('fs');
            const path = require('path');

            // Check if release already exists
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              core.info(`Release ${tagName} already exists. Skipping creation.`);
              return;
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            // Create the release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: '${{ steps.release_name.outputs.name }}',
              draft: false,
              prerelease: ${{ steps.prerelease_check.outputs.is_prerelease == 'true' }},
              generate_release_notes: true
            });

            // Upload assets (both archives and raw binaries)
            const distDir = 'dist';
            const files = fs.readdirSync(distDir).filter(f =>
              f.endsWith('.tar.gz') || f.match(/^lacylights-[^.]+$/)
            );

            for (const file of files) {
              const filePath = path.join(distDir, file);
              const fileContent = fs.readFileSync(filePath);
              const contentType = file.endsWith('.tar.gz') ? 'application/gzip' : 'application/octet-stream';

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: file,
                data: fileContent,
                headers: {
                  'content-type': contentType
                }
              });

              core.info(`Uploaded ${file}`);
            }

      - name: Output summary
        run: |
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          VERSION="${{ steps.new_version.outputs.version }}"

          echo "## Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** v${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

          if [ "$IS_PRERELEASE" = "true" ]; then
            echo "**Type:** Prerelease (Beta)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Type:** Stable Release" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release Directory:** https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          cat platforms.json | jq -r '.[] | "- \(.os)/\(.arch): [Archive](\(.archiveUrl)) | [Binary](\(.binaryUrl))"' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Checksums:** [checksums.txt](https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/checksums.txt)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**API Endpoints:**" >> $GITHUB_STEP_SUMMARY
          if [ "$IS_PRERELEASE" = "false" ]; then
            echo "- Latest: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/latest.json" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Prerelease: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/prerelease.json" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version-specific: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/${VERSION}.json" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${VERSION})" >> $GITHUB_STEP_SUMMARY
