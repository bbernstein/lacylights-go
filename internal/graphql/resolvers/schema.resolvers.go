package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/bbernstein/lacylights-go/internal/database/models"
	"github.com/bbernstein/lacylights-go/internal/graphql/generated"
	"github.com/bbernstein/lacylights-go/internal/services/fade"
	importservice "github.com/bbernstein/lacylights-go/internal/services/import"
	"github.com/bbernstein/lacylights-go/internal/services/network"
	"github.com/bbernstein/lacylights-go/internal/services/ofl"
	"github.com/bbernstein/lacylights-go/internal/services/pubsub"
	"github.com/lucsky/cuid"
	"gorm.io/gorm"
)

// Type is the resolver for the type field.
func (r *channelDefinitionResolver) Type(ctx context.Context, obj *models.ChannelDefinition) (generated.ChannelType, error) {
	return generated.ChannelType(obj.Type), nil
}

// FadeBehavior is the resolver for the fadeBehavior field.
func (r *channelDefinitionResolver) FadeBehavior(ctx context.Context, obj *models.ChannelDefinition) (generated.FadeBehavior, error) {
	// Return the stored value, defaulting to FADE if empty
	if obj.FadeBehavior == "" {
		return generated.FadeBehaviorFade, nil
	}
	return generated.FadeBehavior(obj.FadeBehavior), nil
}

// Scene is the resolver for the scene field.
func (r *cueResolver) Scene(ctx context.Context, obj *models.Cue) (*models.Scene, error) {
	return r.SceneRepo.FindByID(ctx, obj.SceneID)
}

// CueList is the resolver for the cueList field.
func (r *cueResolver) CueList(ctx context.Context, obj *models.Cue) (*models.CueList, error) {
	return r.CueListRepo.FindByID(ctx, obj.CueListID)
}

// EasingType is the resolver for the easingType field.
func (r *cueResolver) EasingType(ctx context.Context, obj *models.Cue) (*generated.EasingType, error) {
	if obj.EasingType == nil {
		return nil, nil
	}
	et := generated.EasingType(*obj.EasingType)
	return &et, nil
}

// Project is the resolver for the project field.
func (r *cueListResolver) Project(ctx context.Context, obj *models.CueList) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// Cues is the resolver for the cues field.
func (r *cueListResolver) Cues(ctx context.Context, obj *models.CueList) ([]*models.Cue, error) {
	cues, err := r.CueRepo.FindByCueListID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	pointers := make([]*models.Cue, len(cues))
	for i := range cues {
		pointers[i] = &cues[i]
	}
	return pointers, nil
}

// CueCount is the resolver for the cueCount field.
func (r *cueListResolver) CueCount(ctx context.Context, obj *models.CueList) (int, error) {
	count, err := r.CueListRepo.CountCues(ctx, obj.ID)
	return int(count), err
}

// TotalDuration is the resolver for the totalDuration field.
func (r *cueListResolver) TotalDuration(ctx context.Context, obj *models.CueList) (float64, error) {
	cues, err := r.CueListRepo.GetCues(ctx, obj.ID)
	if err != nil {
		return 0, err
	}
	var total float64
	for _, cue := range cues {
		total += cue.FadeInTime + cue.FadeOutTime
		if cue.FollowTime != nil {
			total += *cue.FollowTime
		}
	}
	return total, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cueListResolver) CreatedAt(ctx context.Context, obj *models.CueList) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cueListResolver) UpdatedAt(ctx context.Context, obj *models.CueList) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Type is the resolver for the type field.
func (r *fixtureDefinitionResolver) Type(ctx context.Context, obj *models.FixtureDefinition) (generated.FixtureType, error) {
	return generated.FixtureType(obj.Type), nil
}

// Channels is the resolver for the channels field.
func (r *fixtureDefinitionResolver) Channels(ctx context.Context, obj *models.FixtureDefinition) ([]*models.ChannelDefinition, error) {
	var channels []models.ChannelDefinition
	result := r.db.Where("definition_id = ?", obj.ID).Order("\"offset\" ASC").Find(&channels)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.ChannelDefinition, len(channels))
	for i := range channels {
		pointers[i] = &channels[i]
	}
	return pointers, nil
}

// Modes is the resolver for the modes field.
func (r *fixtureDefinitionResolver) Modes(ctx context.Context, obj *models.FixtureDefinition) ([]*models.FixtureMode, error) {
	var modes []models.FixtureMode
	result := r.db.Where("definition_id = ?", obj.ID).Order("name ASC").Find(&modes)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.FixtureMode, len(modes))
	for i := range modes {
		pointers[i] = &modes[i]
	}
	return pointers, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *fixtureDefinitionResolver) CreatedAt(ctx context.Context, obj *models.FixtureDefinition) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Manufacturer is the resolver for the manufacturer field.
func (r *fixtureInstanceResolver) Manufacturer(ctx context.Context, obj *models.FixtureInstance) (string, error) {
	if obj.Manufacturer != nil {
		return *obj.Manufacturer, nil
	}
	return "", nil
}

// Model is the resolver for the model field.
func (r *fixtureInstanceResolver) Model(ctx context.Context, obj *models.FixtureInstance) (string, error) {
	if obj.Model != nil {
		return *obj.Model, nil
	}
	return "", nil
}

// Type is the resolver for the type field.
func (r *fixtureInstanceResolver) Type(ctx context.Context, obj *models.FixtureInstance) (generated.FixtureType, error) {
	if obj.Type != nil {
		return generated.FixtureType(*obj.Type), nil
	}
	return generated.FixtureTypeOther, nil
}

// ModeName is the resolver for the modeName field.
func (r *fixtureInstanceResolver) ModeName(ctx context.Context, obj *models.FixtureInstance) (string, error) {
	if obj.ModeName != nil {
		return *obj.ModeName, nil
	}
	return "default", nil
}

// ChannelCount is the resolver for the channelCount field.
func (r *fixtureInstanceResolver) ChannelCount(ctx context.Context, obj *models.FixtureInstance) (int, error) {
	if obj.ChannelCount != nil {
		return *obj.ChannelCount, nil
	}
	return 0, nil
}

// Channels is the resolver for the channels field on FixtureInstance.
func (r *fixtureInstanceResolver) Channels(ctx context.Context, obj *models.FixtureInstance) ([]*models.InstanceChannel, error) {
	var channels []models.InstanceChannel
	result := r.db.Where("fixture_id = ?", obj.ID).Order("\"offset\" ASC").Find(&channels)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.InstanceChannel, len(channels))
	for i := range channels {
		pointers[i] = &channels[i]
	}
	return pointers, nil
}

// Project is the resolver for the project field.
func (r *fixtureInstanceResolver) Project(ctx context.Context, obj *models.FixtureInstance) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// Tags is the resolver for the tags field.
func (r *fixtureInstanceResolver) Tags(ctx context.Context, obj *models.FixtureInstance) ([]string, error) {
	if obj.Tags == nil || *obj.Tags == "" || *obj.Tags == "[]" {
		return []string{}, nil
	}
	var tags []string
	if err := json.Unmarshal([]byte(*obj.Tags), &tags); err != nil {
		return []string{}, nil
	}
	return tags, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *fixtureInstanceResolver) CreatedAt(ctx context.Context, obj *models.FixtureInstance) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Channels is the resolver for the channels field.
func (r *fixtureModeResolver) Channels(ctx context.Context, obj *models.FixtureMode) ([]*models.ModeChannel, error) {
	var channels []models.ModeChannel
	result := r.db.Where("mode_id = ?", obj.ID).Order("\"offset\" ASC").Find(&channels)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.ModeChannel, len(channels))
	for i := range channels {
		pointers[i] = &channels[i]
	}
	return pointers, nil
}

// Fixture is the resolver for the fixture field.
func (r *fixtureValueResolver) Fixture(ctx context.Context, obj *models.FixtureValue) (*models.FixtureInstance, error) {
	return r.FixtureRepo.FindByID(ctx, obj.FixtureID)
}

// ChannelValues is the resolver for the channelValues field.
func (r *fixtureValueResolver) ChannelValues(ctx context.Context, obj *models.FixtureValue) ([]int, error) {
	if obj.ChannelValues == "" || obj.ChannelValues == "[]" {
		return []int{}, nil
	}
	var values []int
	if err := json.Unmarshal([]byte(obj.ChannelValues), &values); err != nil {
		return []int{}, nil
	}
	return values, nil
}

// Type is the resolver for the type field.
func (r *instanceChannelResolver) Type(ctx context.Context, obj *models.InstanceChannel) (generated.ChannelType, error) {
	return generated.ChannelType(obj.Type), nil
}

// FadeBehavior is the resolver for the fadeBehavior field.
func (r *instanceChannelResolver) FadeBehavior(ctx context.Context, obj *models.InstanceChannel) (generated.FadeBehavior, error) {
	// Return the stored value, defaulting to FADE if empty
	if obj.FadeBehavior == "" {
		return generated.FadeBehaviorFade, nil
	}
	return generated.FadeBehavior(obj.FadeBehavior), nil
}

// Channel is the resolver for the channel field.
func (r *modeChannelResolver) Channel(ctx context.Context, obj *models.ModeChannel) (*models.ChannelDefinition, error) {
	var channel models.ChannelDefinition
	result := r.db.First(&channel, "id = ?", obj.ChannelID)
	if result.Error != nil {
		return nil, result.Error
	}
	return &channel, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input generated.CreateProjectInput) (*models.Project, error) {
	project := &models.Project{
		Name: input.Name,
	}
	if input.Description.IsSet() {
		project.Description = input.Description.Value()
	}
	if err := r.ProjectRepo.Create(ctx, project); err != nil {
		return nil, err
	}
	return project, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input generated.CreateProjectInput) (*models.Project, error) {
	project, err := r.ProjectRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if project == nil {
		return nil, fmt.Errorf("project not found: %s", id)
	}
	project.Name = input.Name
	if input.Description.IsSet() {
		project.Description = input.Description.Value()
	}
	if err := r.ProjectRepo.Update(ctx, project); err != nil {
		return nil, err
	}
	return project, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	if err := r.ProjectRepo.Delete(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// BulkCreateProjects is the resolver for the bulkCreateProjects field.
func (r *mutationResolver) BulkCreateProjects(ctx context.Context, input generated.BulkProjectCreateInput) ([]*models.Project, error) {
	var createdProjects []*models.Project

	for _, projectInput := range input.Projects {
		project, err := r.CreateProject(ctx, *projectInput)
		if err != nil {
			return nil, err
		}
		createdProjects = append(createdProjects, project)
	}

	return createdProjects, nil
}

// BulkUpdateProjects is the resolver for the bulkUpdateProjects field.
func (r *mutationResolver) BulkUpdateProjects(ctx context.Context, input generated.BulkProjectUpdateInput) ([]*models.Project, error) {
	var updatedProjects []*models.Project

	for _, item := range input.Projects {
		project, err := r.ProjectRepo.FindByID(ctx, item.ProjectID)
		if err != nil {
			return nil, err
		}
		if project == nil {
			return nil, fmt.Errorf("project not found: %s", item.ProjectID)
		}

		if item.Name.IsSet() && item.Name.Value() != nil {
			project.Name = *item.Name.Value()
		}

		if item.Description.IsSet() {
			project.Description = item.Description.Value()
		}

		if err := r.ProjectRepo.Update(ctx, project); err != nil {
			return nil, err
		}

		updatedProjects = append(updatedProjects, project)
	}

	return updatedProjects, nil
}

// BulkDeleteProjects is the resolver for the bulkDeleteProjects field.
func (r *mutationResolver) BulkDeleteProjects(ctx context.Context, projectIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, projectID := range projectIds {
		if err := r.ProjectRepo.Delete(ctx, projectID); err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, projectID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// CreateFixtureDefinition is the resolver for the createFixtureDefinition field.
func (r *mutationResolver) CreateFixtureDefinition(ctx context.Context, input generated.CreateFixtureDefinitionInput) (*models.FixtureDefinition, error) {
	// Check if definition with same manufacturer/model already exists
	existing, err := r.FixtureRepo.FindDefinitionByManufacturerModel(ctx, input.Manufacturer, input.Model)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return nil, fmt.Errorf("fixture definition already exists for %s %s", input.Manufacturer, input.Model)
	}

	// Create the definition
	definition := &models.FixtureDefinition{
		Manufacturer: input.Manufacturer,
		Model:        input.Model,
		Type:         string(input.Type),
		IsBuiltIn:    false,
	}

	// Build channel definitions
	var channels []models.ChannelDefinition
	for _, ch := range input.Channels {
		channels = append(channels, models.ChannelDefinition{
			Name:         ch.Name,
			Type:         string(ch.Type),
			Offset:       ch.Offset,
			MinValue:     ch.MinValue,
			MaxValue:     ch.MaxValue,
			DefaultValue: ch.DefaultValue,
		})
	}

	// Create definition with channels
	if err := r.FixtureRepo.CreateDefinitionWithChannels(ctx, definition, channels); err != nil {
		return nil, err
	}

	return definition, nil
}

// ImportOFLFixture is the resolver for the importOFLFixture field.
// Imports a fixture definition from OFL (Open Fixture Library) JSON format.
// Automatically detects and sets FadeBehavior and IsDiscrete based on channel types.
func (r *mutationResolver) ImportOFLFixture(ctx context.Context, input generated.ImportOFLFixtureInput) (*models.FixtureDefinition, error) {
	replace := false
	if replacePtr := input.Replace.Value(); replacePtr != nil {
		replace = *replacePtr
	}

	return r.OFLService.ImportFixture(ctx, input.Manufacturer, input.OflFixtureJSON, replace)
}

// UpdateFixtureDefinition is the resolver for the updateFixtureDefinition field.
func (r *mutationResolver) UpdateFixtureDefinition(ctx context.Context, id string, input generated.CreateFixtureDefinitionInput) (*models.FixtureDefinition, error) {
	// Find existing definition
	definition, err := r.FixtureRepo.FindDefinitionByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if definition == nil {
		return nil, fmt.Errorf("fixture definition not found: %s", id)
	}

	// Check if changing manufacturer/model would conflict
	if definition.Manufacturer != input.Manufacturer || definition.Model != input.Model {
		existing, err := r.FixtureRepo.FindDefinitionByManufacturerModel(ctx, input.Manufacturer, input.Model)
		if err != nil {
			return nil, err
		}
		if existing != nil && existing.ID != id {
			return nil, fmt.Errorf("fixture definition already exists for %s %s", input.Manufacturer, input.Model)
		}
	}

	// Update fields
	definition.Manufacturer = input.Manufacturer
	definition.Model = input.Model
	definition.Type = string(input.Type)

	// Delete existing channels and create new ones
	if err := r.FixtureRepo.DeleteChannelDefinitions(ctx, id); err != nil {
		return nil, err
	}

	var channels []models.ChannelDefinition
	for _, ch := range input.Channels {
		channels = append(channels, models.ChannelDefinition{
			DefinitionID: id,
			Name:         ch.Name,
			Type:         string(ch.Type),
			Offset:       ch.Offset,
			MinValue:     ch.MinValue,
			MaxValue:     ch.MaxValue,
			DefaultValue: ch.DefaultValue,
		})
	}

	if err := r.FixtureRepo.CreateChannelDefinitions(ctx, channels); err != nil {
		return nil, err
	}

	if err := r.FixtureRepo.UpdateDefinition(ctx, definition); err != nil {
		return nil, err
	}

	return definition, nil
}

// DeleteFixtureDefinition is the resolver for the deleteFixtureDefinition field.
func (r *mutationResolver) DeleteFixtureDefinition(ctx context.Context, id string) (bool, error) {
	// Find existing definition
	definition, err := r.FixtureRepo.FindDefinitionByID(ctx, id)
	if err != nil {
		return false, err
	}
	if definition == nil {
		return false, fmt.Errorf("fixture definition not found: %s", id)
	}

	// Check if any fixture instances use this definition
	count, err := r.FixtureRepo.CountInstancesByDefinitionID(ctx, id)
	if err != nil {
		return false, err
	}
	if count > 0 {
		return false, fmt.Errorf("cannot delete fixture definition: %d fixture instances are using it", count)
	}

	// Delete channel definitions first
	if err := r.FixtureRepo.DeleteChannelDefinitions(ctx, id); err != nil {
		return false, err
	}

	// Delete the definition
	if err := r.FixtureRepo.DeleteDefinition(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// BulkCreateFixtureDefinitions is the resolver for the bulkCreateFixtureDefinitions field.
func (r *mutationResolver) BulkCreateFixtureDefinitions(ctx context.Context, input generated.BulkFixtureDefinitionCreateInput) ([]*models.FixtureDefinition, error) {
	var createdDefinitions []*models.FixtureDefinition

	for _, defInput := range input.Definitions {
		definition, err := r.CreateFixtureDefinition(ctx, *defInput)
		if err != nil {
			return nil, err
		}
		createdDefinitions = append(createdDefinitions, definition)
	}

	return createdDefinitions, nil
}

// BulkUpdateFixtureDefinitions is the resolver for the bulkUpdateFixtureDefinitions field.
func (r *mutationResolver) BulkUpdateFixtureDefinitions(ctx context.Context, input generated.BulkFixtureDefinitionUpdateInput) ([]*models.FixtureDefinition, error) {
	var updatedDefinitions []*models.FixtureDefinition

	for _, item := range input.Definitions {
		definition, err := r.FixtureRepo.FindDefinitionByID(ctx, item.DefinitionID)
		if err != nil {
			return nil, err
		}
		if definition == nil {
			return nil, fmt.Errorf("fixture definition not found: %s", item.DefinitionID)
		}

		if item.Manufacturer.IsSet() && item.Manufacturer.Value() != nil {
			definition.Manufacturer = *item.Manufacturer.Value()
		}

		if item.Model.IsSet() && item.Model.Value() != nil {
			definition.Model = *item.Model.Value()
		}

		if item.Type.IsSet() && item.Type.Value() != nil {
			definition.Type = string(*item.Type.Value())
		}

		if err := r.FixtureRepo.UpdateDefinition(ctx, definition); err != nil {
			return nil, err
		}

		updatedDefinitions = append(updatedDefinitions, definition)
	}

	return updatedDefinitions, nil
}

// BulkDeleteFixtureDefinitions is the resolver for the bulkDeleteFixtureDefinitions field.
func (r *mutationResolver) BulkDeleteFixtureDefinitions(ctx context.Context, definitionIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, defID := range definitionIds {
		_, err := r.DeleteFixtureDefinition(ctx, defID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, defID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// CreateFixtureInstance is the resolver for the createFixtureInstance field.
func (r *mutationResolver) CreateFixtureInstance(ctx context.Context, input generated.CreateFixtureInstanceInput) (*models.FixtureInstance, error) {
	// Get the fixture definition
	definition, err := r.FixtureRepo.FindDefinitionByID(ctx, input.DefinitionID)
	if err != nil {
		return nil, err
	}
	if definition == nil {
		return nil, fmt.Errorf("fixture definition not found: %s", input.DefinitionID)
	}

	// Build fixture instance
	fixture := &models.FixtureInstance{
		Name:         input.Name,
		DefinitionID: input.DefinitionID,
		ProjectID:    input.ProjectID,
		Universe:     input.Universe,
		StartChannel: input.StartChannel,
		Manufacturer: &definition.Manufacturer,
		Model:        &definition.Model,
		Type:         &definition.Type,
	}

	if input.Description.IsSet() {
		fixture.Description = input.Description.Value()
	}

	// Handle mode - store mode name if ModeID is provided
	var modeID *string
	if input.ModeID.IsSet() && input.ModeID.Value() != nil {
		modeID = input.ModeID.Value()
		mode, err := r.FixtureRepo.FindModeByID(ctx, *modeID)
		if err != nil {
			return nil, err
		}
		if mode != nil {
			fixture.ModeName = &mode.Name
		}
	}

	// Handle tags
	if input.Tags.IsSet() && len(input.Tags.Value()) > 0 {
		tagsJSON, err := json.Marshal(input.Tags.Value())
		if err != nil {
			return nil, fmt.Errorf("failed to serialize tags: %w", err)
		}
		tagsStr := string(tagsJSON)
		fixture.Tags = &tagsStr
	}

	// Get channels - either from mode or definition
	var instanceChannels []models.InstanceChannel

	if modeID != nil {
		// Use mode channels
		modeChannels, err := r.FixtureRepo.GetModeChannels(ctx, *modeID)
		if err != nil {
			return nil, err
		}
		fixture.ChannelCount = intPtr(len(modeChannels))

		for _, mc := range modeChannels {
			// Get the channel definition for type info
			channelDef, err := r.FixtureRepo.GetChannelDefinitionByID(ctx, mc.ChannelID)
			if err != nil {
				return nil, err
			}
			if channelDef != nil {
				instanceChannels = append(instanceChannels, models.InstanceChannel{
					Offset: mc.Offset,
					Name:   channelDef.Name,
					Type:   channelDef.Type,
				})
			}
		}
	} else {
		// Use definition channels
		defChannels, err := r.FixtureRepo.GetDefinitionChannels(ctx, input.DefinitionID)
		if err != nil {
			return nil, err
		}
		fixture.ChannelCount = intPtr(len(defChannels))

		for _, dc := range defChannels {
			instanceChannels = append(instanceChannels, models.InstanceChannel{
				Offset: dc.Offset,
				Name:   dc.Name,
				Type:   dc.Type,
			})
		}
	}

	// Create fixture with channels in a transaction
	if err := r.FixtureRepo.CreateWithChannels(ctx, fixture, instanceChannels); err != nil {
		return nil, err
	}

	return fixture, nil
}

// UpdateFixtureInstance is the resolver for the updateFixtureInstance field.
func (r *mutationResolver) UpdateFixtureInstance(ctx context.Context, id string, input generated.UpdateFixtureInstanceInput) (*models.FixtureInstance, error) {
	// Get existing fixture
	fixture, err := r.FixtureRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if fixture == nil {
		return nil, fmt.Errorf("fixture not found: %s", id)
	}

	// Update fields if provided
	if input.Name.IsSet() && input.Name.Value() != nil {
		fixture.Name = *input.Name.Value()
	}

	if input.Description.IsSet() {
		fixture.Description = input.Description.Value()
	}

	if input.Universe.IsSet() && input.Universe.Value() != nil {
		fixture.Universe = *input.Universe.Value()
	}

	if input.StartChannel.IsSet() && input.StartChannel.Value() != nil {
		fixture.StartChannel = *input.StartChannel.Value()
	}

	if input.ProjectOrder.IsSet() && input.ProjectOrder.Value() != nil {
		fixture.ProjectOrder = input.ProjectOrder.Value()
	}

	if input.LayoutX.IsSet() {
		fixture.LayoutX = input.LayoutX.Value()
	}

	if input.LayoutY.IsSet() {
		fixture.LayoutY = input.LayoutY.Value()
	}

	if input.LayoutRotation.IsSet() {
		fixture.LayoutRotation = input.LayoutRotation.Value()
	}

	// Handle tags update
	if input.Tags.IsSet() {
		if len(input.Tags.Value()) > 0 {
			tagsJSON, err := json.Marshal(input.Tags.Value())
			if err != nil {
				return nil, fmt.Errorf("failed to serialize tags: %w", err)
			}
			tagsStr := string(tagsJSON)
			fixture.Tags = &tagsStr
		} else {
			fixture.Tags = nil
		}
	}

	// Handle definition/mode change (requires rebuilding channels)
	needsChannelRebuild := false
	var newModeID *string

	if input.DefinitionID.IsSet() && input.DefinitionID.Value() != nil {
		newDefID := *input.DefinitionID.Value()
		if fixture.DefinitionID != newDefID {
			fixture.DefinitionID = newDefID
			// Get the new definition for manufacturer/model
			def, err := r.FixtureRepo.FindDefinitionByID(ctx, newDefID)
			if err != nil {
				return nil, err
			}
			if def != nil {
				fixture.Manufacturer = &def.Manufacturer
				fixture.Model = &def.Model
				fixture.Type = &def.Type
			}
			needsChannelRebuild = true
		}
	}

	if input.ModeID.IsSet() {
		newModeID = input.ModeID.Value()
		// Update mode name
		if newModeID != nil {
			mode, err := r.FixtureRepo.FindModeByID(ctx, *newModeID)
			if err != nil {
				return nil, err
			}
			if mode != nil {
				fixture.ModeName = &mode.Name
			}
		} else {
			fixture.ModeName = nil
		}
		needsChannelRebuild = true
	}

	// If definition or mode changed, rebuild channels
	if needsChannelRebuild {
		// Delete existing instance channels
		if err := r.FixtureRepo.DeleteInstanceChannels(ctx, fixture.ID); err != nil {
			return nil, err
		}

		// Create new instance channels
		var instanceChannels []models.InstanceChannel
		if newModeID != nil {
			modeChannels, err := r.FixtureRepo.GetModeChannels(ctx, *newModeID)
			if err != nil {
				return nil, err
			}
			fixture.ChannelCount = intPtr(len(modeChannels))

			for _, mc := range modeChannels {
				channelDef, err := r.FixtureRepo.GetChannelDefinitionByID(ctx, mc.ChannelID)
				if err != nil {
					return nil, err
				}
				if channelDef != nil {
					instanceChannels = append(instanceChannels, models.InstanceChannel{
						FixtureID: fixture.ID,
						Offset:    mc.Offset,
						Name:      channelDef.Name,
						Type:      channelDef.Type,
					})
				}
			}
		} else {
			defChannels, err := r.FixtureRepo.GetDefinitionChannels(ctx, fixture.DefinitionID)
			if err != nil {
				return nil, err
			}
			fixture.ChannelCount = intPtr(len(defChannels))

			for _, dc := range defChannels {
				instanceChannels = append(instanceChannels, models.InstanceChannel{
					FixtureID: fixture.ID,
					Offset:    dc.Offset,
					Name:      dc.Name,
					Type:      dc.Type,
				})
			}
		}

		if err := r.FixtureRepo.CreateInstanceChannels(ctx, instanceChannels); err != nil {
			return nil, err
		}
	}

	// Save the fixture
	if err := r.FixtureRepo.Update(ctx, fixture); err != nil {
		return nil, err
	}

	return fixture, nil
}

// BulkUpdateFixtures is the resolver for the bulkUpdateFixtures field.
func (r *mutationResolver) BulkUpdateFixtures(ctx context.Context, input generated.BulkFixtureUpdateInput) ([]*models.FixtureInstance, error) {
	var updatedFixtures []*models.FixtureInstance

	for _, item := range input.Fixtures {
		fixture, err := r.FixtureRepo.FindByID(ctx, item.FixtureID)
		if err != nil {
			return nil, err
		}
		if fixture == nil {
			return nil, fmt.Errorf("fixture not found: %s", item.FixtureID)
		}

		// Update fields if provided
		if item.Name.IsSet() && item.Name.Value() != nil {
			fixture.Name = *item.Name.Value()
		}

		if item.Description.IsSet() {
			fixture.Description = item.Description.Value()
		}

		if item.Universe.IsSet() && item.Universe.Value() != nil {
			fixture.Universe = *item.Universe.Value()
		}

		if item.StartChannel.IsSet() && item.StartChannel.Value() != nil {
			fixture.StartChannel = *item.StartChannel.Value()
		}

		if item.Tags.IsSet() && len(item.Tags.Value()) > 0 {
			tagsJSON, err := json.Marshal(item.Tags.Value())
			if err != nil {
				return nil, fmt.Errorf("failed to serialize tags: %w", err)
			}
			tagsStr := string(tagsJSON)
			fixture.Tags = &tagsStr
		}

		if item.LayoutX.IsSet() {
			fixture.LayoutX = item.LayoutX.Value()
		}

		if item.LayoutY.IsSet() {
			fixture.LayoutY = item.LayoutY.Value()
		}

		if item.LayoutRotation.IsSet() {
			fixture.LayoutRotation = item.LayoutRotation.Value()
		}

		if err := r.FixtureRepo.Update(ctx, fixture); err != nil {
			return nil, err
		}

		updatedFixtures = append(updatedFixtures, fixture)
	}

	return updatedFixtures, nil
}

// BulkCreateFixtures is the resolver for the bulkCreateFixtures field.
func (r *mutationResolver) BulkCreateFixtures(ctx context.Context, input generated.BulkFixtureCreateInput) ([]*models.FixtureInstance, error) {
	var createdFixtures []*models.FixtureInstance

	for _, fixtureInput := range input.Fixtures {
		// Call the existing createFixtureInstance logic
		fixture, err := r.CreateFixtureInstance(ctx, *fixtureInput)
		if err != nil {
			return nil, err
		}
		createdFixtures = append(createdFixtures, fixture)
	}

	return createdFixtures, nil
}

// DeleteFixtureInstance is the resolver for the deleteFixtureInstance field.
func (r *mutationResolver) DeleteFixtureInstance(ctx context.Context, id string) (bool, error) {
	// Check if fixture exists
	fixture, err := r.FixtureRepo.FindByID(ctx, id)
	if err != nil {
		return false, err
	}
	if fixture == nil {
		return false, fmt.Errorf("fixture not found: %s", id)
	}

	// Delete instance channels first
	if err := r.FixtureRepo.DeleteInstanceChannels(ctx, id); err != nil {
		return false, err
	}

	// Delete the fixture
	if err := r.FixtureRepo.Delete(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// BulkDeleteFixtures is the resolver for the bulkDeleteFixtures field.
func (r *mutationResolver) BulkDeleteFixtures(ctx context.Context, fixtureIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, fixtureID := range fixtureIds {
		_, err := r.DeleteFixtureInstance(ctx, fixtureID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, fixtureID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// UpdateInstanceChannelFadeBehavior is the resolver for the updateInstanceChannelFadeBehavior field.
// Updates the fade behavior for a single instance channel.
func (r *mutationResolver) UpdateInstanceChannelFadeBehavior(ctx context.Context, channelID string, fadeBehavior generated.FadeBehavior) (*models.InstanceChannel, error) {
	// Find the channel
	var channel models.InstanceChannel
	if err := r.db.WithContext(ctx).First(&channel, "id = ?", channelID).Error; err != nil {
		return nil, fmt.Errorf("instance channel not found: %s", channelID)
	}

	// Update the fade behavior
	channel.FadeBehavior = string(fadeBehavior)
	if err := r.db.WithContext(ctx).Save(&channel).Error; err != nil {
		return nil, fmt.Errorf("failed to update channel fade behavior: %w", err)
	}

	return &channel, nil
}

// BulkUpdateInstanceChannelsFadeBehavior is the resolver for the bulkUpdateInstanceChannelsFadeBehavior field.
// Updates fade behavior for multiple instance channels in a single operation.
func (r *mutationResolver) BulkUpdateInstanceChannelsFadeBehavior(ctx context.Context, updates []*generated.ChannelFadeBehaviorInput) ([]*models.InstanceChannel, error) {
	var results []*models.InstanceChannel

	// Process all updates in a transaction
	err := r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		for _, update := range updates {
			var channel models.InstanceChannel
			if err := tx.First(&channel, "id = ?", update.ChannelID).Error; err != nil {
				return fmt.Errorf("instance channel not found: %s", update.ChannelID)
			}

			channel.FadeBehavior = string(update.FadeBehavior)
			if err := tx.Save(&channel).Error; err != nil {
				return fmt.Errorf("failed to update channel %s: %w", update.ChannelID, err)
			}

			results = append(results, &channel)
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	return results, nil
}

// ReorderProjectFixtures is the resolver for the reorderProjectFixtures field.
func (r *mutationResolver) ReorderProjectFixtures(ctx context.Context, projectID string, fixtureOrders []*generated.FixtureOrderInput) (bool, error) {
	// Verify project exists
	project, err := r.ProjectRepo.FindByID(ctx, projectID)
	if err != nil {
		return false, err
	}
	if project == nil {
		return false, fmt.Errorf("project not found: %s", projectID)
	}

	// Update each fixture's project_order
	for _, order := range fixtureOrders {
		fixture, err := r.FixtureRepo.FindByID(ctx, order.FixtureID)
		if err != nil {
			return false, err
		}
		if fixture == nil {
			return false, fmt.Errorf("fixture not found: %s", order.FixtureID)
		}

		fixture.ProjectOrder = &order.Order
		if err := r.FixtureRepo.Update(ctx, fixture); err != nil {
			return false, err
		}
	}

	return true, nil
}

// ReorderSceneFixtures is the resolver for the reorderSceneFixtures field.
func (r *mutationResolver) ReorderSceneFixtures(ctx context.Context, sceneID string, fixtureOrders []*generated.FixtureOrderInput) (bool, error) {
	// Verify scene exists
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return false, err
	}
	if scene == nil {
		return false, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Update each fixture value's scene_order
	for _, order := range fixtureOrders {
		fixtureValue, err := r.SceneRepo.GetFixtureValue(ctx, sceneID, order.FixtureID)
		if err != nil {
			return false, err
		}
		if fixtureValue == nil {
			return false, fmt.Errorf("fixture not found in scene: fixture=%s scene=%s", order.FixtureID, sceneID)
		}

		fixtureValue.SceneOrder = &order.Order
		if err := r.SceneRepo.UpdateFixtureValue(ctx, fixtureValue); err != nil {
			return false, err
		}
	}

	return true, nil
}

// UpdateFixturePositions is the resolver for the updateFixturePositions field.
func (r *mutationResolver) UpdateFixturePositions(ctx context.Context, positions []*generated.FixturePositionInput) (bool, error) {
	for _, position := range positions {
		fixture, err := r.FixtureRepo.FindByID(ctx, position.FixtureID)
		if err != nil {
			return false, err
		}
		if fixture == nil {
			return false, fmt.Errorf("fixture not found: %s", position.FixtureID)
		}

		fixture.LayoutX = &position.LayoutX
		fixture.LayoutY = &position.LayoutY
		if position.LayoutRotation.IsSet() {
			fixture.LayoutRotation = position.LayoutRotation.Value()
		}

		if err := r.FixtureRepo.Update(ctx, fixture); err != nil {
			return false, err
		}
	}

	return true, nil
}

// CreateScene is the resolver for the createScene field.
func (r *mutationResolver) CreateScene(ctx context.Context, input generated.CreateSceneInput) (*models.Scene, error) {
	scene := &models.Scene{
		Name:      input.Name,
		ProjectID: input.ProjectID,
	}

	if input.Description.IsSet() {
		scene.Description = input.Description.Value()
	}

	// Convert fixture values
	var fixtureValues []models.FixtureValue
	for _, fv := range input.FixtureValues {
		channelValuesJSON, err := json.Marshal(fv.ChannelValues)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize channel values: %w", err)
		}
		value := models.FixtureValue{
			FixtureID:     fv.FixtureID,
			ChannelValues: string(channelValuesJSON),
		}
		if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
			value.SceneOrder = fv.SceneOrder.Value()
		}
		fixtureValues = append(fixtureValues, value)
	}

	// Create scene with fixture values
	if err := r.SceneRepo.CreateWithFixtureValues(ctx, scene, fixtureValues); err != nil {
		return nil, err
	}

	return scene, nil
}

// UpdateScene is the resolver for the updateScene field.
func (r *mutationResolver) UpdateScene(ctx context.Context, id string, input generated.UpdateSceneInput) (*models.Scene, error) {
	scene, err := r.SceneRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", id)
	}

	// Update fields if provided
	if input.Name.IsSet() && input.Name.Value() != nil {
		scene.Name = *input.Name.Value()
	}

	if input.Description.IsSet() {
		scene.Description = input.Description.Value()
	}

	// Update fixture values if provided
	if input.FixtureValues.IsSet() {
		// Delete existing fixture values
		if err := r.SceneRepo.DeleteFixtureValues(ctx, id); err != nil {
			return nil, err
		}

		// Create new fixture values
		var fixtureValues []models.FixtureValue
		for _, fv := range input.FixtureValues.Value() {
			channelValuesJSON, err := json.Marshal(fv.ChannelValues)
			if err != nil {
				return nil, fmt.Errorf("failed to serialize channel values: %w", err)
			}
			value := models.FixtureValue{
				SceneID:       id,
				FixtureID:     fv.FixtureID,
				ChannelValues: string(channelValuesJSON),
			}
			if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
				value.SceneOrder = fv.SceneOrder.Value()
			}
			fixtureValues = append(fixtureValues, value)
		}

		if err := r.SceneRepo.CreateFixtureValues(ctx, fixtureValues); err != nil {
			return nil, err
		}
	}

	// Save the scene
	if err := r.SceneRepo.Update(ctx, scene); err != nil {
		return nil, err
	}

	return scene, nil
}

// DuplicateScene is the resolver for the duplicateScene field.
func (r *mutationResolver) DuplicateScene(ctx context.Context, id string) (*models.Scene, error) {
	// Get original scene
	original, err := r.SceneRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if original == nil {
		return nil, fmt.Errorf("scene not found: %s", id)
	}

	// Get original fixture values
	originalValues, err := r.SceneRepo.GetFixtureValues(ctx, id)
	if err != nil {
		return nil, err
	}

	// Create new scene with "(Copy)" suffix
	newScene := &models.Scene{
		Name:        original.Name + " (Copy)",
		Description: original.Description,
		ProjectID:   original.ProjectID,
	}

	// Prepare new fixture values
	var newValues []models.FixtureValue
	for _, v := range originalValues {
		newValues = append(newValues, models.FixtureValue{
			FixtureID:     v.FixtureID,
			ChannelValues: v.ChannelValues,
			SceneOrder:    v.SceneOrder,
		})
	}

	// Create new scene with fixture values
	if err := r.SceneRepo.CreateWithFixtureValues(ctx, newScene, newValues); err != nil {
		return nil, err
	}

	return newScene, nil
}

// CloneScene is the resolver for the cloneScene field.
func (r *mutationResolver) CloneScene(ctx context.Context, sceneID string, newName string) (*models.Scene, error) {
	// Get original scene
	original, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return nil, err
	}
	if original == nil {
		return nil, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Get original fixture values
	originalValues, err := r.SceneRepo.GetFixtureValues(ctx, sceneID)
	if err != nil {
		return nil, err
	}

	// Create new scene with provided name
	newScene := &models.Scene{
		Name:        newName,
		Description: original.Description,
		ProjectID:   original.ProjectID,
	}

	// Prepare new fixture values
	var newValues []models.FixtureValue
	for _, v := range originalValues {
		newValues = append(newValues, models.FixtureValue{
			FixtureID:     v.FixtureID,
			ChannelValues: v.ChannelValues,
			SceneOrder:    v.SceneOrder,
		})
	}

	// Create new scene with fixture values
	if err := r.SceneRepo.CreateWithFixtureValues(ctx, newScene, newValues); err != nil {
		return nil, err
	}

	return newScene, nil
}

// DeleteScene is the resolver for the deleteScene field.
func (r *mutationResolver) DeleteScene(ctx context.Context, id string) (bool, error) {
	// Check if scene exists
	scene, err := r.SceneRepo.FindByID(ctx, id)
	if err != nil {
		return false, err
	}
	if scene == nil {
		return false, fmt.Errorf("scene not found: %s", id)
	}

	// Delete fixture values first
	if err := r.SceneRepo.DeleteFixtureValues(ctx, id); err != nil {
		return false, err
	}

	// Delete the scene
	if err := r.SceneRepo.Delete(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// BulkCreateScenes is the resolver for the bulkCreateScenes field.
func (r *mutationResolver) BulkCreateScenes(ctx context.Context, input generated.BulkSceneCreateInput) ([]*models.Scene, error) {
	var createdScenes []*models.Scene

	for _, sceneInput := range input.Scenes {
		scene, err := r.CreateScene(ctx, *sceneInput)
		if err != nil {
			return nil, err
		}
		createdScenes = append(createdScenes, scene)
	}

	return createdScenes, nil
}

// BulkUpdateScenes is the resolver for the bulkUpdateScenes field.
func (r *mutationResolver) BulkUpdateScenes(ctx context.Context, input generated.BulkSceneUpdateInput) ([]*models.Scene, error) {
	var updatedScenes []*models.Scene

	for _, item := range input.Scenes {
		scene, err := r.SceneRepo.FindByID(ctx, item.SceneID)
		if err != nil {
			return nil, err
		}
		if scene == nil {
			return nil, fmt.Errorf("scene not found: %s", item.SceneID)
		}

		if item.Name.IsSet() && item.Name.Value() != nil {
			scene.Name = *item.Name.Value()
		}

		if item.Description.IsSet() {
			scene.Description = item.Description.Value()
		}

		if err := r.SceneRepo.Update(ctx, scene); err != nil {
			return nil, err
		}

		updatedScenes = append(updatedScenes, scene)
	}

	return updatedScenes, nil
}

// BulkDeleteScenes is the resolver for the bulkDeleteScenes field.
func (r *mutationResolver) BulkDeleteScenes(ctx context.Context, sceneIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, sceneID := range sceneIds {
		_, err := r.DeleteScene(ctx, sceneID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, sceneID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// AddFixturesToScene is the resolver for the addFixturesToScene field.
func (r *mutationResolver) AddFixturesToScene(ctx context.Context, sceneID string, fixtureValues []*generated.FixtureValueInput, overwriteExisting *bool) (*models.Scene, error) {
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", sceneID)
	}

	overwrite := false
	if overwriteExisting != nil {
		overwrite = *overwriteExisting
	}

	for _, fv := range fixtureValues {
		channelValuesJSON, err := json.Marshal(fv.ChannelValues)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize channel values: %w", err)
		}

		// Check if fixture already exists in scene
		existing, err := r.SceneRepo.GetFixtureValue(ctx, sceneID, fv.FixtureID)
		if err != nil {
			return nil, err
		}

		if existing != nil {
			if overwrite {
				existing.ChannelValues = string(channelValuesJSON)
				if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
					existing.SceneOrder = fv.SceneOrder.Value()
				}
				if err := r.SceneRepo.UpdateFixtureValue(ctx, existing); err != nil {
					return nil, err
				}
			}
			// Skip if not overwriting
		} else {
			// Create new fixture value
			value := &models.FixtureValue{
				SceneID:       sceneID,
				FixtureID:     fv.FixtureID,
				ChannelValues: string(channelValuesJSON),
			}
			if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
				value.SceneOrder = fv.SceneOrder.Value()
			}
			if err := r.SceneRepo.CreateFixtureValue(ctx, value); err != nil {
				return nil, err
			}
		}
	}

	return scene, nil
}

// RemoveFixturesFromScene is the resolver for the removeFixturesFromScene field.
func (r *mutationResolver) RemoveFixturesFromScene(ctx context.Context, sceneID string, fixtureIds []string) (*models.Scene, error) {
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Delete each fixture value
	for _, fixtureID := range fixtureIds {
		if err := r.SceneRepo.DeleteFixtureValue(ctx, sceneID, fixtureID); err != nil {
			return nil, err
		}
	}

	return scene, nil
}

// UpdateScenePartial is the resolver for the updateScenePartial field.
func (r *mutationResolver) UpdateScenePartial(ctx context.Context, sceneID string, name *string, description *string, fixtureValues []*generated.FixtureValueInput, mergeFixtures *bool) (*models.Scene, error) {
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Update name if provided
	if name != nil {
		scene.Name = *name
	}

	// Update description if provided
	if description != nil {
		scene.Description = description
	}

	// Handle fixture values
	if fixtureValues != nil {
		merge := true
		if mergeFixtures != nil {
			merge = *mergeFixtures
		}

		if !merge {
			// Replace all fixture values
			if err := r.SceneRepo.DeleteFixtureValues(ctx, sceneID); err != nil {
				return nil, err
			}
		}

		for _, fv := range fixtureValues {
			channelValuesJSON, err := json.Marshal(fv.ChannelValues)
			if err != nil {
				return nil, fmt.Errorf("failed to serialize channel values: %w", err)
			}

			if merge {
				// Check if fixture already exists
				existing, err := r.SceneRepo.GetFixtureValue(ctx, sceneID, fv.FixtureID)
				if err != nil {
					return nil, err
				}

				if existing != nil {
					// Update existing
					existing.ChannelValues = string(channelValuesJSON)
					if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
						existing.SceneOrder = fv.SceneOrder.Value()
					}
					if err := r.SceneRepo.UpdateFixtureValue(ctx, existing); err != nil {
						return nil, err
					}
				} else {
					// Create new
					value := &models.FixtureValue{
						SceneID:       sceneID,
						FixtureID:     fv.FixtureID,
						ChannelValues: string(channelValuesJSON),
					}
					if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
						value.SceneOrder = fv.SceneOrder.Value()
					}
					if err := r.SceneRepo.CreateFixtureValue(ctx, value); err != nil {
						return nil, err
					}
				}
			} else {
				// Create new fixture values
				value := &models.FixtureValue{
					SceneID:       sceneID,
					FixtureID:     fv.FixtureID,
					ChannelValues: string(channelValuesJSON),
				}
				if fv.SceneOrder.IsSet() && fv.SceneOrder.Value() != nil {
					value.SceneOrder = fv.SceneOrder.Value()
				}
				if err := r.SceneRepo.CreateFixtureValue(ctx, value); err != nil {
					return nil, err
				}
			}
		}
	}

	// Save the scene
	if err := r.SceneRepo.Update(ctx, scene); err != nil {
		return nil, err
	}

	return scene, nil
}

// CreateSceneBoard is the resolver for the createSceneBoard field.
func (r *mutationResolver) CreateSceneBoard(ctx context.Context, input generated.CreateSceneBoardInput) (*models.SceneBoard, error) {
	// Verify project exists
	project, err := r.ProjectRepo.FindByID(ctx, input.ProjectID)
	if err != nil {
		return nil, err
	}
	if project == nil {
		return nil, fmt.Errorf("project not found: %s", input.ProjectID)
	}

	board := &models.SceneBoard{
		ID:              cuid.New(),
		Name:            input.Name,
		ProjectID:       input.ProjectID,
		DefaultFadeTime: 3.0,
		GridSize:        intPtr(50),
		CanvasWidth:     2000,
		CanvasHeight:    2000,
	}

	if input.Description.IsSet() {
		board.Description = input.Description.Value()
	}

	if input.DefaultFadeTime.IsSet() && input.DefaultFadeTime.Value() != nil {
		board.DefaultFadeTime = *input.DefaultFadeTime.Value()
	}

	if input.GridSize.IsSet() && input.GridSize.Value() != nil {
		board.GridSize = input.GridSize.Value()
	}

	if input.CanvasWidth.IsSet() && input.CanvasWidth.Value() != nil {
		board.CanvasWidth = *input.CanvasWidth.Value()
	}

	if input.CanvasHeight.IsSet() && input.CanvasHeight.Value() != nil {
		board.CanvasHeight = *input.CanvasHeight.Value()
	}

	result := r.db.WithContext(ctx).Create(board)
	if result.Error != nil {
		return nil, result.Error
	}

	return board, nil
}

// UpdateSceneBoard is the resolver for the updateSceneBoard field.
func (r *mutationResolver) UpdateSceneBoard(ctx context.Context, id string, input generated.UpdateSceneBoardInput) (*models.SceneBoard, error) {
	var board models.SceneBoard
	result := r.db.WithContext(ctx).First(&board, "id = ?", id)
	if result.Error != nil {
		return nil, result.Error
	}

	if input.Name.IsSet() && input.Name.Value() != nil {
		board.Name = *input.Name.Value()
	}

	if input.Description.IsSet() {
		board.Description = input.Description.Value()
	}

	if input.DefaultFadeTime.IsSet() && input.DefaultFadeTime.Value() != nil {
		board.DefaultFadeTime = *input.DefaultFadeTime.Value()
	}

	if input.GridSize.IsSet() && input.GridSize.Value() != nil {
		board.GridSize = input.GridSize.Value()
	}

	if input.CanvasWidth.IsSet() && input.CanvasWidth.Value() != nil {
		board.CanvasWidth = *input.CanvasWidth.Value()
	}

	if input.CanvasHeight.IsSet() && input.CanvasHeight.Value() != nil {
		board.CanvasHeight = *input.CanvasHeight.Value()
	}

	result = r.db.WithContext(ctx).Save(&board)
	if result.Error != nil {
		return nil, result.Error
	}

	return &board, nil
}

// DeleteSceneBoard is the resolver for the deleteSceneBoard field.
func (r *mutationResolver) DeleteSceneBoard(ctx context.Context, id string) (bool, error) {
	// Delete all buttons first
	result := r.db.WithContext(ctx).Where("scene_board_id = ?", id).Delete(&models.SceneBoardButton{})
	if result.Error != nil {
		return false, result.Error
	}

	// Delete the board
	result = r.db.WithContext(ctx).Delete(&models.SceneBoard{}, "id = ?", id)
	if result.Error != nil {
		return false, result.Error
	}

	return true, nil
}

// BulkCreateSceneBoards is the resolver for the bulkCreateSceneBoards field.
func (r *mutationResolver) BulkCreateSceneBoards(ctx context.Context, input generated.BulkSceneBoardCreateInput) ([]*models.SceneBoard, error) {
	var createdBoards []*models.SceneBoard

	for _, boardInput := range input.SceneBoards {
		board, err := r.CreateSceneBoard(ctx, *boardInput)
		if err != nil {
			return nil, err
		}
		createdBoards = append(createdBoards, board)
	}

	return createdBoards, nil
}

// BulkUpdateSceneBoards is the resolver for the bulkUpdateSceneBoards field.
func (r *mutationResolver) BulkUpdateSceneBoards(ctx context.Context, input generated.BulkSceneBoardUpdateInput) ([]*models.SceneBoard, error) {
	var updatedBoards []*models.SceneBoard

	for _, item := range input.SceneBoards {
		var board models.SceneBoard
		result := r.db.WithContext(ctx).First(&board, "id = ?", item.SceneBoardID)
		if result.Error != nil {
			return nil, result.Error
		}

		if item.Name.IsSet() && item.Name.Value() != nil {
			board.Name = *item.Name.Value()
		}

		if item.Description.IsSet() {
			board.Description = item.Description.Value()
		}

		if item.DefaultFadeTime.IsSet() && item.DefaultFadeTime.Value() != nil {
			board.DefaultFadeTime = *item.DefaultFadeTime.Value()
		}

		if item.GridSize.IsSet() && item.GridSize.Value() != nil {
			board.GridSize = item.GridSize.Value()
		}

		if item.CanvasWidth.IsSet() && item.CanvasWidth.Value() != nil {
			board.CanvasWidth = *item.CanvasWidth.Value()
		}

		if item.CanvasHeight.IsSet() && item.CanvasHeight.Value() != nil {
			board.CanvasHeight = *item.CanvasHeight.Value()
		}

		result = r.db.WithContext(ctx).Save(&board)
		if result.Error != nil {
			return nil, result.Error
		}

		updatedBoards = append(updatedBoards, &board)
	}

	return updatedBoards, nil
}

// BulkDeleteSceneBoards is the resolver for the bulkDeleteSceneBoards field.
func (r *mutationResolver) BulkDeleteSceneBoards(ctx context.Context, sceneBoardIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, boardID := range sceneBoardIds {
		_, err := r.DeleteSceneBoard(ctx, boardID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, boardID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// AddSceneToBoard is the resolver for the addSceneToBoard field.
func (r *mutationResolver) AddSceneToBoard(ctx context.Context, input generated.CreateSceneBoardButtonInput) (*models.SceneBoardButton, error) {
	// Verify scene board exists
	var board models.SceneBoard
	result := r.db.WithContext(ctx).First(&board, "id = ?", input.SceneBoardID)
	if result.Error != nil {
		return nil, fmt.Errorf("scene board not found: %w", result.Error)
	}

	// Verify scene exists
	scene, err := r.SceneRepo.FindByID(ctx, input.SceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", input.SceneID)
	}

	button := &models.SceneBoardButton{
		ID:           cuid.New(),
		SceneBoardID: input.SceneBoardID,
		SceneID:      input.SceneID,
		LayoutX:      input.LayoutX,
		LayoutY:      input.LayoutY,
		Width:        intPtr(200),
		Height:       intPtr(120),
	}

	if input.Width.IsSet() && input.Width.Value() != nil {
		button.Width = input.Width.Value()
	}

	if input.Height.IsSet() && input.Height.Value() != nil {
		button.Height = input.Height.Value()
	}

	if input.Color.IsSet() {
		button.Color = input.Color.Value()
	}

	if input.Label.IsSet() {
		button.Label = input.Label.Value()
	}

	result = r.db.WithContext(ctx).Create(button)
	if result.Error != nil {
		return nil, result.Error
	}

	return button, nil
}

// UpdateSceneBoardButton is the resolver for the updateSceneBoardButton field.
func (r *mutationResolver) UpdateSceneBoardButton(ctx context.Context, id string, input generated.UpdateSceneBoardButtonInput) (*models.SceneBoardButton, error) {
	var button models.SceneBoardButton
	result := r.db.WithContext(ctx).First(&button, "id = ?", id)
	if result.Error != nil {
		return nil, result.Error
	}

	if input.LayoutX.IsSet() && input.LayoutX.Value() != nil {
		button.LayoutX = *input.LayoutX.Value()
	}

	if input.LayoutY.IsSet() && input.LayoutY.Value() != nil {
		button.LayoutY = *input.LayoutY.Value()
	}

	if input.Width.IsSet() {
		button.Width = input.Width.Value()
	}

	if input.Height.IsSet() {
		button.Height = input.Height.Value()
	}

	if input.Color.IsSet() {
		button.Color = input.Color.Value()
	}

	if input.Label.IsSet() {
		button.Label = input.Label.Value()
	}

	result = r.db.WithContext(ctx).Save(&button)
	if result.Error != nil {
		return nil, result.Error
	}

	return &button, nil
}

// RemoveSceneFromBoard is the resolver for the removeSceneFromBoard field.
func (r *mutationResolver) RemoveSceneFromBoard(ctx context.Context, buttonID string) (bool, error) {
	result := r.db.WithContext(ctx).Delete(&models.SceneBoardButton{}, "id = ?", buttonID)
	if result.Error != nil {
		return false, result.Error
	}
	if result.RowsAffected == 0 {
		return false, fmt.Errorf("button not found: %s", buttonID)
	}
	return true, nil
}

// UpdateSceneBoardButtonPositions is the resolver for the updateSceneBoardButtonPositions field.
func (r *mutationResolver) UpdateSceneBoardButtonPositions(ctx context.Context, positions []*generated.SceneBoardButtonPositionInput) (bool, error) {
	for _, position := range positions {
		var button models.SceneBoardButton
		result := r.db.WithContext(ctx).First(&button, "id = ?", position.ButtonID)
		if result.Error != nil {
			return false, result.Error
		}

		button.LayoutX = position.LayoutX
		button.LayoutY = position.LayoutY

		result = r.db.WithContext(ctx).Save(&button)
		if result.Error != nil {
			return false, result.Error
		}
	}
	return true, nil
}

// BulkCreateSceneBoardButtons is the resolver for the bulkCreateSceneBoardButtons field.
func (r *mutationResolver) BulkCreateSceneBoardButtons(ctx context.Context, input generated.BulkSceneBoardButtonCreateInput) ([]*models.SceneBoardButton, error) {
	var createdButtons []*models.SceneBoardButton

	for _, buttonInput := range input.Buttons {
		button, err := r.AddSceneToBoard(ctx, *buttonInput)
		if err != nil {
			return nil, err
		}
		createdButtons = append(createdButtons, button)
	}

	return createdButtons, nil
}

// BulkUpdateSceneBoardButtons is the resolver for the bulkUpdateSceneBoardButtons field.
func (r *mutationResolver) BulkUpdateSceneBoardButtons(ctx context.Context, input generated.BulkSceneBoardButtonUpdateInput) ([]*models.SceneBoardButton, error) {
	var updatedButtons []*models.SceneBoardButton

	for _, item := range input.Buttons {
		var button models.SceneBoardButton
		result := r.db.WithContext(ctx).First(&button, "id = ?", item.ButtonID)
		if result.Error != nil {
			return nil, result.Error
		}

		if item.LayoutX.IsSet() && item.LayoutX.Value() != nil {
			button.LayoutX = *item.LayoutX.Value()
		}

		if item.LayoutY.IsSet() && item.LayoutY.Value() != nil {
			button.LayoutY = *item.LayoutY.Value()
		}

		if item.Width.IsSet() {
			button.Width = item.Width.Value()
		}

		if item.Height.IsSet() {
			button.Height = item.Height.Value()
		}

		if item.Color.IsSet() {
			button.Color = item.Color.Value()
		}

		if item.Label.IsSet() {
			button.Label = item.Label.Value()
		}

		result = r.db.WithContext(ctx).Save(&button)
		if result.Error != nil {
			return nil, result.Error
		}

		updatedButtons = append(updatedButtons, &button)
	}

	return updatedButtons, nil
}

// BulkDeleteSceneBoardButtons is the resolver for the bulkDeleteSceneBoardButtons field.
func (r *mutationResolver) BulkDeleteSceneBoardButtons(ctx context.Context, buttonIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, buttonID := range buttonIds {
		_, err := r.RemoveSceneFromBoard(ctx, buttonID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, buttonID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// ActivateSceneFromBoard is the resolver for the activateSceneFromBoard field.
func (r *mutationResolver) ActivateSceneFromBoard(ctx context.Context, sceneBoardID string, sceneID string, fadeTimeOverride *float64) (bool, error) {
	// Verify scene board exists
	var board models.SceneBoard
	result := r.db.WithContext(ctx).First(&board, "id = ?", sceneBoardID)
	if result.Error != nil {
		return false, fmt.Errorf("scene board not found: %w", result.Error)
	}

	// Verify scene exists
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return false, err
	}
	if scene == nil {
		return false, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Use fade time override if provided, otherwise use board default
	fadeTime := board.DefaultFadeTime
	if fadeTimeOverride != nil {
		fadeTime = *fadeTimeOverride
	}

	// Load scene with fixture values
	var fullScene models.Scene
	result = r.db.WithContext(ctx).Preload("FixtureValues").First(&fullScene, "id = ?", sceneID)
	if result.Error != nil {
		return false, result.Error
	}

	// Load fixtures for the scene's fixture values
	var fixtureIDs []string
	for _, fv := range fullScene.FixtureValues {
		fixtureIDs = append(fixtureIDs, fv.FixtureID)
	}

	var fixtures []models.FixtureInstance
	if len(fixtureIDs) > 0 {
		// Load fixtures with their channels to get fadeBehavior
		r.db.WithContext(ctx).Preload("Channels").Where("id IN ?", fixtureIDs).Find(&fixtures)
	}

	// Create fixture lookup map
	fixtureMap := make(map[string]*models.FixtureInstance)
	for i := range fixtures {
		fixtureMap[fixtures[i].ID] = &fixtures[i]
	}

	// Build scene channels for fade
	var sceneChannels []fade.SceneChannel
	for _, fixtureValue := range fullScene.FixtureValues {
		fixture := fixtureMap[fixtureValue.FixtureID]
		if fixture == nil {
			continue
		}

		// Parse channel values from JSON
		var channelValues []int
		if err := json.Unmarshal([]byte(fixtureValue.ChannelValues), &channelValues); err != nil {
			continue
		}

		// Build channel targets with fade behavior from channel definitions
		for channelIndex, value := range channelValues {
			dmxChannel := fixture.StartChannel + channelIndex

			// Get fade behavior from channel definition (if available)
			fadeBehavior := fade.FadeBehaviorFade // Default to FADE
			if channelIndex < len(fixture.Channels) {
				// Find the channel with matching offset
				for _, ch := range fixture.Channels {
					if ch.Offset == channelIndex {
						if ch.FadeBehavior != "" {
							fadeBehavior = ch.FadeBehavior
						}
						break
					}
				}
			}

			sceneChannels = append(sceneChannels, fade.SceneChannel{
				Universe:     fixture.Universe,
				Channel:      dmxChannel,
				Value:        value,
				FadeBehavior: fadeBehavior,
			})
		}
	}

	// Execute fade
	fadeID := fmt.Sprintf("scene-board-%s", sceneID)
	fadeDuration := time.Duration(fadeTime * float64(time.Second))
	r.FadeEngine.FadeToScene(sceneChannels, fadeDuration, fadeID, fade.EasingInOutSine)

	// Track the active scene
	r.DMXService.SetActiveScene(sceneID)

	return true, nil
}

// CreateCueList is the resolver for the createCueList field.
func (r *mutationResolver) CreateCueList(ctx context.Context, input generated.CreateCueListInput) (*models.CueList, error) {
	cueList := &models.CueList{
		Name:      input.Name,
		ProjectID: input.ProjectID,
	}

	if input.Description.IsSet() {
		cueList.Description = input.Description.Value()
	}

	if input.Loop.IsSet() && input.Loop.Value() != nil {
		cueList.Loop = *input.Loop.Value()
	}

	if err := r.CueListRepo.Create(ctx, cueList); err != nil {
		return nil, err
	}

	return cueList, nil
}

// UpdateCueList is the resolver for the updateCueList field.
func (r *mutationResolver) UpdateCueList(ctx context.Context, id string, input generated.CreateCueListInput) (*models.CueList, error) {
	cueList, err := r.CueListRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if cueList == nil {
		return nil, fmt.Errorf("cue list not found: %s", id)
	}

	// Update fields
	cueList.Name = input.Name

	if input.Description.IsSet() {
		cueList.Description = input.Description.Value()
	}

	if input.Loop.IsSet() && input.Loop.Value() != nil {
		cueList.Loop = *input.Loop.Value()
	}

	if err := r.CueListRepo.Update(ctx, cueList); err != nil {
		return nil, err
	}

	return cueList, nil
}

// DeleteCueList is the resolver for the deleteCueList field.
func (r *mutationResolver) DeleteCueList(ctx context.Context, id string) (bool, error) {
	cueList, err := r.CueListRepo.FindByID(ctx, id)
	if err != nil {
		return false, err
	}
	if cueList == nil {
		return false, fmt.Errorf("cue list not found: %s", id)
	}

	// Delete all cues first
	if err := r.CueRepo.DeleteByCueListID(ctx, id); err != nil {
		return false, err
	}

	// Delete the cue list
	if err := r.CueListRepo.Delete(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// BulkCreateCueLists is the resolver for the bulkCreateCueLists field.
func (r *mutationResolver) BulkCreateCueLists(ctx context.Context, input generated.BulkCueListCreateInput) ([]*models.CueList, error) {
	var createdCueLists []*models.CueList

	for _, cueListInput := range input.CueLists {
		cueList, err := r.CreateCueList(ctx, *cueListInput)
		if err != nil {
			return nil, err
		}
		createdCueLists = append(createdCueLists, cueList)
	}

	return createdCueLists, nil
}

// BulkUpdateCueLists is the resolver for the bulkUpdateCueLists field.
func (r *mutationResolver) BulkUpdateCueLists(ctx context.Context, input generated.BulkCueListUpdateInput) ([]*models.CueList, error) {
	var updatedCueLists []*models.CueList

	for _, item := range input.CueLists {
		cueList, err := r.CueListRepo.FindByID(ctx, item.CueListID)
		if err != nil {
			return nil, err
		}
		if cueList == nil {
			return nil, fmt.Errorf("cue list not found: %s", item.CueListID)
		}

		if item.Name.IsSet() && item.Name.Value() != nil {
			cueList.Name = *item.Name.Value()
		}

		if item.Description.IsSet() {
			cueList.Description = item.Description.Value()
		}

		if item.Loop.IsSet() && item.Loop.Value() != nil {
			cueList.Loop = *item.Loop.Value()
		}

		if err := r.CueListRepo.Update(ctx, cueList); err != nil {
			return nil, err
		}

		updatedCueLists = append(updatedCueLists, cueList)
	}

	return updatedCueLists, nil
}

// BulkDeleteCueLists is the resolver for the bulkDeleteCueLists field.
func (r *mutationResolver) BulkDeleteCueLists(ctx context.Context, cueListIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, cueListID := range cueListIds {
		_, err := r.DeleteCueList(ctx, cueListID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, cueListID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// CreateCue is the resolver for the createCue field.
func (r *mutationResolver) CreateCue(ctx context.Context, input generated.CreateCueInput) (*models.Cue, error) {
	// Verify cue list exists
	cueList, err := r.CueListRepo.FindByID(ctx, input.CueListID)
	if err != nil {
		return nil, err
	}
	if cueList == nil {
		return nil, fmt.Errorf("cue list not found: %s", input.CueListID)
	}

	// Verify scene exists
	scene, err := r.SceneRepo.FindByID(ctx, input.SceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", input.SceneID)
	}

	cue := &models.Cue{
		Name:        input.Name,
		CueNumber:   input.CueNumber,
		CueListID:   input.CueListID,
		SceneID:     input.SceneID,
		FadeInTime:  input.FadeInTime,
		FadeOutTime: input.FadeOutTime,
	}

	if input.FollowTime.IsSet() {
		cue.FollowTime = input.FollowTime.Value()
	}

	if input.EasingType.IsSet() && input.EasingType.Value() != nil {
		easingStr := string(*input.EasingType.Value())
		cue.EasingType = &easingStr
	}

	if input.Notes.IsSet() {
		cue.Notes = input.Notes.Value()
	}

	if err := r.CueRepo.Create(ctx, cue); err != nil {
		return nil, err
	}

	return cue, nil
}

// UpdateCue is the resolver for the updateCue field.
func (r *mutationResolver) UpdateCue(ctx context.Context, id string, input generated.CreateCueInput) (*models.Cue, error) {
	cue, err := r.CueRepo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if cue == nil {
		return nil, fmt.Errorf("cue not found: %s", id)
	}

	// Verify scene exists if being changed
	if input.SceneID != cue.SceneID {
		scene, err := r.SceneRepo.FindByID(ctx, input.SceneID)
		if err != nil {
			return nil, err
		}
		if scene == nil {
			return nil, fmt.Errorf("scene not found: %s", input.SceneID)
		}
	}

	// Update fields
	cue.Name = input.Name
	cue.CueNumber = input.CueNumber
	cue.SceneID = input.SceneID
	cue.FadeInTime = input.FadeInTime
	cue.FadeOutTime = input.FadeOutTime

	if input.FollowTime.IsSet() {
		cue.FollowTime = input.FollowTime.Value()
	}

	if input.EasingType.IsSet() && input.EasingType.Value() != nil {
		easingStr := string(*input.EasingType.Value())
		cue.EasingType = &easingStr
	}

	if input.Notes.IsSet() {
		cue.Notes = input.Notes.Value()
	}

	if err := r.CueRepo.Update(ctx, cue); err != nil {
		return nil, err
	}

	return cue, nil
}

// DeleteCue is the resolver for the deleteCue field.
func (r *mutationResolver) DeleteCue(ctx context.Context, id string) (bool, error) {
	cue, err := r.CueRepo.FindByID(ctx, id)
	if err != nil {
		return false, err
	}
	if cue == nil {
		return false, fmt.Errorf("cue not found: %s", id)
	}

	if err := r.CueRepo.Delete(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// ReorderCues is the resolver for the reorderCues field.
func (r *mutationResolver) ReorderCues(ctx context.Context, cueListID string, cueOrders []*generated.CueOrderInput) (bool, error) {
	// Verify cue list exists
	cueList, err := r.CueListRepo.FindByID(ctx, cueListID)
	if err != nil {
		return false, err
	}
	if cueList == nil {
		return false, fmt.Errorf("cue list not found: %s", cueListID)
	}

	// Update each cue's number
	for _, order := range cueOrders {
		cue, err := r.CueRepo.FindByID(ctx, order.CueID)
		if err != nil {
			return false, err
		}
		if cue == nil {
			return false, fmt.Errorf("cue not found: %s", order.CueID)
		}

		cue.CueNumber = order.CueNumber
		if err := r.CueRepo.Update(ctx, cue); err != nil {
			return false, err
		}
	}

	return true, nil
}

// BulkCreateCues is the resolver for the bulkCreateCues field.
func (r *mutationResolver) BulkCreateCues(ctx context.Context, input generated.BulkCueCreateInput) ([]*models.Cue, error) {
	var createdCues []*models.Cue

	for _, cueInput := range input.Cues {
		cue, err := r.CreateCue(ctx, *cueInput)
		if err != nil {
			return nil, err
		}
		createdCues = append(createdCues, cue)
	}

	return createdCues, nil
}

// BulkUpdateCues is the resolver for the bulkUpdateCues field.
func (r *mutationResolver) BulkUpdateCues(ctx context.Context, input generated.BulkCueUpdateInput) ([]*models.Cue, error) {
	var updatedCues []*models.Cue

	for _, cueID := range input.CueIds {
		cue, err := r.CueRepo.FindByID(ctx, cueID)
		if err != nil {
			return nil, err
		}
		if cue == nil {
			return nil, fmt.Errorf("cue not found: %s", cueID)
		}

		// Update fade in time if provided
		if input.FadeInTime.IsSet() && input.FadeInTime.Value() != nil {
			cue.FadeInTime = *input.FadeInTime.Value()
		}

		// Update fade out time if provided
		if input.FadeOutTime.IsSet() && input.FadeOutTime.Value() != nil {
			cue.FadeOutTime = *input.FadeOutTime.Value()
		}

		// Update follow time if provided
		if input.FollowTime.IsSet() {
			cue.FollowTime = input.FollowTime.Value()
		}

		// Update easing type if provided
		if input.EasingType.IsSet() && input.EasingType.Value() != nil {
			easingStr := string(*input.EasingType.Value())
			cue.EasingType = &easingStr
		}

		if err := r.CueRepo.Update(ctx, cue); err != nil {
			return nil, err
		}

		updatedCues = append(updatedCues, cue)
	}

	return updatedCues, nil
}

// BulkDeleteCues is the resolver for the bulkDeleteCues field.
func (r *mutationResolver) BulkDeleteCues(ctx context.Context, cueIds []string) (*generated.BulkDeleteResult, error) {
	var deletedIds []string

	for _, cueID := range cueIds {
		_, err := r.DeleteCue(ctx, cueID)
		if err != nil {
			return nil, err
		}
		deletedIds = append(deletedIds, cueID)
	}

	return &generated.BulkDeleteResult{
		DeletedCount: len(deletedIds),
		DeletedIds:   deletedIds,
	}, nil
}

// StartPreviewSession is the resolver for the startPreviewSession field.
func (r *mutationResolver) StartPreviewSession(ctx context.Context, projectID string) (*models.PreviewSession, error) {
	session, err := r.PreviewService.StartSession(ctx, projectID, nil)
	if err != nil {
		return nil, err
	}

	// Convert to models.PreviewSession and persist to database
	var userID string
	if session.UserID != nil {
		userID = *session.UserID
	}

	dbSession := &models.PreviewSession{
		ID:        session.ID,
		ProjectID: session.ProjectID,
		UserID:    userID,
		IsActive:  session.IsActive,
		CreatedAt: session.CreatedAt,
	}

	// Persist to database so it can be queried
	if err := r.db.Create(dbSession).Error; err != nil {
		// Rollback in-memory session if database creation fails
		_, _ = r.PreviewService.CancelSession(ctx, session.ID)
		return nil, err
	}

	return dbSession, nil
}

// CommitPreviewSession is the resolver for the commitPreviewSession field.
func (r *mutationResolver) CommitPreviewSession(ctx context.Context, sessionID string) (bool, error) {
	return r.PreviewService.CommitSession(ctx, sessionID)
}

// CancelPreviewSession is the resolver for the cancelPreviewSession field.
func (r *mutationResolver) CancelPreviewSession(ctx context.Context, sessionID string) (bool, error) {
	success, err := r.PreviewService.CancelSession(ctx, sessionID)
	if err != nil {
		return false, err
	}

	// Also delete from database
	if success {
		if err := r.db.Where("id = ?", sessionID).Delete(&models.PreviewSession{}).Error; err != nil {
			return false, err
		}
	}

	return success, nil
}

// UpdatePreviewChannel is the resolver for the updatePreviewChannel field.
func (r *mutationResolver) UpdatePreviewChannel(ctx context.Context, sessionID string, fixtureID string, channelIndex int, value int) (bool, error) {
	return r.PreviewService.UpdateChannelValue(ctx, sessionID, fixtureID, channelIndex, value)
}

// InitializePreviewWithScene is the resolver for the initializePreviewWithScene field.
func (r *mutationResolver) InitializePreviewWithScene(ctx context.Context, sessionID string, sceneID string) (bool, error) {
	return r.PreviewService.InitializeWithScene(ctx, sessionID, sceneID)
}

// SetChannelValue is the resolver for the setChannelValue field.
func (r *mutationResolver) SetChannelValue(ctx context.Context, universe int, channel int, value int) (bool, error) {
	// Clamp value to 0-255
	if value < 0 {
		value = 0
	}
	if value > 255 {
		value = 255
	}
	// DMX service expects 1-indexed universe and channel
	r.DMXService.SetChannelValue(universe, channel, byte(value))
	return true, nil
}

// SetSceneLive is the resolver for the setSceneLive field.
func (r *mutationResolver) SetSceneLive(ctx context.Context, sceneID string) (bool, error) {
	// Load scene with fixture values
	var scene models.Scene
	result := r.db.Preload("FixtureValues").First(&scene, "id = ?", sceneID)
	if result.Error != nil {
		return false, fmt.Errorf("scene not found: %w", result.Error)
	}

	// Load fixtures for the scene's fixture values
	var fixtureIDs []string
	for _, fv := range scene.FixtureValues {
		fixtureIDs = append(fixtureIDs, fv.FixtureID)
	}

	var fixtures []models.FixtureInstance
	if len(fixtureIDs) > 0 {
		r.db.Where("id IN ?", fixtureIDs).Find(&fixtures)
	}

	// Create fixture lookup map
	fixtureMap := make(map[string]*models.FixtureInstance)
	for i := range fixtures {
		fixtureMap[fixtures[i].ID] = &fixtures[i]
	}

	// Set channel values directly (no fade)
	for _, fixtureValue := range scene.FixtureValues {
		fixture := fixtureMap[fixtureValue.FixtureID]
		if fixture == nil {
			continue
		}

		// Parse channel values from JSON
		var channelValues []int
		if err := json.Unmarshal([]byte(fixtureValue.ChannelValues), &channelValues); err != nil {
			continue
		}

		// Set channel values
		for channelIndex, value := range channelValues {
			dmxChannel := fixture.StartChannel + channelIndex
			r.DMXService.SetChannelValue(fixture.Universe, dmxChannel, byte(value))
		}
	}

	// Track the active scene
	r.DMXService.SetActiveScene(sceneID)

	return true, nil
}

// PlayCue is the resolver for the playCue field.
func (r *mutationResolver) PlayCue(ctx context.Context, cueID string, fadeInTime *float64) (bool, error) {
	if err := r.PlaybackService.ExecuteCueDmx(ctx, cueID, fadeInTime); err != nil {
		return false, err
	}
	return true, nil
}

// FadeToBlack is the resolver for the fadeToBlack field.
func (r *mutationResolver) FadeToBlack(ctx context.Context, fadeOutTime float64) (bool, error) {
	// Convert fadeOutTime from seconds to duration
	duration := time.Duration(fadeOutTime * float64(time.Second))

	// Use the fade engine to smoothly fade to black
	fadeID := r.FadeEngine.FadeToBlack(duration, "")

	// For instant fades (0 duration), also immediately clear DMX state
	// For timed fades, the fade engine will handle the gradual transition,
	// but we still need to ensure the DMX service state is cleared at the end
	if duration == 0 {
		r.DMXService.FadeToBlack()
	} else {
		// After fade completes, ensure DMX service clears all channels
		// This handles channels set directly via SetChannelValue that may not be tracked by fade engine
		// Use the fadeID to detect if a new fade has started and skip cleanup if so
		go func(currentFadeID string) {
			time.Sleep(duration + 100*time.Millisecond) // Wait for fade to complete
			// Only clear if this is still the active fade (no new fade has started)
			if r.FadeEngine.ActiveFadeCount() == 0 {
				r.DMXService.FadeToBlack()
			}
		}(fadeID)
	}

	// Clear active scene tracking
	r.DMXService.ClearActiveScene()

	_ = fadeID // suppress unused variable warning
	return true, nil
}

// StartCueList is the resolver for the startCueList field.
func (r *mutationResolver) StartCueList(ctx context.Context, cueListID string, startFromCue *int, fadeInTime *float64) (bool, error) {
	var startFromCueNumber *float64
	if startFromCue != nil {
		cueNum := float64(*startFromCue)
		startFromCueNumber = &cueNum
	}
	if err := r.PlaybackService.StartCueList(ctx, cueListID, startFromCueNumber, fadeInTime); err != nil {
		return false, err
	}
	return true, nil
}

// NextCue is the resolver for the nextCue field.
func (r *mutationResolver) NextCue(ctx context.Context, cueListID string, fadeInTime *float64) (bool, error) {
	if err := r.PlaybackService.NextCue(ctx, cueListID, fadeInTime); err != nil {
		return false, err
	}
	return true, nil
}

// PreviousCue is the resolver for the previousCue field.
func (r *mutationResolver) PreviousCue(ctx context.Context, cueListID string, fadeInTime *float64) (bool, error) {
	if err := r.PlaybackService.PreviousCue(ctx, cueListID, fadeInTime); err != nil {
		return false, err
	}
	return true, nil
}

// GoToCue is the resolver for the goToCue field.
func (r *mutationResolver) GoToCue(ctx context.Context, cueListID string, cueIndex int, fadeInTime *float64) (bool, error) {
	if err := r.PlaybackService.JumpToCue(ctx, cueListID, cueIndex); err != nil {
		return false, err
	}
	return true, nil
}

// StopCueList is the resolver for the stopCueList field.
func (r *mutationResolver) StopCueList(ctx context.Context, cueListID string) (bool, error) {
	r.PlaybackService.StopCueList(cueListID)
	return true, nil
}

// ExportProject is the resolver for the exportProject field.
func (r *mutationResolver) ExportProject(ctx context.Context, projectID string, options *generated.ExportOptionsInput) (*generated.ExportResult, error) {
	// Get project first to get name
	project, err := r.ProjectRepo.FindByID(ctx, projectID)
	if err != nil {
		return nil, err
	}
	if project == nil {
		return nil, fmt.Errorf("project not found: %s", projectID)
	}

	// Parse options
	includeFixtures := true
	includeScenes := true
	includeCueLists := true

	if options != nil {
		if options.IncludeFixtures.IsSet() && options.IncludeFixtures.Value() != nil {
			includeFixtures = *options.IncludeFixtures.Value()
		}
		if options.IncludeScenes.IsSet() && options.IncludeScenes.Value() != nil {
			includeScenes = *options.IncludeScenes.Value()
		}
		if options.IncludeCueLists.IsSet() && options.IncludeCueLists.Value() != nil {
			includeCueLists = *options.IncludeCueLists.Value()
		}
	}

	// Export project
	exported, stats, err := r.ExportService.ExportProject(ctx, projectID, includeFixtures, includeScenes, includeCueLists)
	if err != nil {
		return nil, err
	}
	if exported == nil {
		return nil, fmt.Errorf("project not found: %s", projectID)
	}

	// Convert to JSON
	jsonContent, err := exported.ToJSON()
	if err != nil {
		return nil, err
	}

	return &generated.ExportResult{
		ProjectID:   projectID,
		ProjectName: project.Name,
		JSONContent: jsonContent,
		Stats: generated.ExportStats{
			FixtureDefinitionsCount: stats.FixtureDefinitionsCount,
			FixtureInstancesCount:   stats.FixtureInstancesCount,
			ScenesCount:             stats.ScenesCount,
			CueListsCount:           stats.CueListsCount,
			CuesCount:               stats.CuesCount,
		},
	}, nil
}

// ImportProject is the resolver for the importProject field.
func (r *mutationResolver) ImportProject(ctx context.Context, jsonContent string, options generated.ImportOptionsInput) (*generated.ImportResult, error) {
	// Build import options
	importOpts := importservice.ImportOptions{
		Mode:                    importservice.ImportMode(options.Mode),
		ImportBuiltInFixtures:   false,
		FixtureConflictStrategy: importservice.FixtureConflictSkip,
	}

	if options.TargetProjectID.IsSet() {
		importOpts.TargetProjectID = options.TargetProjectID.Value()
	}

	if options.ProjectName.IsSet() {
		importOpts.ProjectName = options.ProjectName.Value()
	}

	if options.FixtureConflictStrategy.IsSet() && options.FixtureConflictStrategy.Value() != nil {
		importOpts.FixtureConflictStrategy = importservice.FixtureConflictStrategy(*options.FixtureConflictStrategy.Value())
	}

	if options.ImportBuiltInFixtures.IsSet() && options.ImportBuiltInFixtures.Value() != nil {
		importOpts.ImportBuiltInFixtures = *options.ImportBuiltInFixtures.Value()
	}

	// Import project
	projectID, stats, warnings, err := r.ImportService.ImportProject(ctx, jsonContent, importOpts)
	if err != nil {
		return nil, err
	}

	return &generated.ImportResult{
		ProjectID: projectID,
		Stats: generated.ImportStats{
			FixtureDefinitionsCreated: stats.FixtureDefinitionsCreated,
			FixtureInstancesCreated:   stats.FixtureInstancesCreated,
			ScenesCreated:             stats.ScenesCreated,
			CueListsCreated:           stats.CueListsCreated,
			CuesCreated:               stats.CuesCreated,
		},
		Warnings: warnings,
	}, nil
}

// ImportProjectFromQlc is the resolver for the importProjectFromQLC field.
// Returns error - QLC+ import not available on this platform
func (r *mutationResolver) ImportProjectFromQlc(ctx context.Context, xmlContent string, originalFileName string) (*generated.QLCImportResult, error) {
	return nil, fmt.Errorf("QLC+ import not available on this platform")
}

// ExportProjectToQlc is the resolver for the exportProjectToQLC field.
// Returns error - QLC+ export not available on this platform
func (r *mutationResolver) ExportProjectToQlc(ctx context.Context, projectID string, fixtureMappings []*generated.FixtureMappingInput) (*generated.QLCExportResult, error) {
	return nil, fmt.Errorf("QLC+ export not available on this platform")
}

// UpdateSetting is the resolver for the updateSetting field.
func (r *mutationResolver) UpdateSetting(ctx context.Context, input generated.UpdateSettingInput) (*models.Setting, error) {
	setting, err := r.SettingRepo.Upsert(ctx, input.Key, input.Value)
	if err != nil {
		return nil, err
	}

	// If the artnet broadcast address is being updated, reload the DMX service
	if input.Key == "artnet_broadcast_address" {
		if err := r.DMXService.ReloadBroadcastAddress(input.Value); err != nil {
			// Log but don't fail - the setting was saved
			fmt.Printf("Warning: failed to reload Art-Net broadcast address: %v\n", err)
		}
	}

	return setting, nil
}

// ConnectWiFi is the resolver for the connectWiFi field.
// Returns failure - WiFi not available on this platform
func (r *mutationResolver) ConnectWiFi(ctx context.Context, ssid string, password *string) (*generated.WiFiConnectionResult, error) {
	msg := "WiFi management not available on this platform"
	return &generated.WiFiConnectionResult{
		Success:   false,
		Message:   &msg,
		Connected: false,
	}, nil
}

// DisconnectWiFi is the resolver for the disconnectWiFi field.
// Returns failure - WiFi not available on this platform
func (r *mutationResolver) DisconnectWiFi(ctx context.Context) (*generated.WiFiConnectionResult, error) {
	msg := "WiFi management not available on this platform"
	return &generated.WiFiConnectionResult{
		Success:   false,
		Message:   &msg,
		Connected: false,
	}, nil
}

// SetWiFiEnabled is the resolver for the setWiFiEnabled field.
// Returns status indicating WiFi is not available on this platform
func (r *mutationResolver) SetWiFiEnabled(ctx context.Context, enabled bool) (*generated.WiFiStatus, error) {
	return &generated.WiFiStatus{
		Available: false,
		Enabled:   false,
		Connected: false,
	}, nil
}

// ForgetWiFiNetwork is the resolver for the forgetWiFiNetwork field.
// Returns false - WiFi not available on this platform
func (r *mutationResolver) ForgetWiFiNetwork(ctx context.Context, ssid string) (bool, error) {
	return false, nil
}

// UpdateRepository is the resolver for the updateRepository field.
// Updates a specific repository to a specific version
func (r *mutationResolver) UpdateRepository(ctx context.Context, repository string, version *string) (*generated.UpdateResult, error) {
	result, err := r.VersionService.UpdateRepository(repository, version)
	if err != nil {
		errMsg := err.Error()
		return &generated.UpdateResult{
			Success:         false,
			Repository:      repository,
			PreviousVersion: "",
			NewVersion:      "",
			Error:           &errMsg,
		}, nil
	}

	return &generated.UpdateResult{
		Success:         result.Success,
		Repository:      result.Repository,
		PreviousVersion: result.PreviousVersion,
		NewVersion:      result.NewVersion,
		Message:         stringToPointer(result.Message),
		Error:           stringToPointer(result.Error),
	}, nil
}

// UpdateAllRepositories is the resolver for the updateAllRepositories field.
// Updates all repositories to their latest versions
func (r *mutationResolver) UpdateAllRepositories(ctx context.Context) ([]*generated.UpdateResult, error) {
	results, err := r.VersionService.UpdateAllRepositories()
	if err != nil {
		return nil, err
	}

	var gqlResults []*generated.UpdateResult
	for _, result := range results {
		gqlResults = append(gqlResults, &generated.UpdateResult{
			Success:         result.Success,
			Repository:      result.Repository,
			PreviousVersion: result.PreviousVersion,
			NewVersion:      result.NewVersion,
			Message:         stringToPointer(result.Message),
			Error:           stringToPointer(result.Error),
		})
	}

	return gqlResults, nil
}

// TriggerOFLImport is the resolver for the triggerOFLImport field.
func (r *mutationResolver) TriggerOFLImport(ctx context.Context, options *generated.OFLImportOptionsInput) (*generated.OFLImportResult, error) {
	// Convert GraphQL input to service options
	var opts *ofl.ImportOptions
	if options != nil {
		opts = &ofl.ImportOptions{}
		// Handle Omittable types - get the underlying value if set
		if v := options.ForceReimport.Value(); v != nil {
			opts.ForceReimport = *v
		}
		if v := options.UpdateInUseFixtures.Value(); v != nil {
			opts.UpdateInUseFixtures = *v
		}
		if v := options.PreferBundled.Value(); v != nil {
			opts.PreferBundled = *v
		}
		if v := options.Manufacturers.Value(); v != nil {
			opts.Manufacturers = v
		}
	}

	// Trigger the import
	result, err := r.OFLManager.TriggerImport(ctx, opts)
	if err != nil {
		return &generated.OFLImportResult{
			Success:      false,
			ErrorMessage: stringPtr(err.Error()),
			OflVersion:   "unknown",
			Stats: generated.OFLImportStats{
				TotalProcessed:    0,
				SuccessfulImports: 0,
				FailedImports:     0,
				SkippedDuplicates: 0,
				UpdatedFixtures:   0,
				DurationSeconds:   0,
			},
		}, nil
	}

	return &generated.OFLImportResult{
		Success:    result.Success,
		OflVersion: result.OFLVersion,
		Stats: generated.OFLImportStats{
			TotalProcessed:    result.Stats.TotalProcessed,
			SuccessfulImports: result.Stats.SuccessfulImports,
			FailedImports:     result.Stats.FailedImports,
			SkippedDuplicates: result.Stats.SkippedDuplicates,
			UpdatedFixtures:   result.Stats.UpdatedFixtures,
			DurationSeconds:   result.Stats.DurationSeconds,
		},
	}, nil
}

// CancelOFLImport is the resolver for the cancelOFLImport field.
func (r *mutationResolver) CancelOFLImport(ctx context.Context) (bool, error) {
	return r.OFLManager.CancelImport(), nil
}

// Project is the resolver for the project field.
func (r *previewSessionResolver) Project(ctx context.Context, obj *models.PreviewSession) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// User is the resolver for the user field.
func (r *previewSessionResolver) User(ctx context.Context, obj *models.PreviewSession) (*models.User, error) {
	if obj.UserID == "" {
		return nil, nil
	}
	var user models.User
	result := r.db.First(&user, "id = ?", obj.UserID)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *previewSessionResolver) CreatedAt(ctx context.Context, obj *models.PreviewSession) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// DmxOutput is the resolver for the dmxOutput field.
func (r *previewSessionResolver) DmxOutput(ctx context.Context, obj *models.PreviewSession) ([]*generated.UniverseOutput, error) {
	// Get DMX output from preview service
	previewOutput := r.PreviewService.GetDMXOutput(obj.ID)
	if previewOutput == nil {
		return []*generated.UniverseOutput{}, nil
	}

	// Convert to GraphQL type
	result := make([]*generated.UniverseOutput, len(previewOutput))
	for i, output := range previewOutput {
		result[i] = &generated.UniverseOutput{
			Universe: output.Universe,
			Channels: output.Channels,
		}
	}
	return result, nil
}

// FixtureCount is the resolver for the fixtureCount field.
func (r *projectResolver) FixtureCount(ctx context.Context, obj *models.Project) (int, error) {
	count, err := r.ProjectRepo.CountFixtures(ctx, obj.ID)
	return int(count), err
}

// SceneCount is the resolver for the sceneCount field.
func (r *projectResolver) SceneCount(ctx context.Context, obj *models.Project) (int, error) {
	count, err := r.ProjectRepo.CountScenes(ctx, obj.ID)
	return int(count), err
}

// CueListCount is the resolver for the cueListCount field.
func (r *projectResolver) CueListCount(ctx context.Context, obj *models.Project) (int, error) {
	count, err := r.ProjectRepo.CountCueLists(ctx, obj.ID)
	return int(count), err
}

// CreatedAt is the resolver for the createdAt field.
func (r *projectResolver) CreatedAt(ctx context.Context, obj *models.Project) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *projectResolver) UpdatedAt(ctx context.Context, obj *models.Project) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Fixtures is the resolver for the fixtures field.
func (r *projectResolver) Fixtures(ctx context.Context, obj *models.Project) ([]*models.FixtureInstance, error) {
	fixtures, err := r.FixtureRepo.FindByProjectID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	pointers := make([]*models.FixtureInstance, len(fixtures))
	for i := range fixtures {
		pointers[i] = &fixtures[i]
	}
	return pointers, nil
}

// Scenes is the resolver for the scenes field.
func (r *projectResolver) Scenes(ctx context.Context, obj *models.Project) ([]*models.Scene, error) {
	scenes, err := r.SceneRepo.FindByProjectID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	pointers := make([]*models.Scene, len(scenes))
	for i := range scenes {
		pointers[i] = &scenes[i]
	}
	return pointers, nil
}

// CueLists is the resolver for the cueLists field.
func (r *projectResolver) CueLists(ctx context.Context, obj *models.Project) ([]*models.CueList, error) {
	cueLists, err := r.CueListRepo.FindByProjectID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	pointers := make([]*models.CueList, len(cueLists))
	for i := range cueLists {
		pointers[i] = &cueLists[i]
	}
	return pointers, nil
}

// SceneBoards is the resolver for the sceneBoards field.
func (r *projectResolver) SceneBoards(ctx context.Context, obj *models.Project) ([]*models.SceneBoard, error) {
	var boards []models.SceneBoard
	result := r.db.Where("project_id = ?", obj.ID).Order("created_at DESC").Find(&boards)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.SceneBoard, len(boards))
	for i := range boards {
		pointers[i] = &boards[i]
	}
	return pointers, nil
}

// Users is the resolver for the users field.
func (r *projectResolver) Users(ctx context.Context, obj *models.Project) ([]*models.ProjectUser, error) {
	var users []models.ProjectUser
	result := r.db.Where("project_id = ?", obj.ID).Find(&users)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.ProjectUser, len(users))
	for i := range users {
		pointers[i] = &users[i]
	}
	return pointers, nil
}

// User is the resolver for the user field.
func (r *projectUserResolver) User(ctx context.Context, obj *models.ProjectUser) (*models.User, error) {
	var user models.User
	result := r.db.First(&user, "id = ?", obj.UserID)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

// Project is the resolver for the project field.
func (r *projectUserResolver) Project(ctx context.Context, obj *models.ProjectUser) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// Role is the resolver for the role field.
func (r *projectUserResolver) Role(ctx context.Context, obj *models.ProjectUser) (generated.ProjectRole, error) {
	if obj.Role != "" {
		return generated.ProjectRole(obj.Role), nil
	}
	return generated.ProjectRoleViewer, nil
}

// JoinedAt is the resolver for the joinedAt field.
func (r *projectUserResolver) JoinedAt(ctx context.Context, obj *models.ProjectUser) (string, error) {
	return obj.JoinedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*models.Project, error) {
	projects, err := r.ProjectRepo.FindAll(ctx)
	if err != nil {
		return nil, err
	}
	// Convert to pointers
	result := make([]*models.Project, len(projects))
	for i := range projects {
		result[i] = &projects[i]
	}
	return result, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, id)
}

// FixtureDefinitions is the resolver for the fixtureDefinitions field.
func (r *queryResolver) FixtureDefinitions(ctx context.Context, filter *generated.FixtureDefinitionFilter) ([]*models.FixtureDefinition, error) {
	defs, err := r.FixtureRepo.FindAllDefinitions(ctx)
	if err != nil {
		return nil, err
	}

	// Apply filters if provided
	var filtered []models.FixtureDefinition
	for _, def := range defs {
		// Apply manufacturer filter (case-insensitive partial match for autocomplete)
		if filter != nil && filter.Manufacturer.IsSet() {
			if mfr := filter.Manufacturer.Value(); mfr != nil && *mfr != "" {
				if !strings.Contains(strings.ToLower(def.Manufacturer), strings.ToLower(*mfr)) {
					continue
				}
			}
		}
		// Apply model filter (case-insensitive partial match for autocomplete)
		if filter != nil && filter.Model.IsSet() {
			if model := filter.Model.Value(); model != nil && *model != "" {
				if !strings.Contains(strings.ToLower(def.Model), strings.ToLower(*model)) {
					continue
				}
			}
		}
		// Apply type filter
		if filter != nil && filter.Type.IsSet() {
			if fixtureType := filter.Type.Value(); fixtureType != nil {
				if def.Type != string(*fixtureType) {
					continue
				}
			}
		}
		// Apply isBuiltIn filter
		if filter != nil && filter.IsBuiltIn.IsSet() {
			if isBuiltIn := filter.IsBuiltIn.Value(); isBuiltIn != nil {
				if def.IsBuiltIn != *isBuiltIn {
					continue
				}
			}
		}
		filtered = append(filtered, def)
	}

	// Convert to pointers
	result := make([]*models.FixtureDefinition, len(filtered))
	for i := range filtered {
		result[i] = &filtered[i]
	}
	return result, nil
}

// FixtureDefinition is the resolver for the fixtureDefinition field.
func (r *queryResolver) FixtureDefinition(ctx context.Context, id string) (*models.FixtureDefinition, error) {
	return r.FixtureRepo.FindDefinitionByID(ctx, id)
}

// FixtureInstances is the resolver for the fixtureInstances field.
func (r *queryResolver) FixtureInstances(ctx context.Context, projectID string, page *int, perPage *int, filter *generated.FixtureFilterInput) (*generated.FixtureInstancePage, error) {
	fixtures, err := r.FixtureRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Apply pagination
	pageNum := 1
	pageSize := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		pageSize = *perPage
	}

	total := len(fixtures)
	start := (pageNum - 1) * pageSize
	end := start + pageSize
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	// Convert to pointers
	items := make([]*models.FixtureInstance, end-start)
	for i := start; i < end; i++ {
		items[i-start] = &fixtures[i]
	}

	return &generated.FixtureInstancePage{
		Fixtures: items,
		Pagination: generated.PaginationInfo{
			Total:   total,
			Page:    pageNum,
			PerPage: pageSize,
			HasMore: end < total,
		},
	}, nil
}

// FixtureInstance is the resolver for the fixtureInstance field.
func (r *queryResolver) FixtureInstance(ctx context.Context, id string) (*models.FixtureInstance, error) {
	return r.FixtureRepo.FindByID(ctx, id)
}

// SearchFixtures is the resolver for the searchFixtures field.
func (r *queryResolver) SearchFixtures(ctx context.Context, projectID string, query string, filter *generated.FixtureFilterInput, page *int, perPage *int) (*generated.FixtureInstancePage, error) {
	fixtures, err := r.FixtureRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Filter by search query (name, manufacturer, model)
	var filtered []models.FixtureInstance
	queryLower := strings.ToLower(query)
	for _, f := range fixtures {
		if strings.Contains(strings.ToLower(f.Name), queryLower) {
			filtered = append(filtered, f)
			continue
		}
		if f.Manufacturer != nil && strings.Contains(strings.ToLower(*f.Manufacturer), queryLower) {
			filtered = append(filtered, f)
			continue
		}
		if f.Model != nil && strings.Contains(strings.ToLower(*f.Model), queryLower) {
			filtered = append(filtered, f)
			continue
		}
	}

	// Apply pagination
	pageNum := 1
	pageSize := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		pageSize = *perPage
	}

	total := len(filtered)
	start := (pageNum - 1) * pageSize
	end := start + pageSize
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	items := make([]*models.FixtureInstance, end-start)
	for i := start; i < end; i++ {
		items[i-start] = &filtered[i]
	}

	return &generated.FixtureInstancePage{
		Fixtures: items,
		Pagination: generated.PaginationInfo{
			Total:   total,
			Page:    pageNum,
			PerPage: pageSize,
			HasMore: end < total,
		},
	}, nil
}

// ChannelMap is the resolver for the channelMap field.
func (r *queryResolver) ChannelMap(ctx context.Context, projectID string, universe *int) (*generated.ChannelMapResult, error) {
	fixtures, err := r.FixtureRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Build fixtures per universe
	universeFixtures := make(map[int][]*generated.ChannelMapFixture)
	universeUsedChannels := make(map[int]int)

	for _, f := range fixtures {
		// Skip if filtering by universe and this fixture doesn't match
		if universe != nil && f.Universe != *universe {
			continue
		}

		channelCount := 1
		if f.ChannelCount != nil {
			channelCount = *f.ChannelCount
		}

		fixtureType := generated.FixtureTypeOther
		if f.Type != nil {
			fixtureType = generated.FixtureType(*f.Type)
		}

		fixture := &generated.ChannelMapFixture{
			ID:           f.ID,
			Name:         f.Name,
			Type:         fixtureType,
			StartChannel: f.StartChannel,
			EndChannel:   f.StartChannel + channelCount - 1,
			ChannelCount: channelCount,
		}
		universeFixtures[f.Universe] = append(universeFixtures[f.Universe], fixture)
		universeUsedChannels[f.Universe] += channelCount
	}

	// Build universe outputs
	var universes []*generated.UniverseChannelMap
	for uni, fixtureList := range universeFixtures {
		usedChannels := universeUsedChannels[uni]
		universes = append(universes, &generated.UniverseChannelMap{
			Universe:          uni,
			Fixtures:          fixtureList,
			ChannelUsage:      []*generated.ChannelUsage{}, // TODO: Add channel usage details
			AvailableChannels: 512 - usedChannels,
			UsedChannels:      usedChannels,
		})
	}

	return &generated.ChannelMapResult{
		ProjectID: projectID,
		Universes: universes,
	}, nil
}

// SuggestChannelAssignment is the resolver for the suggestChannelAssignment field.
func (r *queryResolver) SuggestChannelAssignment(ctx context.Context, input generated.ChannelAssignmentInput) (*generated.ChannelAssignmentSuggestion, error) {
	// Get existing fixtures to find used channels
	fixtures, err := r.FixtureRepo.FindByProjectID(ctx, input.ProjectID)
	if err != nil {
		return nil, err
	}

	// Build a map of used channels per universe
	usedChannels := make(map[int]map[int]bool)
	for _, f := range fixtures {
		if usedChannels[f.Universe] == nil {
			usedChannels[f.Universe] = make(map[int]bool)
		}
		channelCount := 1
		if f.ChannelCount != nil {
			channelCount = *f.ChannelCount
		}
		for ch := 0; ch < channelCount; ch++ {
			usedChannels[f.Universe][f.StartChannel+ch] = true
		}
	}

	// Find suggested assignments for each fixture spec
	var assignments []*generated.FixtureChannelAssignment
	universe := 1
	if input.Universe.IsSet() && input.Universe.Value() != nil {
		universe = *input.Universe.Value()
	}
	startChannel := 1
	if input.StartingChannel.IsSet() && input.StartingChannel.Value() != nil {
		startChannel = *input.StartingChannel.Value()
	}

	totalChannelsNeeded := 0
	for _, spec := range input.FixtureSpecs {
		channelCount := 1
		if spec.ChannelCount.IsSet() && spec.ChannelCount.Value() != nil {
			channelCount = *spec.ChannelCount.Value()
		}
		totalChannelsNeeded += channelCount

		// Find next available block of channels
		for {
			available := true
			for ch := 0; ch < channelCount; ch++ {
				if startChannel+ch > 512 {
					// Move to next universe
					universe++
					startChannel = 1
					if usedChannels[universe] == nil {
						usedChannels[universe] = make(map[int]bool)
					}
					available = false
					break
				}
				if usedChannels[universe][startChannel+ch] {
					available = false
					break
				}
			}
			if available {
				break
			}
			startChannel++
		}

		endChannel := startChannel + channelCount - 1
		channelRange := fmt.Sprintf("%d-%d", startChannel, endChannel)

		// Mode is Omittable[*string], need to extract the *string
		var mode *string
		if spec.Mode.IsSet() {
			mode = spec.Mode.Value()
		}

		assignments = append(assignments, &generated.FixtureChannelAssignment{
			FixtureName:  spec.Name,
			Manufacturer: spec.Manufacturer,
			Model:        spec.Model,
			Mode:         mode,
			StartChannel: startChannel,
			EndChannel:   endChannel,
			ChannelCount: channelCount,
			ChannelRange: channelRange,
		})

		// Mark these channels as used
		for ch := 0; ch < channelCount; ch++ {
			usedChannels[universe][startChannel+ch] = true
		}
		startChannel += channelCount
	}

	// Calculate available channels remaining
	availableRemaining := 512 - len(usedChannels[universe])

	return &generated.ChannelAssignmentSuggestion{
		Universe:                   universe,
		Assignments:                assignments,
		TotalChannelsNeeded:        totalChannelsNeeded,
		AvailableChannelsRemaining: availableRemaining,
	}, nil
}

// Scenes is the resolver for the scenes field.
func (r *queryResolver) Scenes(ctx context.Context, projectID string, page *int, perPage *int, filter *generated.SceneFilterInput, sortBy *generated.SceneSortField) (*generated.ScenePage, error) {
	scenes, err := r.SceneRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Apply pagination
	pageNum := 1
	pageSize := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		pageSize = *perPage
	}

	total := len(scenes)
	start := (pageNum - 1) * pageSize
	end := start + pageSize
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	// Convert to SceneSummary
	items := make([]*generated.SceneSummary, end-start)
	for i := start; i < end; i++ {
		scene := &scenes[i]
		fixtureCount, _ := r.SceneRepo.CountFixtures(ctx, scene.ID)
		items[i-start] = &generated.SceneSummary{
			ID:           scene.ID,
			Name:         scene.Name,
			Description:  scene.Description,
			FixtureCount: int(fixtureCount),
			CreatedAt:    scene.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
			UpdatedAt:    scene.UpdatedAt.Format("2006-01-02T15:04:05.000Z"),
		}
	}

	return &generated.ScenePage{
		Scenes: items,
		Pagination: generated.PaginationInfo{
			Total:   total,
			Page:    pageNum,
			PerPage: pageSize,
			HasMore: end < total,
		},
	}, nil
}

// Scene is the resolver for the scene field.
func (r *queryResolver) Scene(ctx context.Context, id string, includeFixtureValues *bool) (*models.Scene, error) {
	return r.SceneRepo.FindByID(ctx, id)
}

// SceneFixtures is the resolver for the sceneFixtures field.
func (r *queryResolver) SceneFixtures(ctx context.Context, sceneID string) ([]*generated.SceneFixtureSummary, error) {
	// Get fixture values for the scene
	var fixtureValues []models.FixtureValue
	result := r.db.Where("scene_id = ?", sceneID).Find(&fixtureValues)
	if result.Error != nil {
		return nil, result.Error
	}

	summaries := make([]*generated.SceneFixtureSummary, 0, len(fixtureValues))
	for _, fv := range fixtureValues {
		fixture, err := r.FixtureRepo.FindByID(ctx, fv.FixtureID)
		if err != nil || fixture == nil {
			continue
		}

		fixtureType := generated.FixtureTypeOther
		if fixture.Type != nil {
			fixtureType = generated.FixtureType(*fixture.Type)
		}

		summaries = append(summaries, &generated.SceneFixtureSummary{
			FixtureID:   fixture.ID,
			FixtureName: fixture.Name,
			FixtureType: fixtureType,
		})
	}

	return summaries, nil
}

// SearchScenes is the resolver for the searchScenes field.
func (r *queryResolver) SearchScenes(ctx context.Context, projectID string, query string, filter *generated.SceneFilterInput, page *int, perPage *int) (*generated.ScenePage, error) {
	scenes, err := r.SceneRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	// Filter by search query (name, description)
	var filtered []models.Scene
	queryLower := strings.ToLower(query)
	for _, s := range scenes {
		if strings.Contains(strings.ToLower(s.Name), queryLower) {
			filtered = append(filtered, s)
			continue
		}
		if s.Description != nil && strings.Contains(strings.ToLower(*s.Description), queryLower) {
			filtered = append(filtered, s)
			continue
		}
	}

	// Apply pagination
	pageNum := 1
	pageSize := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		pageSize = *perPage
	}

	total := len(filtered)
	start := (pageNum - 1) * pageSize
	end := start + pageSize
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	items := make([]*generated.SceneSummary, end-start)
	for i := start; i < end; i++ {
		scene := &filtered[i]
		fixtureCount, _ := r.SceneRepo.CountFixtures(ctx, scene.ID)
		items[i-start] = &generated.SceneSummary{
			ID:           scene.ID,
			Name:         scene.Name,
			Description:  scene.Description,
			FixtureCount: int(fixtureCount),
			CreatedAt:    scene.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
			UpdatedAt:    scene.UpdatedAt.Format("2006-01-02T15:04:05.000Z"),
		}
	}

	return &generated.ScenePage{
		Scenes: items,
		Pagination: generated.PaginationInfo{
			Total:   total,
			Page:    pageNum,
			PerPage: pageSize,
			HasMore: end < total,
		},
	}, nil
}

// SceneBoards is the resolver for the sceneBoards field.
func (r *queryResolver) SceneBoards(ctx context.Context, projectID string) ([]*models.SceneBoard, error) {
	var boards []models.SceneBoard
	result := r.db.Where("project_id = ?", projectID).Order("created_at DESC").Find(&boards)
	if result.Error != nil {
		return nil, result.Error
	}
	// Convert to pointers
	pointers := make([]*models.SceneBoard, len(boards))
	for i := range boards {
		pointers[i] = &boards[i]
	}
	return pointers, nil
}

// SceneBoard is the resolver for the sceneBoard field.
func (r *queryResolver) SceneBoard(ctx context.Context, id string) (*models.SceneBoard, error) {
	var board models.SceneBoard
	result := r.db.Preload("Buttons").First(&board, "id = ?", id)
	if result.Error != nil {
		return nil, result.Error
	}
	return &board, nil
}

// SceneBoardButton is the resolver for the sceneBoardButton field.
func (r *queryResolver) SceneBoardButton(ctx context.Context, id string) (*models.SceneBoardButton, error) {
	var button models.SceneBoardButton
	result := r.db.First(&button, "id = ?", id)
	if result.Error != nil {
		return nil, result.Error
	}
	return &button, nil
}

// FixtureUsage is the resolver for the fixtureUsage field.
func (r *queryResolver) FixtureUsage(ctx context.Context, fixtureID string) (*generated.FixtureUsage, error) {
	// Get fixture
	fixture, err := r.FixtureRepo.FindByID(ctx, fixtureID)
	if err != nil {
		return nil, err
	}
	if fixture == nil {
		return nil, fmt.Errorf("fixture not found: %s", fixtureID)
	}

	// Find scenes that use this fixture
	var fixtureValues []models.FixtureValue
	r.db.Where("fixture_id = ?", fixtureID).Find(&fixtureValues)

	sceneIDs := make([]string, 0, len(fixtureValues))
	for _, fv := range fixtureValues {
		sceneIDs = append(sceneIDs, fv.SceneID)
	}

	// Get unique scenes and convert to SceneSummary
	var scenes []models.Scene
	if len(sceneIDs) > 0 {
		r.db.Where("id IN ?", sceneIDs).Find(&scenes)
	}

	sceneSummaries := make([]*generated.SceneSummary, len(scenes))
	for i, scene := range scenes {
		fixtureCount, _ := r.SceneRepo.CountFixtures(ctx, scene.ID)
		sceneSummaries[i] = &generated.SceneSummary{
			ID:           scene.ID,
			Name:         scene.Name,
			Description:  scene.Description,
			FixtureCount: int(fixtureCount),
			CreatedAt:    scene.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
			UpdatedAt:    scene.UpdatedAt.Format("2006-01-02T15:04:05.000Z"),
		}
	}

	// Find cues that use this fixture (through scenes)
	var cueUsageSummaries []*generated.CueUsageSummary
	if len(sceneIDs) > 0 {
		var cues []models.Cue
		r.db.Where("scene_id IN ?", sceneIDs).Find(&cues)
		for _, cue := range cues {
			cueList, _ := r.CueListRepo.FindByID(ctx, cue.CueListID)
			cueListName := ""
			if cueList != nil {
				cueListName = cueList.Name
			}
			cueUsageSummaries = append(cueUsageSummaries, &generated.CueUsageSummary{
				CueID:       cue.ID,
				CueNumber:   cue.CueNumber,
				CueName:     cue.Name,
				CueListID:   cue.CueListID,
				CueListName: cueListName,
			})
		}
	}

	return &generated.FixtureUsage{
		FixtureID:   fixture.ID,
		FixtureName: fixture.Name,
		Scenes:      sceneSummaries,
		Cues:        cueUsageSummaries,
	}, nil
}

// SceneUsage is the resolver for the sceneUsage field.
func (r *queryResolver) SceneUsage(ctx context.Context, sceneID string) (*generated.SceneUsage, error) {
	// Get scene
	scene, err := r.SceneRepo.FindByID(ctx, sceneID)
	if err != nil {
		return nil, err
	}
	if scene == nil {
		return nil, fmt.Errorf("scene not found: %s", sceneID)
	}

	// Find cues that use this scene
	var cues []models.Cue
	r.db.Where("scene_id = ?", sceneID).Find(&cues)

	// Convert to CueUsageSummary
	cueUsageSummaries := make([]*generated.CueUsageSummary, 0, len(cues))
	for _, cue := range cues {
		cueList, _ := r.CueListRepo.FindByID(ctx, cue.CueListID)
		cueListName := ""
		if cueList != nil {
			cueListName = cueList.Name
		}
		cueUsageSummaries = append(cueUsageSummaries, &generated.CueUsageSummary{
			CueID:       cue.ID,
			CueNumber:   cue.CueNumber,
			CueName:     cue.Name,
			CueListID:   cue.CueListID,
			CueListName: cueListName,
		})
	}

	return &generated.SceneUsage{
		SceneID:   scene.ID,
		SceneName: scene.Name,
		Cues:      cueUsageSummaries,
	}, nil
}

// CompareScenes is the resolver for the compareScenes field.
func (r *queryResolver) CompareScenes(ctx context.Context, sceneID1 string, sceneID2 string) (*generated.SceneComparison, error) {
	// Get scenes
	scene1, err := r.SceneRepo.FindByID(ctx, sceneID1)
	if err != nil {
		return nil, err
	}
	scene2, err := r.SceneRepo.FindByID(ctx, sceneID2)
	if err != nil {
		return nil, err
	}

	// Get fixture values for each scene
	var values1, values2 []models.FixtureValue
	r.db.Where("scene_id = ?", sceneID1).Find(&values1)
	r.db.Where("scene_id = ?", sceneID2).Find(&values2)

	// Build maps for comparison
	fixtures1 := make(map[string]models.FixtureValue)
	fixtures2 := make(map[string]models.FixtureValue)

	for _, fv := range values1 {
		fixtures1[fv.FixtureID] = fv
	}
	for _, fv := range values2 {
		fixtures2[fv.FixtureID] = fv
	}

	// Find differences
	var differences []*generated.SceneDifference
	identicalCount := 0
	differentCount := 0

	for fixtureID, fv1 := range fixtures1 {
		fixture, _ := r.FixtureRepo.FindByID(ctx, fixtureID)
		fixtureName := ""
		if fixture != nil {
			fixtureName = fixture.Name
		}

		if fv2, ok := fixtures2[fixtureID]; ok {
			// Fixture in both scenes
			if fv1.ChannelValues != fv2.ChannelValues {
				var vals1, vals2 []int
				_ = json.Unmarshal([]byte(fv1.ChannelValues), &vals1)
				_ = json.Unmarshal([]byte(fv2.ChannelValues), &vals2)
				differences = append(differences, &generated.SceneDifference{
					FixtureID:      fixtureID,
					FixtureName:    fixtureName,
					DifferenceType: generated.DifferenceTypeValuesChanged,
					Scene1Values:   vals1,
					Scene2Values:   vals2,
				})
				differentCount++
			} else {
				identicalCount++
			}
		} else {
			// Fixture only in scene1
			var vals1 []int
			_ = json.Unmarshal([]byte(fv1.ChannelValues), &vals1)
			differences = append(differences, &generated.SceneDifference{
				FixtureID:      fixtureID,
				FixtureName:    fixtureName,
				DifferenceType: generated.DifferenceTypeOnlyInScene1,
				Scene1Values:   vals1,
			})
			differentCount++
		}
	}

	for fixtureID, fv2 := range fixtures2 {
		if _, ok := fixtures1[fixtureID]; !ok {
			// Fixture only in scene2
			fixture, _ := r.FixtureRepo.FindByID(ctx, fixtureID)
			fixtureName := ""
			if fixture != nil {
				fixtureName = fixture.Name
			}
			var vals2 []int
			_ = json.Unmarshal([]byte(fv2.ChannelValues), &vals2)
			differences = append(differences, &generated.SceneDifference{
				FixtureID:      fixtureID,
				FixtureName:    fixtureName,
				DifferenceType: generated.DifferenceTypeOnlyInScene2,
				Scene2Values:   vals2,
			})
			differentCount++
		}
	}

	// Convert scenes to SceneSummary
	fixtureCount1, _ := r.SceneRepo.CountFixtures(ctx, scene1.ID)
	fixtureCount2, _ := r.SceneRepo.CountFixtures(ctx, scene2.ID)

	scene1Summary := generated.SceneSummary{
		ID:           scene1.ID,
		Name:         scene1.Name,
		Description:  scene1.Description,
		FixtureCount: int(fixtureCount1),
		CreatedAt:    scene1.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
		UpdatedAt:    scene1.UpdatedAt.Format("2006-01-02T15:04:05.000Z"),
	}

	scene2Summary := generated.SceneSummary{
		ID:           scene2.ID,
		Name:         scene2.Name,
		Description:  scene2.Description,
		FixtureCount: int(fixtureCount2),
		CreatedAt:    scene2.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
		UpdatedAt:    scene2.UpdatedAt.Format("2006-01-02T15:04:05.000Z"),
	}

	return &generated.SceneComparison{
		Scene1:                scene1Summary,
		Scene2:                scene2Summary,
		Differences:           differences,
		IdenticalFixtureCount: identicalCount,
		DifferentFixtureCount: differentCount,
	}, nil
}

// CueLists is the resolver for the cueLists field.
func (r *queryResolver) CueLists(ctx context.Context, projectID string) ([]*generated.CueListSummary, error) {
	cueLists, err := r.CueListRepo.FindByProjectID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	result := make([]*generated.CueListSummary, len(cueLists))
	for i, cl := range cueLists {
		cueCount, _ := r.CueListRepo.CountCues(ctx, cl.ID)
		// Calculate total duration
		cues, _ := r.CueListRepo.GetCues(ctx, cl.ID)
		var totalDuration float64
		for _, cue := range cues {
			totalDuration += cue.FadeInTime + cue.FadeOutTime
			if cue.FollowTime != nil {
				totalDuration += *cue.FollowTime
			}
		}
		result[i] = &generated.CueListSummary{
			ID:            cl.ID,
			Name:          cl.Name,
			Description:   cl.Description,
			CueCount:      int(cueCount),
			TotalDuration: totalDuration,
			Loop:          cl.Loop,
			CreatedAt:     cl.CreatedAt.Format("2006-01-02T15:04:05.000Z"),
		}
	}
	return result, nil
}

// CueList is the resolver for the cueList field.
func (r *queryResolver) CueList(ctx context.Context, id string, page *int, perPage *int, includeSceneDetails *bool) (*models.CueList, error) {
	return r.CueListRepo.FindByID(ctx, id)
}

// CueListPlaybackStatus is the resolver for the cueListPlaybackStatus field.
func (r *queryResolver) CueListPlaybackStatus(ctx context.Context, cueListID string) (*generated.CueListPlaybackStatus, error) {
	// Get the current playback status from the PlaybackService
	status := r.PlaybackService.GetFormattedStatus(cueListID)

	// Convert playback service status to generated GraphQL type
	fadeProgress := status.FadeProgress
	gqlStatus := &generated.CueListPlaybackStatus{
		CueListID:       status.CueListID,
		CurrentCueIndex: status.CurrentCueIndex,
		IsPlaying:       status.IsPlaying,
		IsFading:        status.IsFading,
		FadeProgress:    &fadeProgress,
		LastUpdated:     status.LastUpdated,
	}

	// Convert current cue if present
	if status.CurrentCue != nil {
		gqlStatus.CurrentCue = &models.Cue{
			ID:          status.CurrentCue.ID,
			Name:        status.CurrentCue.Name,
			CueNumber:   status.CurrentCue.CueNumber,
			FadeInTime:  status.CurrentCue.FadeInTime,
			FadeOutTime: status.CurrentCue.FadeOutTime,
			FollowTime:  status.CurrentCue.FollowTime,
		}
	}

	return gqlStatus, nil
}

// Cue is the resolver for the cue field.
func (r *queryResolver) Cue(ctx context.Context, id string) (*models.Cue, error) {
	return r.CueRepo.FindByID(ctx, id)
}

// SearchCues is the resolver for the searchCues field.
func (r *queryResolver) SearchCues(ctx context.Context, cueListID string, query string, page *int, perPage *int) (*generated.CuePage, error) {
	cues, err := r.CueListRepo.GetCues(ctx, cueListID)
	if err != nil {
		return nil, err
	}

	// Filter by search query (name, notes)
	var filtered []models.Cue
	queryLower := strings.ToLower(query)
	for _, c := range cues {
		if strings.Contains(strings.ToLower(c.Name), queryLower) {
			filtered = append(filtered, c)
			continue
		}
		if c.Notes != nil && strings.Contains(strings.ToLower(*c.Notes), queryLower) {
			filtered = append(filtered, c)
			continue
		}
	}

	// Apply pagination
	pageNum := 1
	pageSize := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		pageSize = *perPage
	}

	total := len(filtered)
	start := (pageNum - 1) * pageSize
	end := start + pageSize
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	items := make([]*models.Cue, end-start)
	for i := start; i < end; i++ {
		items[i-start] = &filtered[i]
	}

	return &generated.CuePage{
		Cues: items,
		Pagination: generated.PaginationInfo{
			Total:   total,
			Page:    pageNum,
			PerPage: pageSize,
			HasMore: end < total,
		},
	}, nil
}

// DmxOutput is the resolver for the dmxOutput field.
func (r *queryResolver) DmxOutput(ctx context.Context, universe int) ([]int, error) {
	// DMX service expects 1-indexed universe
	return r.DMXService.GetUniverse(universe), nil
}

// AllDmxOutput is the resolver for the allDmxOutput field.
func (r *queryResolver) AllDmxOutput(ctx context.Context) ([]*generated.UniverseOutput, error) {
	allUniverses := r.DMXService.GetAllUniverses()
	result := make([]*generated.UniverseOutput, 0, len(allUniverses))
	for universe, channels := range allUniverses {
		result = append(result, &generated.UniverseOutput{
			Universe: universe,
			Channels: channels,
		})
	}
	return result, nil
}

// PreviewSession is the resolver for the previewSession field.
func (r *queryResolver) PreviewSession(ctx context.Context, sessionID string) (*models.PreviewSession, error) {
	var session models.PreviewSession
	result := r.db.First(&session, "id = ?", sessionID)
	if result.Error != nil {
		return nil, result.Error
	}
	return &session, nil
}

// CurrentActiveScene is the resolver for the currentActiveScene field.
func (r *queryResolver) CurrentActiveScene(ctx context.Context) (*models.Scene, error) {
	// TODO: Implement tracking of currently active scene
	// For now, return nil (no active scene)
	return nil, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context) ([]*models.Setting, error) {
	settings, err := r.SettingRepo.FindAll(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*models.Setting, len(settings))
	for i := range settings {
		result[i] = &settings[i]
	}
	return result, nil
}

// Setting is the resolver for the setting field.
func (r *queryResolver) Setting(ctx context.Context, key string) (*models.Setting, error) {
	return r.SettingRepo.FindByKey(ctx, key)
}

// SystemInfo is the resolver for the systemInfo field.
func (r *queryResolver) SystemInfo(ctx context.Context) (*generated.SystemInfo, error) {
	return &generated.SystemInfo{
		ArtnetEnabled:          r.DMXService.IsEnabled(),
		ArtnetBroadcastAddress: r.DMXService.GetBroadcastAddress(),
	}, nil
}

// NetworkInterfaceOptions is the resolver for the networkInterfaceOptions field.
// Returns available network interfaces for Art-Net broadcast selection
func (r *queryResolver) NetworkInterfaceOptions(ctx context.Context) ([]*generated.NetworkInterfaceOption, error) {
	interfaces, err := network.GetNetworkInterfaces()
	if err != nil {
		return nil, err
	}

	options := make([]*generated.NetworkInterfaceOption, len(interfaces))
	for i, iface := range interfaces {
		options[i] = &generated.NetworkInterfaceOption{
			Name:          iface.Name,
			Address:       iface.Address,
			Broadcast:     iface.Broadcast,
			Description:   iface.Description,
			InterfaceType: iface.InterfaceType,
		}
	}

	return options, nil
}

// WifiNetworks is the resolver for the wifiNetworks field.
// Returns empty list - WiFi not available on this platform
func (r *queryResolver) WifiNetworks(ctx context.Context, rescan *bool, deduplicate *bool) ([]*generated.WiFiNetwork, error) {
	return []*generated.WiFiNetwork{}, nil
}

// WifiStatus is the resolver for the wifiStatus field.
// Returns status indicating WiFi is not available on this platform
func (r *queryResolver) WifiStatus(ctx context.Context) (*generated.WiFiStatus, error) {
	return &generated.WiFiStatus{
		Available: false,
		Enabled:   false,
		Connected: false,
	}, nil
}

// SavedWifiNetworks is the resolver for the savedWifiNetworks field.
// Returns empty list - WiFi not available on this platform
func (r *queryResolver) SavedWifiNetworks(ctx context.Context) ([]*generated.WiFiNetwork, error) {
	return []*generated.WiFiNetwork{}, nil
}

// GetQLCFixtureMappingSuggestions is the resolver for the getQLCFixtureMappingSuggestions field.
// Returns empty result - QLC+ integration not available
func (r *queryResolver) GetQLCFixtureMappingSuggestions(ctx context.Context, projectID string) (*generated.QLCFixtureMappingResult, error) {
	return &generated.QLCFixtureMappingResult{
		ProjectID:          projectID,
		LacyLightsFixtures: []*generated.LacyLightsFixture{},
		Suggestions:        []*generated.FixtureMappingSuggestion{},
		DefaultMappings:    []*generated.FixtureMapping{},
	}, nil
}

// SystemVersions is the resolver for the systemVersions field.
// Returns version information for all LacyLights components
func (r *queryResolver) SystemVersions(ctx context.Context) (*generated.SystemVersionInfo, error) {
	info, err := r.VersionService.GetSystemVersions()
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL types
	var repos []*generated.RepositoryVersion
	for _, repo := range info.Repositories {
		repos = append(repos, &generated.RepositoryVersion{
			Repository:      repo.Repository,
			Installed:       repo.Installed,
			Latest:          repo.Latest,
			UpdateAvailable: repo.UpdateAvailable,
		})
	}

	return &generated.SystemVersionInfo{
		Repositories:               repos,
		LastChecked:                info.LastChecked,
		VersionManagementSupported: info.VersionManagementSupported,
	}, nil
}

// AvailableVersions is the resolver for the availableVersions field.
// Returns available versions for a specific repository
func (r *queryResolver) AvailableVersions(ctx context.Context, repository string) ([]string, error) {
	return r.VersionService.GetAvailableVersions(repository)
}

// OflImportStatus is the resolver for the oflImportStatus field.
func (r *queryResolver) OflImportStatus(ctx context.Context) (*generated.OFLImportStatus, error) {
	status := r.OFLManager.GetStatus()

	var startedAt, completedAt *string
	if status.StartedAt != nil {
		s := status.StartedAt.Format("2006-01-02T15:04:05Z07:00")
		startedAt = &s
	}
	if status.CompletedAt != nil {
		s := status.CompletedAt.Format("2006-01-02T15:04:05Z07:00")
		completedAt = &s
	}

	var errorMessage *string
	if status.ErrorMessage != "" {
		errorMessage = &status.ErrorMessage
	}

	var currentFixture, currentManufacturer *string
	if status.CurrentFixture != "" {
		currentFixture = &status.CurrentFixture
	}
	if status.CurrentManufacturer != "" {
		currentManufacturer = &status.CurrentManufacturer
	}

	var oflVersion *string
	if status.OFLVersion != "" {
		oflVersion = &status.OFLVersion
	}

	return &generated.OFLImportStatus{
		IsImporting:               status.IsImporting,
		Phase:                     generated.OFLImportPhase(status.Phase),
		TotalFixtures:             status.TotalFixtures,
		ImportedCount:             status.ImportedCount,
		FailedCount:               status.FailedCount,
		SkippedCount:              status.SkippedCount,
		PercentComplete:           status.PercentComplete,
		CurrentFixture:            currentFixture,
		CurrentManufacturer:       currentManufacturer,
		EstimatedSecondsRemaining: status.EstimatedSecondsRemaining,
		ErrorMessage:              errorMessage,
		StartedAt:                 startedAt,
		CompletedAt:               completedAt,
		OflVersion:                oflVersion,
		UsingBundledData:          status.UsingBundledData,
	}, nil
}

// CheckOFLUpdates is the resolver for the checkOFLUpdates field.
func (r *queryResolver) CheckOFLUpdates(ctx context.Context) (*generated.OFLUpdateCheckResult, error) {
	result, err := r.OFLManager.CheckForUpdates(ctx)
	if err != nil {
		return nil, err
	}

	// Convert fixture updates to GraphQL type
	var updates []*generated.OFLFixtureUpdate
	for _, u := range result.FixtureUpdates {
		update := &generated.OFLFixtureUpdate{
			FixtureKey:    u.FixtureKey,
			Manufacturer:  u.Manufacturer,
			Model:         u.Model,
			ChangeType:    generated.OFLFixtureChangeType(u.ChangeType),
			IsInUse:       u.IsInUse,
			InstanceCount: u.InstanceCount,
			CurrentHash:   u.CurrentHash,
			NewHash:       u.NewHash,
		}
		updates = append(updates, update)
	}

	return &generated.OFLUpdateCheckResult{
		CurrentFixtureCount: result.CurrentFixtureCount,
		OflFixtureCount:     result.OFLFixtureCount,
		NewFixtureCount:     result.NewFixtureCount,
		ChangedFixtureCount: result.ChangedFixtureCount,
		ChangedInUseCount:   result.ChangedInUseCount,
		FixtureUpdates:      updates,
		OflVersion:          result.OFLVersion,
		CheckedAt:           result.CheckedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// FixturesByIds is the resolver for the fixturesByIds field.
func (r *queryResolver) FixturesByIds(ctx context.Context, ids []string) ([]*models.FixtureInstance, error) {
	var fixtures []*models.FixtureInstance

	for _, id := range ids {
		fixture, err := r.FixtureRepo.FindByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if fixture != nil {
			fixtures = append(fixtures, fixture)
		}
	}

	return fixtures, nil
}

// ScenesByIds is the resolver for the scenesByIds field.
func (r *queryResolver) ScenesByIds(ctx context.Context, ids []string) ([]*models.Scene, error) {
	var scenes []*models.Scene

	for _, id := range ids {
		scene, err := r.SceneRepo.FindByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if scene != nil {
			scenes = append(scenes, scene)
		}
	}

	return scenes, nil
}

// CuesByIds is the resolver for the cuesByIds field.
func (r *queryResolver) CuesByIds(ctx context.Context, ids []string) ([]*models.Cue, error) {
	var cues []*models.Cue

	for _, id := range ids {
		cue, err := r.CueRepo.FindByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if cue != nil {
			cues = append(cues, cue)
		}
	}

	return cues, nil
}

// CueListsByIds is the resolver for the cueListsByIds field.
func (r *queryResolver) CueListsByIds(ctx context.Context, ids []string) ([]*models.CueList, error) {
	var cueLists []*models.CueList

	for _, id := range ids {
		cueList, err := r.CueListRepo.FindByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if cueList != nil {
			cueLists = append(cueLists, cueList)
		}
	}

	return cueLists, nil
}

// SceneBoardsByIds is the resolver for the sceneBoardsByIds field.
func (r *queryResolver) SceneBoardsByIds(ctx context.Context, ids []string) ([]*models.SceneBoard, error) {
	var sceneBoards []*models.SceneBoard

	for _, id := range ids {
		var board models.SceneBoard
		result := r.db.WithContext(ctx).First(&board, "id = ?", id)
		if result.Error == nil {
			sceneBoards = append(sceneBoards, &board)
		}
	}

	return sceneBoards, nil
}

// FixtureDefinitionsByIds is the resolver for the fixtureDefinitionsByIds field.
func (r *queryResolver) FixtureDefinitionsByIds(ctx context.Context, ids []string) ([]*models.FixtureDefinition, error) {
	var definitions []*models.FixtureDefinition

	for _, id := range ids {
		definition, err := r.FixtureRepo.FindDefinitionByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if definition != nil {
			definitions = append(definitions, definition)
		}
	}

	return definitions, nil
}

// ProjectsByIds is the resolver for the projectsByIds field.
func (r *queryResolver) ProjectsByIds(ctx context.Context, ids []string) ([]*models.Project, error) {
	var projects []*models.Project

	for _, id := range ids {
		project, err := r.ProjectRepo.FindByID(ctx, id)
		if err != nil {
			return nil, err
		}
		if project != nil {
			projects = append(projects, project)
		}
	}

	return projects, nil
}

// Project is the resolver for the project field.
func (r *sceneResolver) Project(ctx context.Context, obj *models.Scene) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// FixtureValues is the resolver for the fixtureValues field.
func (r *sceneResolver) FixtureValues(ctx context.Context, obj *models.Scene) ([]*models.FixtureValue, error) {
	values, err := r.SceneRepo.GetFixtureValues(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	pointers := make([]*models.FixtureValue, len(values))
	for i := range values {
		pointers[i] = &values[i]
	}
	return pointers, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *sceneResolver) CreatedAt(ctx context.Context, obj *models.Scene) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *sceneResolver) UpdatedAt(ctx context.Context, obj *models.Scene) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// Project is the resolver for the project field.
func (r *sceneBoardResolver) Project(ctx context.Context, obj *models.SceneBoard) (*models.Project, error) {
	return r.ProjectRepo.FindByID(ctx, obj.ProjectID)
}

// Buttons is the resolver for the buttons field.
func (r *sceneBoardResolver) Buttons(ctx context.Context, obj *models.SceneBoard) ([]*models.SceneBoardButton, error) {
	var buttons []models.SceneBoardButton
	result := r.db.WithContext(ctx).Where("scene_board_id = ?", obj.ID).Find(&buttons)
	if result.Error != nil {
		return nil, result.Error
	}
	pointers := make([]*models.SceneBoardButton, len(buttons))
	for i := range buttons {
		pointers[i] = &buttons[i]
	}
	return pointers, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *sceneBoardResolver) CreatedAt(ctx context.Context, obj *models.SceneBoard) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *sceneBoardResolver) UpdatedAt(ctx context.Context, obj *models.SceneBoard) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// SceneBoard is the resolver for the sceneBoard field.
func (r *sceneBoardButtonResolver) SceneBoard(ctx context.Context, obj *models.SceneBoardButton) (*models.SceneBoard, error) {
	var board models.SceneBoard
	result := r.db.First(&board, "id = ?", obj.SceneBoardID)
	if result.Error != nil {
		return nil, result.Error
	}
	return &board, nil
}

// Scene is the resolver for the scene field.
func (r *sceneBoardButtonResolver) Scene(ctx context.Context, obj *models.SceneBoardButton) (*models.Scene, error) {
	return r.SceneRepo.FindByID(ctx, obj.SceneID)
}

// CreatedAt is the resolver for the createdAt field.
func (r *sceneBoardButtonResolver) CreatedAt(ctx context.Context, obj *models.SceneBoardButton) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *sceneBoardButtonResolver) UpdatedAt(ctx context.Context, obj *models.SceneBoardButton) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *settingResolver) CreatedAt(ctx context.Context, obj *models.Setting) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *settingResolver) UpdatedAt(ctx context.Context, obj *models.Setting) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// DmxOutputChanged is the resolver for the dmxOutputChanged field.
func (r *subscriptionResolver) DmxOutputChanged(ctx context.Context, universe *int) (<-chan *generated.UniverseOutput, error) {
	// Create a filter string if universe is specified
	filter := ""
	if universe != nil {
		filter = fmt.Sprintf("%d", *universe)
	}

	// Subscribe to DMX output changes
	sub := r.PubSub.Subscribe(pubsub.TopicDMXOutput, filter, 10)

	// Create the output channel
	outputChan := make(chan *generated.UniverseOutput, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if output, valid := msg.(*generated.UniverseOutput); valid {
					select {
					case outputChan <- output:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// ProjectUpdated is the resolver for the projectUpdated field.
func (r *subscriptionResolver) ProjectUpdated(ctx context.Context, projectID string) (<-chan *models.Project, error) {
	// Subscribe to project updates filtered by projectID
	sub := r.PubSub.Subscribe(pubsub.TopicProjectUpdated, projectID, 10)

	// Create the output channel
	outputChan := make(chan *models.Project, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if project, valid := msg.(*models.Project); valid {
					select {
					case outputChan <- project:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// PreviewSessionUpdated is the resolver for the previewSessionUpdated field.
func (r *subscriptionResolver) PreviewSessionUpdated(ctx context.Context, projectID string) (<-chan *models.PreviewSession, error) {
	// Subscribe to preview session updates filtered by projectID
	sub := r.PubSub.Subscribe(pubsub.TopicPreviewSession, projectID, 10)

	// Create the output channel
	outputChan := make(chan *models.PreviewSession, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if session, valid := msg.(*models.PreviewSession); valid {
					select {
					case outputChan <- session:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// CueListPlaybackUpdated is the resolver for the cueListPlaybackUpdated field.
func (r *subscriptionResolver) CueListPlaybackUpdated(ctx context.Context, cueListID string) (<-chan *generated.CueListPlaybackStatus, error) {
	// Subscribe to cue list playback updates filtered by cueListID
	sub := r.PubSub.Subscribe(pubsub.TopicCueListPlayback, cueListID, 10)

	// Create the output channel
	outputChan := make(chan *generated.CueListPlaybackStatus, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if status, valid := msg.(*generated.CueListPlaybackStatus); valid {
					select {
					case outputChan <- status:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// SystemInfoUpdated is the resolver for the systemInfoUpdated field.
func (r *subscriptionResolver) SystemInfoUpdated(ctx context.Context) (<-chan *generated.SystemInfo, error) {
	// Subscribe to system info updates (no filter, receives all updates)
	sub := r.PubSub.Subscribe(pubsub.TopicSystemInfo, "", 10)

	// Create the output channel
	outputChan := make(chan *generated.SystemInfo, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if info, valid := msg.(*generated.SystemInfo); valid {
					select {
					case outputChan <- info:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// WifiStatusUpdated is the resolver for the wifiStatusUpdated field.
func (r *subscriptionResolver) WifiStatusUpdated(ctx context.Context) (<-chan *generated.WiFiStatus, error) {
	// Subscribe to WiFi status updates (no filter, receives all updates)
	sub := r.PubSub.Subscribe(pubsub.TopicWiFiStatus, "", 10)

	// Create the output channel
	outputChan := make(chan *generated.WiFiStatus, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if status, valid := msg.(*generated.WiFiStatus); valid {
					select {
					case outputChan <- status:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// OflImportProgress is the resolver for the oflImportProgress field.
func (r *subscriptionResolver) OflImportProgress(ctx context.Context) (<-chan *generated.OFLImportStatus, error) {
	// Subscribe to OFL import progress updates (no filter, receives all updates)
	sub := r.PubSub.Subscribe(pubsub.TopicOFLImportProgress, "", 10)

	// Create the output channel
	outputChan := make(chan *generated.OFLImportStatus, 10)

	// Start a goroutine to forward messages
	go func() {
		defer close(outputChan)
		for {
			select {
			case <-ctx.Done():
				r.PubSub.Unsubscribe(sub)
				return
			case msg, ok := <-sub.Channel:
				if !ok {
					return
				}
				if status, valid := msg.(*ofl.ProgressStatus); valid {
					// Convert to GraphQL type
					var startedAt, completedAt *string
					if status.StartedAt != nil {
						s := status.StartedAt.Format("2006-01-02T15:04:05Z07:00")
						startedAt = &s
					}
					if status.CompletedAt != nil {
						s := status.CompletedAt.Format("2006-01-02T15:04:05Z07:00")
						completedAt = &s
					}

					var errorMessage *string
					if status.ErrorMessage != "" {
						errorMessage = &status.ErrorMessage
					}

					var currentFixture, currentManufacturer *string
					if status.CurrentFixture != "" {
						currentFixture = &status.CurrentFixture
					}
					if status.CurrentManufacturer != "" {
						currentManufacturer = &status.CurrentManufacturer
					}

					var oflVersion *string
					if status.OFLVersion != "" {
						oflVersion = &status.OFLVersion
					}

					gqlStatus := &generated.OFLImportStatus{
						IsImporting:               status.IsImporting,
						Phase:                     generated.OFLImportPhase(status.Phase),
						TotalFixtures:             status.TotalFixtures,
						ImportedCount:             status.ImportedCount,
						FailedCount:               status.FailedCount,
						SkippedCount:              status.SkippedCount,
						PercentComplete:           status.PercentComplete,
						CurrentFixture:            currentFixture,
						CurrentManufacturer:       currentManufacturer,
						EstimatedSecondsRemaining: status.EstimatedSecondsRemaining,
						ErrorMessage:              errorMessage,
						StartedAt:                 startedAt,
						CompletedAt:               completedAt,
						OflVersion:                oflVersion,
						UsingBundledData:          status.UsingBundledData,
					}

					select {
					case outputChan <- gqlStatus:
					case <-ctx.Done():
						r.PubSub.Unsubscribe(sub)
						return
					}
				}
			}
		}
	}()

	return outputChan, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *models.User) (generated.UserRole, error) {
	if obj.Role != "" {
		return generated.UserRole(obj.Role), nil
	}
	return generated.UserRoleUser, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *models.User) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05.000Z"), nil
}

// ChannelDefinition returns generated.ChannelDefinitionResolver implementation.
func (r *Resolver) ChannelDefinition() generated.ChannelDefinitionResolver {
	return &channelDefinitionResolver{r}
}

// Cue returns generated.CueResolver implementation.
func (r *Resolver) Cue() generated.CueResolver { return &cueResolver{r} }

// CueList returns generated.CueListResolver implementation.
func (r *Resolver) CueList() generated.CueListResolver { return &cueListResolver{r} }

// FixtureDefinition returns generated.FixtureDefinitionResolver implementation.
func (r *Resolver) FixtureDefinition() generated.FixtureDefinitionResolver {
	return &fixtureDefinitionResolver{r}
}

// FixtureInstance returns generated.FixtureInstanceResolver implementation.
func (r *Resolver) FixtureInstance() generated.FixtureInstanceResolver {
	return &fixtureInstanceResolver{r}
}

// FixtureMode returns generated.FixtureModeResolver implementation.
func (r *Resolver) FixtureMode() generated.FixtureModeResolver { return &fixtureModeResolver{r} }

// FixtureValue returns generated.FixtureValueResolver implementation.
func (r *Resolver) FixtureValue() generated.FixtureValueResolver { return &fixtureValueResolver{r} }

// InstanceChannel returns generated.InstanceChannelResolver implementation.
func (r *Resolver) InstanceChannel() generated.InstanceChannelResolver {
	return &instanceChannelResolver{r}
}

// ModeChannel returns generated.ModeChannelResolver implementation.
func (r *Resolver) ModeChannel() generated.ModeChannelResolver { return &modeChannelResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// PreviewSession returns generated.PreviewSessionResolver implementation.
func (r *Resolver) PreviewSession() generated.PreviewSessionResolver {
	return &previewSessionResolver{r}
}

// Project returns generated.ProjectResolver implementation.
func (r *Resolver) Project() generated.ProjectResolver { return &projectResolver{r} }

// ProjectUser returns generated.ProjectUserResolver implementation.
func (r *Resolver) ProjectUser() generated.ProjectUserResolver { return &projectUserResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Scene returns generated.SceneResolver implementation.
func (r *Resolver) Scene() generated.SceneResolver { return &sceneResolver{r} }

// SceneBoard returns generated.SceneBoardResolver implementation.
func (r *Resolver) SceneBoard() generated.SceneBoardResolver { return &sceneBoardResolver{r} }

// SceneBoardButton returns generated.SceneBoardButtonResolver implementation.
func (r *Resolver) SceneBoardButton() generated.SceneBoardButtonResolver {
	return &sceneBoardButtonResolver{r}
}

// Setting returns generated.SettingResolver implementation.
func (r *Resolver) Setting() generated.SettingResolver { return &settingResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type channelDefinitionResolver struct{ *Resolver }
type cueResolver struct{ *Resolver }
type cueListResolver struct{ *Resolver }
type fixtureDefinitionResolver struct{ *Resolver }
type fixtureInstanceResolver struct{ *Resolver }
type fixtureModeResolver struct{ *Resolver }
type fixtureValueResolver struct{ *Resolver }
type instanceChannelResolver struct{ *Resolver }
type modeChannelResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type previewSessionResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type projectUserResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sceneResolver struct{ *Resolver }
type sceneBoardResolver struct{ *Resolver }
type sceneBoardButtonResolver struct{ *Resolver }
type settingResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
