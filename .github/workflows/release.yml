name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      is_prerelease:
        description: 'Create prerelease (beta) version'
        required: true
        type: boolean
        default: false
      release_name:
        description: 'Release name (optional - leave blank for auto-generated)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    env:
      COMPONENT: go
      BETA_VERSION_PATTERN: '^([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$'
      BETA_SUFFIX_PATTERN: '-beta\.[0-9]+$'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run tests before release
        run: go test -v ./...
        env:
          ARTNET_ENABLED: 'false'

      - name: Get current version
        id: current_version
        run: |
          # Get current version from latest tag
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_TAG#v}
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          VERSION_BUMP="${{ inputs.version_bump }}"
          IS_PRERELEASE="${{ inputs.is_prerelease }}"

          echo "Current version: $CURRENT_VERSION"
          echo "Version bump: $VERSION_BUMP"
          echo "Is prerelease: $IS_PRERELEASE"

          # Detect if current version is a beta (semver format: X.Y.Z-beta.[N])
          if [[ "$CURRENT_VERSION" =~ $BETA_VERSION_PATTERN ]]; then
            IS_CURRENT_BETA=true
            BASE_VERSION="${BASH_REMATCH[1]}"
            BETA_NUMBER="${BASH_REMATCH[2]}"
            echo "Detected beta: base=$BASE_VERSION, beta=$BETA_NUMBER"
          else
            IS_CURRENT_BETA=false
            BASE_VERSION="$CURRENT_VERSION"
            echo "Detected stable: $BASE_VERSION"
          fi

          # Parse base version
          IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"

          # Decision logic (semver-compatible)
          if [ "$IS_PRERELEASE" = "true" ]; then
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Next Beta (increment beta, ignore version_bump)
              BETA_NUMBER=$((BETA_NUMBER + 1))
              NEW_VERSION="${BASE_VERSION}-beta.${BETA_NUMBER}"
              echo "Scenario: Beta -> Next Beta"
            else
              # Stable -> First Beta (apply version_bump, add -beta.1)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.1"
              echo "Scenario: Stable -> First Beta"
            fi
          else
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Stable (finalize by removing beta suffix)
              NEW_VERSION="$BASE_VERSION"
              echo "Scenario: Beta -> Stable Finalization"
            else
              # Stable -> Stable (normal version bump)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
              echo "Scenario: Stable -> Stable"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Detect prerelease status
        id: prerelease_check
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          if [[ "$VERSION" =~ $BETA_SUFFIX_PATTERN ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "Detected prerelease (beta) version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "Detected stable version"
          fi

      - name: Build binaries
        run: |
          set -e
          mkdir -p dist

          # Build for multiple platforms
          PLATFORMS=(
            "linux/amd64"
            "linux/arm64"
            "linux/arm"
            "darwin/amd64"
            "darwin/arm64"
          )

          for PLATFORM in "${PLATFORMS[@]}"; do
            GOOS="${PLATFORM%/*}"
            GOARCH="${PLATFORM#*/}"
            OUTPUT="dist/lacylights-${GOOS}-${GOARCH}"

            if [ "$GOARCH" = "arm" ]; then
              GOARM=7 GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            else
              GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            fi

            echo "Built $OUTPUT"
          done

      - name: Create archives
        run: |
          set -e
          cd dist
          for binary in lacylights-*; do
            # Create archive containing the binary
            tar -czf "${binary}.tar.gz" "$binary"
            echo "Created ${binary}.tar.gz"
          done
          # NOTE: We keep the raw binaries - they're needed for direct download by RPi

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          set -e
          cd dist

          # Calculate checksums for ALL files (archives AND raw binaries)
          # First checksums for archives
          echo "Archive checksums:" > checksums.txt
          for archive in *.tar.gz; do
            sha256sum "$archive" >> checksums.txt
          done

          # Then checksums for raw binaries
          echo "" >> checksums.txt
          echo "Binary checksums:" >> checksums.txt
          for binary in lacylights-*; do
            # Skip archives
            if [[ "$binary" == *.tar.gz ]]; then
              continue
            fi
            sha256sum "$binary" >> checksums.txt
          done

          cat checksums.txt

      - name: Calculate release metadata
        id: release_metadata
        run: |
          echo "release_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Build platforms metadata
        id: platforms
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Validate checksums file exists and is not empty
          if [ ! -f "dist/checksums.txt" ] || [ ! -s "dist/checksums.txt" ]; then
            echo "Error: checksums.txt is missing or empty"
            exit 1
          fi

          # Build platforms array with checksums
          PLATFORMS_JSON="[]"
          PLATFORMS_JSON_DYNAMODB="[]"

          # Process only tar.gz files for platform entries (to avoid duplicates)
          for archive in dist/*.tar.gz; do
            FILENAME=$(basename "$archive")

            # Get checksum for archive
            SHA256_ARCHIVE=$(grep " ${FILENAME}$" dist/checksums.txt | awk '{print $1}')

            if [ -z "$SHA256_ARCHIVE" ]; then
              echo "Error: No checksum found for $FILENAME"
              exit 1
            fi

            # Extract platform info from filename: lacylights-{os}-{arch}.tar.gz
            PLATFORM_INFO=$(echo "$FILENAME" | sed 's/lacylights-//' | sed 's/.tar.gz//')
            OS=$(echo "$PLATFORM_INFO" | cut -d- -f1)
            ARCH=$(echo "$PLATFORM_INFO" | cut -d- -f2)

            # Get corresponding raw binary name and checksum
            BINARY_NAME="lacylights-${OS}-${ARCH}"
            SHA256_BINARY=$(grep " ${BINARY_NAME}$" dist/checksums.txt | awk '{print $1}')

            # Use portable file size command
            ARCHIVE_SIZE=$(wc -c < "dist/$FILENAME" | tr -d ' ')
            BINARY_SIZE=$(wc -c < "dist/$BINARY_NAME" | tr -d ' ')

            # Build platform entry for S3 JSON files - WITH VERSIONED URLs
            PLATFORM_ENTRY=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg archiveUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg binaryUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${BINARY_NAME}" \
              --arg sha256Archive "$SHA256_ARCHIVE" \
              --arg sha256Binary "$SHA256_BINARY" \
              --argjson archiveSize "$ARCHIVE_SIZE" \
              --argjson binarySize "$BINARY_SIZE" \
              --arg url "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg sha256 "$SHA256_ARCHIVE" \
              --argjson fileSize "$ARCHIVE_SIZE" \
              '{
                os: $os,
                arch: $arch,
                archiveUrl: $archiveUrl,
                binaryUrl: $binaryUrl,
                sha256Archive: $sha256Archive,
                sha256Binary: $sha256Binary,
                archiveSize: $archiveSize,
                binarySize: $binarySize,
                url: $url,
                sha256: $sha256,
                fileSize: $fileSize
              }')

            PLATFORMS_JSON=$(echo "$PLATFORMS_JSON" | jq --argjson entry "$PLATFORM_ENTRY" '. += [$entry]')

            # Build platform entry for DynamoDB (with type annotations)
            PLATFORM_ENTRY_DYNAMODB=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg archiveUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${FILENAME}" \
              --arg binaryUrl "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/${BINARY_NAME}" \
              --arg sha256Archive "$SHA256_ARCHIVE" \
              --arg sha256Binary "$SHA256_BINARY" \
              --argjson archiveSize "$ARCHIVE_SIZE" \
              --argjson binarySize "$BINARY_SIZE" \
              '{
                M: {
                  os: {S: $os},
                  arch: {S: $arch},
                  archiveUrl: {S: $archiveUrl},
                  binaryUrl: {S: $binaryUrl},
                  sha256Archive: {S: $sha256Archive},
                  sha256Binary: {S: $sha256Binary},
                  archiveSize: {N: ($archiveSize | tostring)},
                  binarySize: {N: ($binarySize | tostring)}
                }
              }')

            PLATFORMS_JSON_DYNAMODB=$(echo "$PLATFORMS_JSON_DYNAMODB" | jq --argjson entry "$PLATFORM_ENTRY_DYNAMODB" '. += [$entry]')
          done

          # Save to file for use in subsequent steps (avoiding step output size limits)
          echo "$PLATFORMS_JSON" > platforms.json
          echo "$PLATFORMS_JSON_DYNAMODB" > platforms-dynamodb.json

          echo "platforms_file=platforms.json" >> $GITHUB_OUTPUT
          echo "platforms_dynamodb_file=platforms-dynamodb.json" >> $GITHUB_OUTPUT

          echo "Generated platforms.json:"
          cat platforms.json | jq .

      - name: Upload to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          S3_VERSION_PATH="s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/v${VERSION}"

          echo "Uploading to versioned directory: $S3_VERSION_PATH"

          # Upload archives
          echo "Uploading archives..."
          for archive in dist/*.tar.gz; do
            FILENAME=$(basename "$archive")
            aws s3 cp "$archive" \
              "${S3_VERSION_PATH}/${FILENAME}" \
              --content-type "application/gzip" \
              --cache-control "max-age=31536000, immutable"
            echo "  Uploaded archive: $FILENAME"
          done

          # Upload raw binaries
          echo "Uploading raw binaries..."
          for binary in dist/lacylights-*; do
            # Skip archives (only upload raw binaries)
            if [[ "$binary" == *.tar.gz ]]; then
              continue
            fi
            FILENAME=$(basename "$binary")
            aws s3 cp "$binary" \
              "${S3_VERSION_PATH}/${FILENAME}" \
              --content-type "application/octet-stream" \
              --cache-control "max-age=31536000, immutable"
            echo "  Uploaded binary: $FILENAME"
          done

          # Upload checksums.txt
          echo "Uploading checksums.txt..."
          aws s3 cp "dist/checksums.txt" \
            "${S3_VERSION_PATH}/checksums.txt" \
            --content-type "text/plain" \
            --cache-control "max-age=31536000, immutable"
          echo "  Uploaded checksums.txt"

          echo "All files uploaded to ${S3_VERSION_PATH}/"

      - name: Create version-specific metadata JSON
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Read platforms JSON from file
          PLATFORMS_JSON=$(cat platforms.json)

          # Create version-specific metadata JSON
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > "${VERSION}.json"

          echo "Uploading ${VERSION}.json..."
          aws s3 cp "${VERSION}.json" \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/${VERSION}.json" \
            --content-type "application/json" \
            --cache-control "max-age=31536000, immutable" \
            --metadata-directive REPLACE

          echo "${VERSION}.json uploaded"

      - name: Update latest.json
        if: ${{ steps.prerelease_check.outputs.is_prerelease == 'false' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Read platforms JSON from file
          PLATFORMS_JSON=$(cat platforms.json)

          # Create latest.json
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease false \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > latest.json

          echo "Uploading latest.json..."
          aws s3 cp latest.json \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/latest.json" \
            --content-type "application/json" \
            --cache-control "max-age=300, must-revalidate" \
            --metadata-directive REPLACE

          echo "latest.json updated"

      - name: Update DynamoDB
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"
          TABLE_NAME="${{ secrets.AWS_DIST_TABLE_NAME || 'lacylights-releases' }}"

          # Read platforms JSON from DynamoDB-formatted file
          PLATFORMS_JSON=$(cat platforms-dynamodb.json)

          echo "Updating DynamoDB..."

          # Create DynamoDB item
          jq -n \
            --arg tableName "$TABLE_NAME" \
            --arg component "${{ env.COMPONENT }}" \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --arg isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              TableName: $tableName,
              Item: {
                component: {S: $component},
                version: {S: $version},
                releaseDate: {S: $releaseDate},
                isPrerelease: {BOOL: ($isPrerelease == "true")},
                platforms: {L: $platforms}
              }
            }' > dynamodb-item.json

          aws dynamodb put-item --cli-input-json file://dynamodb-item.json

          echo "DynamoDB updated: component=${{ env.COMPONENT }}, version=$VERSION"

      - name: Create Git tag
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Check if tag exists, skip creation if it does (idempotent)
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists. Skipping creation."
          else
            git tag -a "v${VERSION}" -m "Release v${VERSION}"

            # Push with retry logic
            for i in 1 2 3; do
              if git push origin "v${VERSION}"; then
                echo "Successfully pushed tag"
                break
              fi
              echo "Push attempt $i failed, retrying..."
              sleep 5
            done
          fi

      - name: Determine release name
        id: release_name
        run: |
          if [ -z "${{ inputs.release_name }}" ]; then
            echo "name=v${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ inputs.release_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN }}
          script: |
            const tagName = 'v${{ steps.new_version.outputs.version }}';
            const fs = require('fs');
            const path = require('path');

            // Check if release already exists
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              core.info(`Release ${tagName} already exists. Skipping creation.`);
              return;
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            // Create the release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: '${{ steps.release_name.outputs.name }}',
              draft: false,
              prerelease: ${{ steps.prerelease_check.outputs.is_prerelease == 'true' }},
              generate_release_notes: true
            });

            // Upload assets (both archives and raw binaries)
            const distDir = 'dist';
            const files = fs.readdirSync(distDir).filter(f =>
              f.endsWith('.tar.gz') || (f.startsWith('lacylights-') && !f.includes('.'))
            );

            for (const file of files) {
              const filePath = path.join(distDir, file);
              const fileContent = fs.readFileSync(filePath);
              const contentType = file.endsWith('.tar.gz') ? 'application/gzip' : 'application/octet-stream';

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: file,
                data: fileContent,
                headers: {
                  'content-type': contentType
                }
              });

              core.info(`Uploaded ${file}`);
            }

      - name: Output summary
        run: |
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          VERSION="${{ steps.new_version.outputs.version }}"

          echo "## Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** v${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

          if [ "$IS_PRERELEASE" = "true" ]; then
            echo "**Type:** Prerelease (Beta)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Type:** Stable Release" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release Directory:** https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          cat platforms.json | jq -r '.[] | "- \(.os)/\(.arch): [Archive](\(.archiveUrl)) | [Binary](\(.binaryUrl))"' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Checksums:** [checksums.txt](https://dist.lacylights.com/releases/${{ env.COMPONENT }}/v${VERSION}/checksums.txt)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**API Endpoints:**" >> $GITHUB_STEP_SUMMARY
          if [ "$IS_PRERELEASE" = "false" ]; then
            echo "- Latest: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/latest.json" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version-specific: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/${VERSION}.json" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${VERSION})" >> $GITHUB_STEP_SUMMARY
