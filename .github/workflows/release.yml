name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      is_prerelease:
        description: 'Create prerelease (beta) version'
        required: true
        type: boolean
        default: false
      release_name:
        description: 'Release name (optional - leave blank for auto-generated)'
        required: false
        type: string

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    env:
      COMPONENT: go
      BETA_VERSION_PATTERN: '^([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$'
      BETA_SUFFIX_PATTERN: '-beta\.[0-9]+$'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run tests before release
        run: go test -v ./...
        env:
          ARTNET_ENABLED: 'false'

      - name: Get current version
        id: current_version
        run: |
          # Get current version from latest tag
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_TAG#v}
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          VERSION_BUMP="${{ inputs.version_bump }}"
          IS_PRERELEASE="${{ inputs.is_prerelease }}"

          echo "Current version: $CURRENT_VERSION"
          echo "Version bump: $VERSION_BUMP"
          echo "Is prerelease: $IS_PRERELEASE"

          # Detect if current version is a beta (semver format: X.Y.Z-beta.[N])
          if [[ "$CURRENT_VERSION" =~ $BETA_VERSION_PATTERN ]]; then
            IS_CURRENT_BETA=true
            BASE_VERSION="${BASH_REMATCH[1]}"
            BETA_NUMBER="${BASH_REMATCH[2]}"
            echo "Detected beta: base=$BASE_VERSION, beta=$BETA_NUMBER"
          else
            IS_CURRENT_BETA=false
            BASE_VERSION="$CURRENT_VERSION"
            echo "Detected stable: $BASE_VERSION"
          fi

          # Parse base version
          IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"

          # Decision logic (semver-compatible)
          if [ "$IS_PRERELEASE" = "true" ]; then
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Next Beta (increment beta, ignore version_bump)
              BETA_NUMBER=$((BETA_NUMBER + 1))
              NEW_VERSION="${BASE_VERSION}-beta.${BETA_NUMBER}"
              echo "Scenario: Beta -> Next Beta"
            else
              # Stable -> First Beta (apply version_bump, add -beta.1)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.1"
              echo "Scenario: Stable -> First Beta"
            fi
          else
            if [ "$IS_CURRENT_BETA" = "true" ]; then
              # Beta -> Stable (finalize by removing beta suffix)
              NEW_VERSION="$BASE_VERSION"
              echo "Scenario: Beta -> Stable Finalization"
            else
              # Stable -> Stable (normal version bump)
              case "$VERSION_BUMP" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
              echo "Scenario: Stable -> Stable"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Detect prerelease status
        id: prerelease_check
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          if [[ "$VERSION" =~ $BETA_SUFFIX_PATTERN ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "Detected prerelease (beta) version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "Detected stable version"
          fi

      - name: Build binaries
        run: |
          set -e
          mkdir -p dist

          # Build for multiple platforms
          PLATFORMS=(
            "linux/amd64"
            "linux/arm64"
            "linux/arm"
            "darwin/amd64"
            "darwin/arm64"
          )

          for PLATFORM in "${PLATFORMS[@]}"; do
            GOOS="${PLATFORM%/*}"
            GOARCH="${PLATFORM#*/}"
            OUTPUT="dist/lacylights-${GOOS}-${GOARCH}"

            if [ "$GOARCH" = "arm" ]; then
              GOARM=7 GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            else
              GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.Version=v${{ steps.new_version.outputs.version }}" -o "$OUTPUT" ./cmd/server
            fi

            echo "Built $OUTPUT"
          done

      - name: Create archives
        run: |
          cd dist
          for binary in lacylights-*; do
            tar -czf "${binary}.tar.gz" "$binary"
            rm "$binary"
          done

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          set -e
          cd dist

          # Calculate checksums for all archives
          for archive in *.tar.gz; do
            sha256sum "$archive" >> checksums.txt
          done

          cat checksums.txt
          echo "checksums_file=checksums.txt" >> $GITHUB_OUTPUT

      - name: Calculate release metadata
        id: release_metadata
        run: |
          echo "release_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Upload to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          echo "Uploading archives to S3..."
          for archive in dist/*.tar.gz; do
            FILENAME=$(basename "$archive")
            aws s3 cp "$archive" \
              "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/$FILENAME" \
              --content-type "application/gzip"
            echo "âœ“ Uploaded $FILENAME"
          done

      - name: Create version-specific metadata JSON
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Build platforms array with checksums
          PLATFORMS_JSON="[]"
          while IFS= read -r line; do
            SHA256=$(echo "$line" | awk '{print $1}')
            FILENAME=$(echo "$line" | awk '{print $2}')

            # Extract platform info from filename: lacylights-{os}-{arch}.tar.gz
            PLATFORM_INFO=$(echo "$FILENAME" | sed 's/lacylights-//' | sed 's/.tar.gz//')
            OS=$(echo "$PLATFORM_INFO" | cut -d- -f1)
            ARCH=$(echo "$PLATFORM_INFO" | cut -d- -f2)

            FILE_SIZE=$(stat -c%s "dist/$FILENAME")

            PLATFORM_ENTRY=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg url "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/$FILENAME" \
              --arg sha256 "$SHA256" \
              --argjson fileSize "$FILE_SIZE" \
              '{
                os: $os,
                arch: $arch,
                url: $url,
                sha256: $sha256,
                fileSize: $fileSize
              }')

            PLATFORMS_JSON=$(echo "$PLATFORMS_JSON" | jq --argjson entry "$PLATFORM_ENTRY" '. += [$entry]')
          done < dist/checksums.txt

          # Create version-specific metadata JSON
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > "${VERSION}.json"

          echo "Uploading ${VERSION}.json..."
          aws s3 cp "${VERSION}.json" \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/${VERSION}.json" \
            --content-type "application/json" \
            --cache-control "max-age=31536000, immutable" \
            --metadata-directive REPLACE

          echo "âœ“ ${VERSION}.json uploaded"

      - name: Update latest.json
        if: ${{ steps.prerelease_check.outputs.is_prerelease == 'false' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"

          # Build platforms array with checksums
          PLATFORMS_JSON="[]"
          while IFS= read -r line; do
            SHA256=$(echo "$line" | awk '{print $1}')
            FILENAME=$(echo "$line" | awk '{print $2}')

            # Extract platform info from filename
            PLATFORM_INFO=$(echo "$FILENAME" | sed 's/lacylights-//' | sed 's/.tar.gz//')
            OS=$(echo "$PLATFORM_INFO" | cut -d- -f1)
            ARCH=$(echo "$PLATFORM_INFO" | cut -d- -f2)

            FILE_SIZE=$(stat -c%s "dist/$FILENAME")

            PLATFORM_ENTRY=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg url "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/$FILENAME" \
              --arg sha256 "$SHA256" \
              --argjson fileSize "$FILE_SIZE" \
              '{
                os: $os,
                arch: $arch,
                url: $url,
                sha256: $sha256,
                fileSize: $fileSize
              }')

            PLATFORMS_JSON=$(echo "$PLATFORMS_JSON" | jq --argjson entry "$PLATFORM_ENTRY" '. += [$entry]')
          done < dist/checksums.txt

          # Create latest.json
          jq -n \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --argjson isPrerelease false \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              version: $version,
              releaseDate: $releaseDate,
              isPrerelease: $isPrerelease,
              platforms: $platforms
            }' > latest.json

          echo "Uploading latest.json..."
          aws s3 cp latest.json \
            "s3://${{ secrets.AWS_DIST_BUCKET }}/releases/${{ env.COMPONENT }}/latest.json" \
            --content-type "application/json" \
            --cache-control "max-age=300, must-revalidate" \
            --metadata-directive REPLACE

          echo "âœ“ latest.json updated"

      - name: Update DynamoDB
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_DIST_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_DIST_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_DIST_REGION }}
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"
          RELEASE_DATE="${{ steps.release_metadata.outputs.release_date }}"
          TABLE_NAME="${{ secrets.AWS_DIST_TABLE_NAME || 'lacylights-releases' }}"

          # Build platforms array with checksums
          PLATFORMS_JSON="[]"
          while IFS= read -r line; do
            SHA256=$(echo "$line" | awk '{print $1}')
            FILENAME=$(echo "$line" | awk '{print $2}')

            # Extract platform info from filename
            PLATFORM_INFO=$(echo "$FILENAME" | sed 's/lacylights-//' | sed 's/.tar.gz//')
            OS=$(echo "$PLATFORM_INFO" | cut -d- -f1)
            ARCH=$(echo "$PLATFORM_INFO" | cut -d- -f2)

            FILE_SIZE=$(stat -c%s "dist/$FILENAME")

            PLATFORM_ENTRY=$(jq -n \
              --arg os "$OS" \
              --arg arch "$ARCH" \
              --arg url "https://dist.lacylights.com/releases/${{ env.COMPONENT }}/$FILENAME" \
              --arg sha256 "$SHA256" \
              --argjson fileSize "$FILE_SIZE" \
              '{
                os: {S: $os},
                arch: {S: $arch},
                url: {S: $url},
                sha256: {S: $sha256},
                fileSize: {N: ($fileSize | tostring)}
              }')

            PLATFORMS_JSON=$(echo "$PLATFORMS_JSON" | jq --argjson entry "$PLATFORM_ENTRY" '. += [$entry]')
          done < dist/checksums.txt

          echo "Updating DynamoDB..."

          # Create DynamoDB item
          jq -n \
            --arg component "${{ env.COMPONENT }}" \
            --arg version "$VERSION" \
            --arg releaseDate "$RELEASE_DATE" \
            --arg isPrerelease "$IS_PRERELEASE" \
            --argjson platforms "$PLATFORMS_JSON" \
            '{
              TableName: env.TABLE_NAME,
              Item: {
                component: {S: $component},
                version: {S: $version},
                releaseDate: {S: $releaseDate},
                isPrerelease: {BOOL: ($isPrerelease == "true")},
                platforms: {L: $platforms}
              }
            }' | TABLE_NAME="$TABLE_NAME" jq '.TableName = env.TABLE_NAME' > dynamodb-item.json

          aws dynamodb put-item --cli-input-json file://dynamodb-item.json

          echo "âœ“ DynamoDB updated: component=${{ env.COMPONENT }}, version=$VERSION"

      - name: Create Git tag
        run: |
          set -e
          VERSION="${{ steps.new_version.outputs.version }}"

          # Check if tag exists, skip creation if it does (idempotent)
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists. Skipping creation."
          else
            git tag -a "v${VERSION}" -m "Release v${VERSION}"

            # Push with retry logic
            for i in 1 2 3; do
              if git push origin "v${VERSION}"; then
                echo "Successfully pushed tag"
                break
              fi
              echo "Push attempt $i failed, retrying..."
              sleep 5
            done
          fi

      - name: Determine release name
        id: release_name
        run: |
          if [ -z "${{ inputs.release_name }}" ]; then
            echo "name=v${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ inputs.release_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const tagName = 'v${{ steps.new_version.outputs.version }}';
            const fs = require('fs');
            const path = require('path');

            // Check if release already exists
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              core.info(`Release ${tagName} already exists. Skipping creation.`);
              return;
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            // Create the release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: '${{ steps.release_name.outputs.name }}',
              draft: false,
              prerelease: ${{ steps.prerelease_check.outputs.is_prerelease == 'true' }},
              generate_release_notes: true
            });

            // Upload assets
            const distDir = 'dist';
            const files = fs.readdirSync(distDir).filter(f => f.endsWith('.tar.gz'));

            for (const file of files) {
              const filePath = path.join(distDir, file);
              const fileContent = fs.readFileSync(filePath);

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: file,
                data: fileContent
              });

              core.info(`Uploaded ${file}`);
            }

      - name: Output summary
        run: |
          IS_PRERELEASE="${{ steps.prerelease_check.outputs.is_prerelease }}"

          echo "## Release Created Successfully! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ steps.new_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** v${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

          if [ "$IS_PRERELEASE" = "true" ]; then
            echo "**Type:** ðŸ§ª Prerelease (Beta)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Type:** âœ… Stable Release" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          for f in dist/*.tar.gz; do
            FILENAME=$(basename "$f")
            echo "- [$FILENAME](https://dist.lacylights.com/releases/${{ env.COMPONENT }}/$FILENAME)" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**API Endpoints:**" >> $GITHUB_STEP_SUMMARY
          echo "- Latest: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/latest.json" >> $GITHUB_STEP_SUMMARY
          echo "- Version-specific: https://dist.lacylights.com/releases/${{ env.COMPONENT }}/${{ steps.new_version.outputs.version }}.json" >> $GITHUB_STEP_SUMMARY
          echo "- Manifest: https://dist.lacylights.com/api/manifest" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new_version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
