// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/bbernstein/lacylights-go/internal/database/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ChannelDefinition() ChannelDefinitionResolver
	Cue() CueResolver
	CueList() CueListResolver
	FixtureDefinition() FixtureDefinitionResolver
	FixtureInstance() FixtureInstanceResolver
	FixtureMode() FixtureModeResolver
	FixtureValue() FixtureValueResolver
	InstanceChannel() InstanceChannelResolver
	ModeChannel() ModeChannelResolver
	Mutation() MutationResolver
	PreviewSession() PreviewSessionResolver
	Project() ProjectResolver
	ProjectUser() ProjectUserResolver
	Query() QueryResolver
	Scene() SceneResolver
	SceneBoard() SceneBoardResolver
	SceneBoardButton() SceneBoardButtonResolver
	Setting() SettingResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	BulkDeleteResult struct {
		DeletedCount func(childComplexity int) int
		DeletedIds   func(childComplexity int) int
	}

	ChannelAssignmentSuggestion struct {
		Assignments                func(childComplexity int) int
		AvailableChannelsRemaining func(childComplexity int) int
		TotalChannelsNeeded        func(childComplexity int) int
		Universe                   func(childComplexity int) int
	}

	ChannelDefinition struct {
		DefaultValue func(childComplexity int) int
		FadeBehavior func(childComplexity int) int
		ID           func(childComplexity int) int
		IsDiscrete   func(childComplexity int) int
		MaxValue     func(childComplexity int) int
		MinValue     func(childComplexity int) int
		Name         func(childComplexity int) int
		Offset       func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	ChannelMapFixture struct {
		ChannelCount func(childComplexity int) int
		EndChannel   func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		StartChannel func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	ChannelMapResult struct {
		ProjectID func(childComplexity int) int
		Universes func(childComplexity int) int
	}

	ChannelUsage struct {
		ChannelType func(childComplexity int) int
		FixtureID   func(childComplexity int) int
		FixtureName func(childComplexity int) int
	}

	ChannelValue struct {
		Offset func(childComplexity int) int
		Value  func(childComplexity int) int
	}

	Cue struct {
		CueList     func(childComplexity int) int
		CueNumber   func(childComplexity int) int
		EasingType  func(childComplexity int) int
		FadeInTime  func(childComplexity int) int
		FadeOutTime func(childComplexity int) int
		FollowTime  func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Notes       func(childComplexity int) int
		Scene       func(childComplexity int) int
	}

	CueList struct {
		CreatedAt     func(childComplexity int) int
		CueCount      func(childComplexity int) int
		Cues          func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		Loop          func(childComplexity int) int
		Name          func(childComplexity int) int
		Project       func(childComplexity int) int
		TotalDuration func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	CueListPlaybackStatus struct {
		CueListID       func(childComplexity int) int
		CurrentCue      func(childComplexity int) int
		CurrentCueIndex func(childComplexity int) int
		FadeProgress    func(childComplexity int) int
		IsFading        func(childComplexity int) int
		IsPlaying       func(childComplexity int) int
		LastUpdated     func(childComplexity int) int
		NextCue         func(childComplexity int) int
		PreviousCue     func(childComplexity int) int
	}

	CueListSummary struct {
		CreatedAt     func(childComplexity int) int
		CueCount      func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		Loop          func(childComplexity int) int
		Name          func(childComplexity int) int
		TotalDuration func(childComplexity int) int
	}

	CuePage struct {
		Cues       func(childComplexity int) int
		Pagination func(childComplexity int) int
	}

	CueUsageSummary struct {
		CueID       func(childComplexity int) int
		CueListID   func(childComplexity int) int
		CueListName func(childComplexity int) int
		CueName     func(childComplexity int) int
		CueNumber   func(childComplexity int) int
	}

	ExportResult struct {
		JSONContent func(childComplexity int) int
		ProjectID   func(childComplexity int) int
		ProjectName func(childComplexity int) int
		Stats       func(childComplexity int) int
	}

	ExportStats struct {
		CueListsCount           func(childComplexity int) int
		CuesCount               func(childComplexity int) int
		FixtureDefinitionsCount func(childComplexity int) int
		FixtureInstancesCount   func(childComplexity int) int
		ScenesCount             func(childComplexity int) int
	}

	FixtureChannelAssignment struct {
		ChannelCount func(childComplexity int) int
		ChannelRange func(childComplexity int) int
		EndChannel   func(childComplexity int) int
		FixtureName  func(childComplexity int) int
		Manufacturer func(childComplexity int) int
		Mode         func(childComplexity int) int
		Model        func(childComplexity int) int
		StartChannel func(childComplexity int) int
	}

	FixtureDefinition struct {
		Channels     func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IsBuiltIn    func(childComplexity int) int
		Manufacturer func(childComplexity int) int
		Model        func(childComplexity int) int
		Modes        func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	FixtureInstance struct {
		ChannelCount   func(childComplexity int) int
		Channels       func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		DefinitionID   func(childComplexity int) int
		Description    func(childComplexity int) int
		ID             func(childComplexity int) int
		LayoutRotation func(childComplexity int) int
		LayoutX        func(childComplexity int) int
		LayoutY        func(childComplexity int) int
		Manufacturer   func(childComplexity int) int
		ModeName       func(childComplexity int) int
		Model          func(childComplexity int) int
		Name           func(childComplexity int) int
		Project        func(childComplexity int) int
		ProjectOrder   func(childComplexity int) int
		StartChannel   func(childComplexity int) int
		Tags           func(childComplexity int) int
		Type           func(childComplexity int) int
		Universe       func(childComplexity int) int
	}

	FixtureInstancePage struct {
		Fixtures   func(childComplexity int) int
		Pagination func(childComplexity int) int
	}

	FixtureMapping struct {
		LacyLightsKey   func(childComplexity int) int
		QlcManufacturer func(childComplexity int) int
		QlcMode         func(childComplexity int) int
		QlcModel        func(childComplexity int) int
	}

	FixtureMappingSuggestion struct {
		Fixture     func(childComplexity int) int
		Suggestions func(childComplexity int) int
	}

	FixtureMode struct {
		ChannelCount func(childComplexity int) int
		Channels     func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		ShortName    func(childComplexity int) int
	}

	FixtureUsage struct {
		Cues        func(childComplexity int) int
		FixtureID   func(childComplexity int) int
		FixtureName func(childComplexity int) int
		Scenes      func(childComplexity int) int
	}

	FixtureValue struct {
		Channels   func(childComplexity int) int
		Fixture    func(childComplexity int) int
		ID         func(childComplexity int) int
		SceneOrder func(childComplexity int) int
	}

	ImportResult struct {
		ProjectID func(childComplexity int) int
		Stats     func(childComplexity int) int
		Warnings  func(childComplexity int) int
	}

	ImportStats struct {
		CueListsCreated           func(childComplexity int) int
		CuesCreated               func(childComplexity int) int
		FixtureDefinitionsCreated func(childComplexity int) int
		FixtureInstancesCreated   func(childComplexity int) int
		ScenesCreated             func(childComplexity int) int
	}

	InstanceChannel struct {
		DefaultValue func(childComplexity int) int
		FadeBehavior func(childComplexity int) int
		ID           func(childComplexity int) int
		IsDiscrete   func(childComplexity int) int
		MaxValue     func(childComplexity int) int
		MinValue     func(childComplexity int) int
		Name         func(childComplexity int) int
		Offset       func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	LacyLightsFixture struct {
		Manufacturer func(childComplexity int) int
		Model        func(childComplexity int) int
	}

	ModeChannel struct {
		Channel func(childComplexity int) int
		ID      func(childComplexity int) int
		Offset  func(childComplexity int) int
	}

	Mutation struct {
		ActivateSceneFromBoard                 func(childComplexity int, sceneBoardID string, sceneID string, fadeTimeOverride *float64) int
		AddFixturesToScene                     func(childComplexity int, sceneID string, fixtureValues []*FixtureValueInput, overwriteExisting *bool) int
		AddSceneToBoard                        func(childComplexity int, input CreateSceneBoardButtonInput) int
		BulkCreateCueLists                     func(childComplexity int, input BulkCueListCreateInput) int
		BulkCreateCues                         func(childComplexity int, input BulkCueCreateInput) int
		BulkCreateFixtureDefinitions           func(childComplexity int, input BulkFixtureDefinitionCreateInput) int
		BulkCreateFixtures                     func(childComplexity int, input BulkFixtureCreateInput) int
		BulkCreateProjects                     func(childComplexity int, input BulkProjectCreateInput) int
		BulkCreateSceneBoardButtons            func(childComplexity int, input BulkSceneBoardButtonCreateInput) int
		BulkCreateSceneBoards                  func(childComplexity int, input BulkSceneBoardCreateInput) int
		BulkCreateScenes                       func(childComplexity int, input BulkSceneCreateInput) int
		BulkDeleteCueLists                     func(childComplexity int, cueListIds []string) int
		BulkDeleteCues                         func(childComplexity int, cueIds []string) int
		BulkDeleteFixtureDefinitions           func(childComplexity int, definitionIds []string) int
		BulkDeleteFixtures                     func(childComplexity int, fixtureIds []string) int
		BulkDeleteProjects                     func(childComplexity int, projectIds []string) int
		BulkDeleteSceneBoardButtons            func(childComplexity int, buttonIds []string) int
		BulkDeleteSceneBoards                  func(childComplexity int, sceneBoardIds []string) int
		BulkDeleteScenes                       func(childComplexity int, sceneIds []string) int
		BulkUpdateCueLists                     func(childComplexity int, input BulkCueListUpdateInput) int
		BulkUpdateCues                         func(childComplexity int, input BulkCueUpdateInput) int
		BulkUpdateFixtureDefinitions           func(childComplexity int, input BulkFixtureDefinitionUpdateInput) int
		BulkUpdateFixtures                     func(childComplexity int, input BulkFixtureUpdateInput) int
		BulkUpdateInstanceChannelsFadeBehavior func(childComplexity int, updates []*ChannelFadeBehaviorInput) int
		BulkUpdateProjects                     func(childComplexity int, input BulkProjectUpdateInput) int
		BulkUpdateSceneBoardButtons            func(childComplexity int, input BulkSceneBoardButtonUpdateInput) int
		BulkUpdateSceneBoards                  func(childComplexity int, input BulkSceneBoardUpdateInput) int
		BulkUpdateScenes                       func(childComplexity int, input BulkSceneUpdateInput) int
		CancelOFLImport                        func(childComplexity int) int
		CancelPreviewSession                   func(childComplexity int, sessionID string) int
		CloneScene                             func(childComplexity int, sceneID string, newName string) int
		CommitPreviewSession                   func(childComplexity int, sessionID string) int
		ConnectWiFi                            func(childComplexity int, ssid string, password *string) int
		CreateCue                              func(childComplexity int, input CreateCueInput) int
		CreateCueList                          func(childComplexity int, input CreateCueListInput) int
		CreateFixtureDefinition                func(childComplexity int, input CreateFixtureDefinitionInput) int
		CreateFixtureInstance                  func(childComplexity int, input CreateFixtureInstanceInput) int
		CreateProject                          func(childComplexity int, input CreateProjectInput) int
		CreateScene                            func(childComplexity int, input CreateSceneInput) int
		CreateSceneBoard                       func(childComplexity int, input CreateSceneBoardInput) int
		DeleteCue                              func(childComplexity int, id string) int
		DeleteCueList                          func(childComplexity int, id string) int
		DeleteFixtureDefinition                func(childComplexity int, id string) int
		DeleteFixtureInstance                  func(childComplexity int, id string) int
		DeleteProject                          func(childComplexity int, id string) int
		DeleteScene                            func(childComplexity int, id string) int
		DeleteSceneBoard                       func(childComplexity int, id string) int
		DisconnectWiFi                         func(childComplexity int) int
		DuplicateScene                         func(childComplexity int, id string) int
		ExportProject                          func(childComplexity int, projectID string, options *ExportOptionsInput) int
		ExportProjectToQlc                     func(childComplexity int, projectID string, fixtureMappings []*FixtureMappingInput) int
		FadeToBlack                            func(childComplexity int, fadeOutTime float64) int
		ForgetWiFiNetwork                      func(childComplexity int, ssid string) int
		GoToCue                                func(childComplexity int, cueListID string, cueIndex int, fadeInTime *float64) int
		ImportOFLFixture                       func(childComplexity int, input ImportOFLFixtureInput) int
		ImportProject                          func(childComplexity int, jsonContent string, options ImportOptionsInput) int
		ImportProjectFromQlc                   func(childComplexity int, xmlContent string, originalFileName string) int
		InitializePreviewWithScene             func(childComplexity int, sessionID string, sceneID string) int
		NextCue                                func(childComplexity int, cueListID string, fadeInTime *float64) int
		PlayCue                                func(childComplexity int, cueID string, fadeInTime *float64) int
		PreviousCue                            func(childComplexity int, cueListID string, fadeInTime *float64) int
		RemoveFixturesFromScene                func(childComplexity int, sceneID string, fixtureIds []string) int
		RemoveSceneFromBoard                   func(childComplexity int, buttonID string) int
		ReorderCues                            func(childComplexity int, cueListID string, cueOrders []*CueOrderInput) int
		ReorderProjectFixtures                 func(childComplexity int, projectID string, fixtureOrders []*FixtureOrderInput) int
		ReorderSceneFixtures                   func(childComplexity int, sceneID string, fixtureOrders []*FixtureOrderInput) int
		SetChannelValue                        func(childComplexity int, universe int, channel int, value int) int
		SetSceneLive                           func(childComplexity int, sceneID string) int
		SetWiFiEnabled                         func(childComplexity int, enabled bool) int
		StartCueList                           func(childComplexity int, cueListID string, startFromCue *int, fadeInTime *float64) int
		StartPreviewSession                    func(childComplexity int, projectID string) int
		StopCueList                            func(childComplexity int, cueListID string) int
		TriggerOFLImport                       func(childComplexity int, options *OFLImportOptionsInput) int
		UpdateAllRepositories                  func(childComplexity int) int
		UpdateCue                              func(childComplexity int, id string, input CreateCueInput) int
		UpdateCueList                          func(childComplexity int, id string, input CreateCueListInput) int
		UpdateFixtureDefinition                func(childComplexity int, id string, input CreateFixtureDefinitionInput) int
		UpdateFixtureInstance                  func(childComplexity int, id string, input UpdateFixtureInstanceInput) int
		UpdateFixturePositions                 func(childComplexity int, positions []*FixturePositionInput) int
		UpdateInstanceChannelFadeBehavior      func(childComplexity int, channelID string, fadeBehavior FadeBehavior) int
		UpdatePreviewChannel                   func(childComplexity int, sessionID string, fixtureID string, channelIndex int, value int) int
		UpdateProject                          func(childComplexity int, id string, input CreateProjectInput) int
		UpdateRepository                       func(childComplexity int, repository string, version *string) int
		UpdateScene                            func(childComplexity int, id string, input UpdateSceneInput) int
		UpdateSceneBoard                       func(childComplexity int, id string, input UpdateSceneBoardInput) int
		UpdateSceneBoardButton                 func(childComplexity int, id string, input UpdateSceneBoardButtonInput) int
		UpdateSceneBoardButtonPositions        func(childComplexity int, positions []*SceneBoardButtonPositionInput) int
		UpdateScenePartial                     func(childComplexity int, sceneID string, name *string, description *string, fixtureValues []*FixtureValueInput, mergeFixtures *bool) int
		UpdateSetting                          func(childComplexity int, input UpdateSettingInput) int
	}

	NetworkInterfaceOption struct {
		Address       func(childComplexity int) int
		Broadcast     func(childComplexity int) int
		Description   func(childComplexity int) int
		InterfaceType func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	OFLFixtureUpdate struct {
		ChangeType    func(childComplexity int) int
		CurrentHash   func(childComplexity int) int
		FixtureKey    func(childComplexity int) int
		InstanceCount func(childComplexity int) int
		IsInUse       func(childComplexity int) int
		Manufacturer  func(childComplexity int) int
		Model         func(childComplexity int) int
		NewHash       func(childComplexity int) int
	}

	OFLImportResult struct {
		ErrorMessage func(childComplexity int) int
		OflVersion   func(childComplexity int) int
		Stats        func(childComplexity int) int
		Success      func(childComplexity int) int
	}

	OFLImportStats struct {
		DurationSeconds   func(childComplexity int) int
		FailedImports     func(childComplexity int) int
		SkippedDuplicates func(childComplexity int) int
		SuccessfulImports func(childComplexity int) int
		TotalProcessed    func(childComplexity int) int
		UpdatedFixtures   func(childComplexity int) int
	}

	OFLImportStatus struct {
		CompletedAt               func(childComplexity int) int
		CurrentFixture            func(childComplexity int) int
		CurrentManufacturer       func(childComplexity int) int
		ErrorMessage              func(childComplexity int) int
		EstimatedSecondsRemaining func(childComplexity int) int
		FailedCount               func(childComplexity int) int
		ImportedCount             func(childComplexity int) int
		IsImporting               func(childComplexity int) int
		OflVersion                func(childComplexity int) int
		PercentComplete           func(childComplexity int) int
		Phase                     func(childComplexity int) int
		SkippedCount              func(childComplexity int) int
		StartedAt                 func(childComplexity int) int
		TotalFixtures             func(childComplexity int) int
		UsingBundledData          func(childComplexity int) int
	}

	OFLUpdateCheckResult struct {
		ChangedFixtureCount func(childComplexity int) int
		ChangedInUseCount   func(childComplexity int) int
		CheckedAt           func(childComplexity int) int
		CurrentFixtureCount func(childComplexity int) int
		FixtureUpdates      func(childComplexity int) int
		NewFixtureCount     func(childComplexity int) int
		OflFixtureCount     func(childComplexity int) int
		OflVersion          func(childComplexity int) int
	}

	PaginationInfo struct {
		HasMore    func(childComplexity int) int
		Page       func(childComplexity int) int
		PerPage    func(childComplexity int) int
		Total      func(childComplexity int) int
		TotalPages func(childComplexity int) int
	}

	PreviewSession struct {
		CreatedAt func(childComplexity int) int
		DmxOutput func(childComplexity int) int
		ID        func(childComplexity int) int
		IsActive  func(childComplexity int) int
		Project   func(childComplexity int) int
		User      func(childComplexity int) int
	}

	Project struct {
		CreatedAt    func(childComplexity int) int
		CueListCount func(childComplexity int) int
		CueLists     func(childComplexity int) int
		Description  func(childComplexity int) int
		FixtureCount func(childComplexity int) int
		Fixtures     func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		SceneBoards  func(childComplexity int) int
		SceneCount   func(childComplexity int) int
		Scenes       func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	ProjectUser struct {
		ID       func(childComplexity int) int
		JoinedAt func(childComplexity int) int
		Project  func(childComplexity int) int
		Role     func(childComplexity int) int
		User     func(childComplexity int) int
	}

	QLCExportResult struct {
		CueListCount func(childComplexity int) int
		FixtureCount func(childComplexity int) int
		ProjectName  func(childComplexity int) int
		SceneCount   func(childComplexity int) int
		XMLContent   func(childComplexity int) int
	}

	QLCFixtureDefinition struct {
		Manufacturer func(childComplexity int) int
		Model        func(childComplexity int) int
		Modes        func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	QLCFixtureMappingResult struct {
		DefaultMappings    func(childComplexity int) int
		LacyLightsFixtures func(childComplexity int) int
		ProjectID          func(childComplexity int) int
		Suggestions        func(childComplexity int) int
	}

	QLCFixtureMode struct {
		ChannelCount func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	QLCImportResult struct {
		CueListCount     func(childComplexity int) int
		FixtureCount     func(childComplexity int) int
		OriginalFileName func(childComplexity int) int
		Project          func(childComplexity int) int
		SceneCount       func(childComplexity int) int
		Warnings         func(childComplexity int) int
	}

	Query struct {
		AllDmxOutput                    func(childComplexity int) int
		AvailableVersions               func(childComplexity int, repository string) int
		ChannelMap                      func(childComplexity int, projectID string, universe *int) int
		CheckOFLUpdates                 func(childComplexity int) int
		CompareScenes                   func(childComplexity int, sceneID1 string, sceneID2 string) int
		Cue                             func(childComplexity int, id string) int
		CueList                         func(childComplexity int, id string, page *int, perPage *int, includeSceneDetails *bool) int
		CueListPlaybackStatus           func(childComplexity int, cueListID string) int
		CueLists                        func(childComplexity int, projectID string) int
		CueListsByIds                   func(childComplexity int, ids []string) int
		CuesByIds                       func(childComplexity int, ids []string) int
		CurrentActiveScene              func(childComplexity int) int
		DmxOutput                       func(childComplexity int, universe int) int
		FixtureDefinition               func(childComplexity int, id string) int
		FixtureDefinitions              func(childComplexity int, filter *FixtureDefinitionFilter) int
		FixtureDefinitionsByIds         func(childComplexity int, ids []string) int
		FixtureInstance                 func(childComplexity int, id string) int
		FixtureInstances                func(childComplexity int, projectID string, page *int, perPage *int, filter *FixtureFilterInput) int
		FixtureUsage                    func(childComplexity int, fixtureID string) int
		FixturesByIds                   func(childComplexity int, ids []string) int
		GetQLCFixtureMappingSuggestions func(childComplexity int, projectID string) int
		NetworkInterfaceOptions         func(childComplexity int) int
		OflImportStatus                 func(childComplexity int) int
		PreviewSession                  func(childComplexity int, sessionID string) int
		Project                         func(childComplexity int, id string) int
		Projects                        func(childComplexity int) int
		ProjectsByIds                   func(childComplexity int, ids []string) int
		SavedWifiNetworks               func(childComplexity int) int
		Scene                           func(childComplexity int, id string, includeFixtureValues *bool) int
		SceneBoard                      func(childComplexity int, id string) int
		SceneBoardButton                func(childComplexity int, id string) int
		SceneBoards                     func(childComplexity int, projectID string) int
		SceneBoardsByIds                func(childComplexity int, ids []string) int
		SceneFixtures                   func(childComplexity int, sceneID string) int
		SceneUsage                      func(childComplexity int, sceneID string) int
		Scenes                          func(childComplexity int, projectID string, page *int, perPage *int, filter *SceneFilterInput, sortBy *SceneSortField) int
		ScenesByIds                     func(childComplexity int, ids []string) int
		SearchCues                      func(childComplexity int, cueListID string, query string, page *int, perPage *int) int
		SearchFixtures                  func(childComplexity int, projectID string, query string, filter *FixtureFilterInput, page *int, perPage *int) int
		SearchScenes                    func(childComplexity int, projectID string, query string, filter *SceneFilterInput, page *int, perPage *int) int
		Setting                         func(childComplexity int, key string) int
		Settings                        func(childComplexity int) int
		SuggestChannelAssignment        func(childComplexity int, input ChannelAssignmentInput) int
		SystemInfo                      func(childComplexity int) int
		SystemVersions                  func(childComplexity int) int
		WifiNetworks                    func(childComplexity int, rescan *bool, deduplicate *bool) int
		WifiStatus                      func(childComplexity int) int
	}

	RepositoryVersion struct {
		Installed       func(childComplexity int) int
		Latest          func(childComplexity int) int
		Repository      func(childComplexity int) int
		UpdateAvailable func(childComplexity int) int
	}

	Scene struct {
		CreatedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		FixtureValues func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Project       func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	SceneBoard struct {
		Buttons         func(childComplexity int) int
		CanvasHeight    func(childComplexity int) int
		CanvasWidth     func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DefaultFadeTime func(childComplexity int) int
		Description     func(childComplexity int) int
		GridSize        func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Project         func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	SceneBoardButton struct {
		Color      func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Height     func(childComplexity int) int
		ID         func(childComplexity int) int
		Label      func(childComplexity int) int
		LayoutX    func(childComplexity int) int
		LayoutY    func(childComplexity int) int
		Scene      func(childComplexity int) int
		SceneBoard func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		Width      func(childComplexity int) int
	}

	SceneComparison struct {
		Differences           func(childComplexity int) int
		DifferentFixtureCount func(childComplexity int) int
		IdenticalFixtureCount func(childComplexity int) int
		Scene1                func(childComplexity int) int
		Scene2                func(childComplexity int) int
	}

	SceneDifference struct {
		DifferenceType func(childComplexity int) int
		FixtureID      func(childComplexity int) int
		FixtureName    func(childComplexity int) int
		Scene1Values   func(childComplexity int) int
		Scene2Values   func(childComplexity int) int
	}

	SceneFixtureSummary struct {
		FixtureID   func(childComplexity int) int
		FixtureName func(childComplexity int) int
		FixtureType func(childComplexity int) int
	}

	ScenePage struct {
		Pagination func(childComplexity int) int
		Scenes     func(childComplexity int) int
	}

	SceneSummary struct {
		CreatedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		FixtureCount func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	SceneUsage struct {
		Cues      func(childComplexity int) int
		SceneID   func(childComplexity int) int
		SceneName func(childComplexity int) int
	}

	Setting struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Key       func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		Value     func(childComplexity int) int
	}

	Subscription struct {
		CueListPlaybackUpdated func(childComplexity int, cueListID string) int
		DmxOutputChanged       func(childComplexity int, universe *int) int
		OflImportProgress      func(childComplexity int) int
		PreviewSessionUpdated  func(childComplexity int, projectID string) int
		ProjectUpdated         func(childComplexity int, projectID string) int
		SystemInfoUpdated      func(childComplexity int) int
		WifiStatusUpdated      func(childComplexity int) int
	}

	SystemInfo struct {
		ArtnetBroadcastAddress func(childComplexity int) int
		ArtnetEnabled          func(childComplexity int) int
	}

	SystemVersionInfo struct {
		LastChecked                func(childComplexity int) int
		Repositories               func(childComplexity int) int
		VersionManagementSupported func(childComplexity int) int
	}

	UniverseChannelMap struct {
		AvailableChannels func(childComplexity int) int
		ChannelUsage      func(childComplexity int) int
		Fixtures          func(childComplexity int) int
		Universe          func(childComplexity int) int
		UsedChannels      func(childComplexity int) int
	}

	UniverseOutput struct {
		Channels func(childComplexity int) int
		Universe func(childComplexity int) int
	}

	UpdateResult struct {
		Error           func(childComplexity int) int
		Message         func(childComplexity int) int
		NewVersion      func(childComplexity int) int
		PreviousVersion func(childComplexity int) int
		Repository      func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Role      func(childComplexity int) int
	}

	WiFiConnectionResult struct {
		Connected func(childComplexity int) int
		Message   func(childComplexity int) int
		Success   func(childComplexity int) int
	}

	WiFiNetwork struct {
		Frequency      func(childComplexity int) int
		InUse          func(childComplexity int) int
		Saved          func(childComplexity int) int
		Security       func(childComplexity int) int
		SignalStrength func(childComplexity int) int
		Ssid           func(childComplexity int) int
	}

	WiFiStatus struct {
		Available      func(childComplexity int) int
		Connected      func(childComplexity int) int
		Enabled        func(childComplexity int) int
		Frequency      func(childComplexity int) int
		IPAddress      func(childComplexity int) int
		MacAddress     func(childComplexity int) int
		SignalStrength func(childComplexity int) int
		Ssid           func(childComplexity int) int
	}
}

type ChannelDefinitionResolver interface {
	Type(ctx context.Context, obj *models.ChannelDefinition) (ChannelType, error)

	FadeBehavior(ctx context.Context, obj *models.ChannelDefinition) (FadeBehavior, error)
}
type CueResolver interface {
	Scene(ctx context.Context, obj *models.Cue) (*models.Scene, error)
	CueList(ctx context.Context, obj *models.Cue) (*models.CueList, error)

	EasingType(ctx context.Context, obj *models.Cue) (*EasingType, error)
}
type CueListResolver interface {
	Project(ctx context.Context, obj *models.CueList) (*models.Project, error)
	Cues(ctx context.Context, obj *models.CueList) ([]*models.Cue, error)
	CueCount(ctx context.Context, obj *models.CueList) (int, error)
	TotalDuration(ctx context.Context, obj *models.CueList) (float64, error)
	CreatedAt(ctx context.Context, obj *models.CueList) (string, error)
	UpdatedAt(ctx context.Context, obj *models.CueList) (string, error)
}
type FixtureDefinitionResolver interface {
	Type(ctx context.Context, obj *models.FixtureDefinition) (FixtureType, error)
	Channels(ctx context.Context, obj *models.FixtureDefinition) ([]*models.ChannelDefinition, error)
	Modes(ctx context.Context, obj *models.FixtureDefinition) ([]*models.FixtureMode, error)

	CreatedAt(ctx context.Context, obj *models.FixtureDefinition) (string, error)
}
type FixtureInstanceResolver interface {
	Manufacturer(ctx context.Context, obj *models.FixtureInstance) (string, error)
	Model(ctx context.Context, obj *models.FixtureInstance) (string, error)
	Type(ctx context.Context, obj *models.FixtureInstance) (FixtureType, error)
	ModeName(ctx context.Context, obj *models.FixtureInstance) (string, error)
	ChannelCount(ctx context.Context, obj *models.FixtureInstance) (int, error)
	Channels(ctx context.Context, obj *models.FixtureInstance) ([]*models.InstanceChannel, error)
	Project(ctx context.Context, obj *models.FixtureInstance) (*models.Project, error)

	Tags(ctx context.Context, obj *models.FixtureInstance) ([]string, error)

	CreatedAt(ctx context.Context, obj *models.FixtureInstance) (string, error)
}
type FixtureModeResolver interface {
	Channels(ctx context.Context, obj *models.FixtureMode) ([]*models.ModeChannel, error)
}
type FixtureValueResolver interface {
	Fixture(ctx context.Context, obj *models.FixtureValue) (*models.FixtureInstance, error)
	Channels(ctx context.Context, obj *models.FixtureValue) ([]*models.ChannelValue, error)
}
type InstanceChannelResolver interface {
	Type(ctx context.Context, obj *models.InstanceChannel) (ChannelType, error)

	FadeBehavior(ctx context.Context, obj *models.InstanceChannel) (FadeBehavior, error)
}
type ModeChannelResolver interface {
	Channel(ctx context.Context, obj *models.ModeChannel) (*models.ChannelDefinition, error)
}
type MutationResolver interface {
	CreateProject(ctx context.Context, input CreateProjectInput) (*models.Project, error)
	UpdateProject(ctx context.Context, id string, input CreateProjectInput) (*models.Project, error)
	DeleteProject(ctx context.Context, id string) (bool, error)
	BulkCreateProjects(ctx context.Context, input BulkProjectCreateInput) ([]*models.Project, error)
	BulkUpdateProjects(ctx context.Context, input BulkProjectUpdateInput) ([]*models.Project, error)
	BulkDeleteProjects(ctx context.Context, projectIds []string) (*BulkDeleteResult, error)
	CreateFixtureDefinition(ctx context.Context, input CreateFixtureDefinitionInput) (*models.FixtureDefinition, error)
	ImportOFLFixture(ctx context.Context, input ImportOFLFixtureInput) (*models.FixtureDefinition, error)
	UpdateFixtureDefinition(ctx context.Context, id string, input CreateFixtureDefinitionInput) (*models.FixtureDefinition, error)
	DeleteFixtureDefinition(ctx context.Context, id string) (bool, error)
	BulkCreateFixtureDefinitions(ctx context.Context, input BulkFixtureDefinitionCreateInput) ([]*models.FixtureDefinition, error)
	BulkUpdateFixtureDefinitions(ctx context.Context, input BulkFixtureDefinitionUpdateInput) ([]*models.FixtureDefinition, error)
	BulkDeleteFixtureDefinitions(ctx context.Context, definitionIds []string) (*BulkDeleteResult, error)
	CreateFixtureInstance(ctx context.Context, input CreateFixtureInstanceInput) (*models.FixtureInstance, error)
	UpdateFixtureInstance(ctx context.Context, id string, input UpdateFixtureInstanceInput) (*models.FixtureInstance, error)
	BulkUpdateFixtures(ctx context.Context, input BulkFixtureUpdateInput) ([]*models.FixtureInstance, error)
	BulkCreateFixtures(ctx context.Context, input BulkFixtureCreateInput) ([]*models.FixtureInstance, error)
	DeleteFixtureInstance(ctx context.Context, id string) (bool, error)
	BulkDeleteFixtures(ctx context.Context, fixtureIds []string) (*BulkDeleteResult, error)
	UpdateInstanceChannelFadeBehavior(ctx context.Context, channelID string, fadeBehavior FadeBehavior) (*models.InstanceChannel, error)
	BulkUpdateInstanceChannelsFadeBehavior(ctx context.Context, updates []*ChannelFadeBehaviorInput) ([]*models.InstanceChannel, error)
	ReorderProjectFixtures(ctx context.Context, projectID string, fixtureOrders []*FixtureOrderInput) (bool, error)
	ReorderSceneFixtures(ctx context.Context, sceneID string, fixtureOrders []*FixtureOrderInput) (bool, error)
	UpdateFixturePositions(ctx context.Context, positions []*FixturePositionInput) (bool, error)
	CreateScene(ctx context.Context, input CreateSceneInput) (*models.Scene, error)
	UpdateScene(ctx context.Context, id string, input UpdateSceneInput) (*models.Scene, error)
	DuplicateScene(ctx context.Context, id string) (*models.Scene, error)
	CloneScene(ctx context.Context, sceneID string, newName string) (*models.Scene, error)
	DeleteScene(ctx context.Context, id string) (bool, error)
	BulkCreateScenes(ctx context.Context, input BulkSceneCreateInput) ([]*models.Scene, error)
	BulkUpdateScenes(ctx context.Context, input BulkSceneUpdateInput) ([]*models.Scene, error)
	BulkDeleteScenes(ctx context.Context, sceneIds []string) (*BulkDeleteResult, error)
	AddFixturesToScene(ctx context.Context, sceneID string, fixtureValues []*FixtureValueInput, overwriteExisting *bool) (*models.Scene, error)
	RemoveFixturesFromScene(ctx context.Context, sceneID string, fixtureIds []string) (*models.Scene, error)
	UpdateScenePartial(ctx context.Context, sceneID string, name *string, description *string, fixtureValues []*FixtureValueInput, mergeFixtures *bool) (*models.Scene, error)
	CreateSceneBoard(ctx context.Context, input CreateSceneBoardInput) (*models.SceneBoard, error)
	UpdateSceneBoard(ctx context.Context, id string, input UpdateSceneBoardInput) (*models.SceneBoard, error)
	DeleteSceneBoard(ctx context.Context, id string) (bool, error)
	BulkCreateSceneBoards(ctx context.Context, input BulkSceneBoardCreateInput) ([]*models.SceneBoard, error)
	BulkUpdateSceneBoards(ctx context.Context, input BulkSceneBoardUpdateInput) ([]*models.SceneBoard, error)
	BulkDeleteSceneBoards(ctx context.Context, sceneBoardIds []string) (*BulkDeleteResult, error)
	AddSceneToBoard(ctx context.Context, input CreateSceneBoardButtonInput) (*models.SceneBoardButton, error)
	UpdateSceneBoardButton(ctx context.Context, id string, input UpdateSceneBoardButtonInput) (*models.SceneBoardButton, error)
	RemoveSceneFromBoard(ctx context.Context, buttonID string) (bool, error)
	UpdateSceneBoardButtonPositions(ctx context.Context, positions []*SceneBoardButtonPositionInput) (bool, error)
	BulkCreateSceneBoardButtons(ctx context.Context, input BulkSceneBoardButtonCreateInput) ([]*models.SceneBoardButton, error)
	BulkUpdateSceneBoardButtons(ctx context.Context, input BulkSceneBoardButtonUpdateInput) ([]*models.SceneBoardButton, error)
	BulkDeleteSceneBoardButtons(ctx context.Context, buttonIds []string) (*BulkDeleteResult, error)
	ActivateSceneFromBoard(ctx context.Context, sceneBoardID string, sceneID string, fadeTimeOverride *float64) (bool, error)
	CreateCueList(ctx context.Context, input CreateCueListInput) (*models.CueList, error)
	UpdateCueList(ctx context.Context, id string, input CreateCueListInput) (*models.CueList, error)
	DeleteCueList(ctx context.Context, id string) (bool, error)
	BulkCreateCueLists(ctx context.Context, input BulkCueListCreateInput) ([]*models.CueList, error)
	BulkUpdateCueLists(ctx context.Context, input BulkCueListUpdateInput) ([]*models.CueList, error)
	BulkDeleteCueLists(ctx context.Context, cueListIds []string) (*BulkDeleteResult, error)
	CreateCue(ctx context.Context, input CreateCueInput) (*models.Cue, error)
	UpdateCue(ctx context.Context, id string, input CreateCueInput) (*models.Cue, error)
	DeleteCue(ctx context.Context, id string) (bool, error)
	ReorderCues(ctx context.Context, cueListID string, cueOrders []*CueOrderInput) (bool, error)
	BulkCreateCues(ctx context.Context, input BulkCueCreateInput) ([]*models.Cue, error)
	BulkUpdateCues(ctx context.Context, input BulkCueUpdateInput) ([]*models.Cue, error)
	BulkDeleteCues(ctx context.Context, cueIds []string) (*BulkDeleteResult, error)
	StartPreviewSession(ctx context.Context, projectID string) (*models.PreviewSession, error)
	CommitPreviewSession(ctx context.Context, sessionID string) (bool, error)
	CancelPreviewSession(ctx context.Context, sessionID string) (bool, error)
	UpdatePreviewChannel(ctx context.Context, sessionID string, fixtureID string, channelIndex int, value int) (bool, error)
	InitializePreviewWithScene(ctx context.Context, sessionID string, sceneID string) (bool, error)
	SetChannelValue(ctx context.Context, universe int, channel int, value int) (bool, error)
	SetSceneLive(ctx context.Context, sceneID string) (bool, error)
	PlayCue(ctx context.Context, cueID string, fadeInTime *float64) (bool, error)
	FadeToBlack(ctx context.Context, fadeOutTime float64) (bool, error)
	StartCueList(ctx context.Context, cueListID string, startFromCue *int, fadeInTime *float64) (bool, error)
	NextCue(ctx context.Context, cueListID string, fadeInTime *float64) (bool, error)
	PreviousCue(ctx context.Context, cueListID string, fadeInTime *float64) (bool, error)
	GoToCue(ctx context.Context, cueListID string, cueIndex int, fadeInTime *float64) (bool, error)
	StopCueList(ctx context.Context, cueListID string) (bool, error)
	ExportProject(ctx context.Context, projectID string, options *ExportOptionsInput) (*ExportResult, error)
	ImportProject(ctx context.Context, jsonContent string, options ImportOptionsInput) (*ImportResult, error)
	ImportProjectFromQlc(ctx context.Context, xmlContent string, originalFileName string) (*QLCImportResult, error)
	ExportProjectToQlc(ctx context.Context, projectID string, fixtureMappings []*FixtureMappingInput) (*QLCExportResult, error)
	UpdateSetting(ctx context.Context, input UpdateSettingInput) (*models.Setting, error)
	ConnectWiFi(ctx context.Context, ssid string, password *string) (*WiFiConnectionResult, error)
	DisconnectWiFi(ctx context.Context) (*WiFiConnectionResult, error)
	SetWiFiEnabled(ctx context.Context, enabled bool) (*WiFiStatus, error)
	ForgetWiFiNetwork(ctx context.Context, ssid string) (bool, error)
	UpdateRepository(ctx context.Context, repository string, version *string) (*UpdateResult, error)
	UpdateAllRepositories(ctx context.Context) ([]*UpdateResult, error)
	TriggerOFLImport(ctx context.Context, options *OFLImportOptionsInput) (*OFLImportResult, error)
	CancelOFLImport(ctx context.Context) (bool, error)
}
type PreviewSessionResolver interface {
	Project(ctx context.Context, obj *models.PreviewSession) (*models.Project, error)
	User(ctx context.Context, obj *models.PreviewSession) (*models.User, error)

	CreatedAt(ctx context.Context, obj *models.PreviewSession) (string, error)
	DmxOutput(ctx context.Context, obj *models.PreviewSession) ([]*UniverseOutput, error)
}
type ProjectResolver interface {
	FixtureCount(ctx context.Context, obj *models.Project) (int, error)
	SceneCount(ctx context.Context, obj *models.Project) (int, error)
	CueListCount(ctx context.Context, obj *models.Project) (int, error)
	CreatedAt(ctx context.Context, obj *models.Project) (string, error)
	UpdatedAt(ctx context.Context, obj *models.Project) (string, error)
	Fixtures(ctx context.Context, obj *models.Project) ([]*models.FixtureInstance, error)
	Scenes(ctx context.Context, obj *models.Project) ([]*models.Scene, error)
	CueLists(ctx context.Context, obj *models.Project) ([]*models.CueList, error)
	SceneBoards(ctx context.Context, obj *models.Project) ([]*models.SceneBoard, error)
	Users(ctx context.Context, obj *models.Project) ([]*models.ProjectUser, error)
}
type ProjectUserResolver interface {
	User(ctx context.Context, obj *models.ProjectUser) (*models.User, error)
	Project(ctx context.Context, obj *models.ProjectUser) (*models.Project, error)
	Role(ctx context.Context, obj *models.ProjectUser) (ProjectRole, error)
	JoinedAt(ctx context.Context, obj *models.ProjectUser) (string, error)
}
type QueryResolver interface {
	Projects(ctx context.Context) ([]*models.Project, error)
	Project(ctx context.Context, id string) (*models.Project, error)
	FixtureDefinitions(ctx context.Context, filter *FixtureDefinitionFilter) ([]*models.FixtureDefinition, error)
	FixtureDefinition(ctx context.Context, id string) (*models.FixtureDefinition, error)
	FixtureInstances(ctx context.Context, projectID string, page *int, perPage *int, filter *FixtureFilterInput) (*FixtureInstancePage, error)
	FixtureInstance(ctx context.Context, id string) (*models.FixtureInstance, error)
	SearchFixtures(ctx context.Context, projectID string, query string, filter *FixtureFilterInput, page *int, perPage *int) (*FixtureInstancePage, error)
	ChannelMap(ctx context.Context, projectID string, universe *int) (*ChannelMapResult, error)
	SuggestChannelAssignment(ctx context.Context, input ChannelAssignmentInput) (*ChannelAssignmentSuggestion, error)
	Scenes(ctx context.Context, projectID string, page *int, perPage *int, filter *SceneFilterInput, sortBy *SceneSortField) (*ScenePage, error)
	Scene(ctx context.Context, id string, includeFixtureValues *bool) (*models.Scene, error)
	SceneFixtures(ctx context.Context, sceneID string) ([]*SceneFixtureSummary, error)
	SearchScenes(ctx context.Context, projectID string, query string, filter *SceneFilterInput, page *int, perPage *int) (*ScenePage, error)
	SceneBoards(ctx context.Context, projectID string) ([]*models.SceneBoard, error)
	SceneBoard(ctx context.Context, id string) (*models.SceneBoard, error)
	SceneBoardButton(ctx context.Context, id string) (*models.SceneBoardButton, error)
	FixtureUsage(ctx context.Context, fixtureID string) (*FixtureUsage, error)
	SceneUsage(ctx context.Context, sceneID string) (*SceneUsage, error)
	CompareScenes(ctx context.Context, sceneID1 string, sceneID2 string) (*SceneComparison, error)
	CueLists(ctx context.Context, projectID string) ([]*CueListSummary, error)
	CueList(ctx context.Context, id string, page *int, perPage *int, includeSceneDetails *bool) (*models.CueList, error)
	CueListPlaybackStatus(ctx context.Context, cueListID string) (*CueListPlaybackStatus, error)
	Cue(ctx context.Context, id string) (*models.Cue, error)
	SearchCues(ctx context.Context, cueListID string, query string, page *int, perPage *int) (*CuePage, error)
	DmxOutput(ctx context.Context, universe int) ([]int, error)
	AllDmxOutput(ctx context.Context) ([]*UniverseOutput, error)
	PreviewSession(ctx context.Context, sessionID string) (*models.PreviewSession, error)
	CurrentActiveScene(ctx context.Context) (*models.Scene, error)
	Settings(ctx context.Context) ([]*models.Setting, error)
	Setting(ctx context.Context, key string) (*models.Setting, error)
	SystemInfo(ctx context.Context) (*SystemInfo, error)
	NetworkInterfaceOptions(ctx context.Context) ([]*NetworkInterfaceOption, error)
	WifiNetworks(ctx context.Context, rescan *bool, deduplicate *bool) ([]*WiFiNetwork, error)
	WifiStatus(ctx context.Context) (*WiFiStatus, error)
	SavedWifiNetworks(ctx context.Context) ([]*WiFiNetwork, error)
	GetQLCFixtureMappingSuggestions(ctx context.Context, projectID string) (*QLCFixtureMappingResult, error)
	SystemVersions(ctx context.Context) (*SystemVersionInfo, error)
	AvailableVersions(ctx context.Context, repository string) ([]string, error)
	OflImportStatus(ctx context.Context) (*OFLImportStatus, error)
	CheckOFLUpdates(ctx context.Context) (*OFLUpdateCheckResult, error)
	FixturesByIds(ctx context.Context, ids []string) ([]*models.FixtureInstance, error)
	ScenesByIds(ctx context.Context, ids []string) ([]*models.Scene, error)
	CuesByIds(ctx context.Context, ids []string) ([]*models.Cue, error)
	CueListsByIds(ctx context.Context, ids []string) ([]*models.CueList, error)
	SceneBoardsByIds(ctx context.Context, ids []string) ([]*models.SceneBoard, error)
	FixtureDefinitionsByIds(ctx context.Context, ids []string) ([]*models.FixtureDefinition, error)
	ProjectsByIds(ctx context.Context, ids []string) ([]*models.Project, error)
}
type SceneResolver interface {
	Project(ctx context.Context, obj *models.Scene) (*models.Project, error)
	FixtureValues(ctx context.Context, obj *models.Scene) ([]*models.FixtureValue, error)
	CreatedAt(ctx context.Context, obj *models.Scene) (string, error)
	UpdatedAt(ctx context.Context, obj *models.Scene) (string, error)
}
type SceneBoardResolver interface {
	Project(ctx context.Context, obj *models.SceneBoard) (*models.Project, error)

	Buttons(ctx context.Context, obj *models.SceneBoard) ([]*models.SceneBoardButton, error)
	CreatedAt(ctx context.Context, obj *models.SceneBoard) (string, error)
	UpdatedAt(ctx context.Context, obj *models.SceneBoard) (string, error)
}
type SceneBoardButtonResolver interface {
	SceneBoard(ctx context.Context, obj *models.SceneBoardButton) (*models.SceneBoard, error)
	Scene(ctx context.Context, obj *models.SceneBoardButton) (*models.Scene, error)

	CreatedAt(ctx context.Context, obj *models.SceneBoardButton) (string, error)
	UpdatedAt(ctx context.Context, obj *models.SceneBoardButton) (string, error)
}
type SettingResolver interface {
	CreatedAt(ctx context.Context, obj *models.Setting) (string, error)
	UpdatedAt(ctx context.Context, obj *models.Setting) (string, error)
}
type SubscriptionResolver interface {
	DmxOutputChanged(ctx context.Context, universe *int) (<-chan *UniverseOutput, error)
	ProjectUpdated(ctx context.Context, projectID string) (<-chan *models.Project, error)
	PreviewSessionUpdated(ctx context.Context, projectID string) (<-chan *models.PreviewSession, error)
	CueListPlaybackUpdated(ctx context.Context, cueListID string) (<-chan *CueListPlaybackStatus, error)
	SystemInfoUpdated(ctx context.Context) (<-chan *SystemInfo, error)
	WifiStatusUpdated(ctx context.Context) (<-chan *WiFiStatus, error)
	OflImportProgress(ctx context.Context) (<-chan *OFLImportStatus, error)
}
type UserResolver interface {
	Role(ctx context.Context, obj *models.User) (UserRole, error)
	CreatedAt(ctx context.Context, obj *models.User) (string, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BulkDeleteResult.deletedCount":
		if e.complexity.BulkDeleteResult.DeletedCount == nil {
			break
		}

		return e.complexity.BulkDeleteResult.DeletedCount(childComplexity), true
	case "BulkDeleteResult.deletedIds":
		if e.complexity.BulkDeleteResult.DeletedIds == nil {
			break
		}

		return e.complexity.BulkDeleteResult.DeletedIds(childComplexity), true

	case "ChannelAssignmentSuggestion.assignments":
		if e.complexity.ChannelAssignmentSuggestion.Assignments == nil {
			break
		}

		return e.complexity.ChannelAssignmentSuggestion.Assignments(childComplexity), true
	case "ChannelAssignmentSuggestion.availableChannelsRemaining":
		if e.complexity.ChannelAssignmentSuggestion.AvailableChannelsRemaining == nil {
			break
		}

		return e.complexity.ChannelAssignmentSuggestion.AvailableChannelsRemaining(childComplexity), true
	case "ChannelAssignmentSuggestion.totalChannelsNeeded":
		if e.complexity.ChannelAssignmentSuggestion.TotalChannelsNeeded == nil {
			break
		}

		return e.complexity.ChannelAssignmentSuggestion.TotalChannelsNeeded(childComplexity), true
	case "ChannelAssignmentSuggestion.universe":
		if e.complexity.ChannelAssignmentSuggestion.Universe == nil {
			break
		}

		return e.complexity.ChannelAssignmentSuggestion.Universe(childComplexity), true

	case "ChannelDefinition.defaultValue":
		if e.complexity.ChannelDefinition.DefaultValue == nil {
			break
		}

		return e.complexity.ChannelDefinition.DefaultValue(childComplexity), true
	case "ChannelDefinition.fadeBehavior":
		if e.complexity.ChannelDefinition.FadeBehavior == nil {
			break
		}

		return e.complexity.ChannelDefinition.FadeBehavior(childComplexity), true
	case "ChannelDefinition.id":
		if e.complexity.ChannelDefinition.ID == nil {
			break
		}

		return e.complexity.ChannelDefinition.ID(childComplexity), true
	case "ChannelDefinition.isDiscrete":
		if e.complexity.ChannelDefinition.IsDiscrete == nil {
			break
		}

		return e.complexity.ChannelDefinition.IsDiscrete(childComplexity), true
	case "ChannelDefinition.maxValue":
		if e.complexity.ChannelDefinition.MaxValue == nil {
			break
		}

		return e.complexity.ChannelDefinition.MaxValue(childComplexity), true
	case "ChannelDefinition.minValue":
		if e.complexity.ChannelDefinition.MinValue == nil {
			break
		}

		return e.complexity.ChannelDefinition.MinValue(childComplexity), true
	case "ChannelDefinition.name":
		if e.complexity.ChannelDefinition.Name == nil {
			break
		}

		return e.complexity.ChannelDefinition.Name(childComplexity), true
	case "ChannelDefinition.offset":
		if e.complexity.ChannelDefinition.Offset == nil {
			break
		}

		return e.complexity.ChannelDefinition.Offset(childComplexity), true
	case "ChannelDefinition.type":
		if e.complexity.ChannelDefinition.Type == nil {
			break
		}

		return e.complexity.ChannelDefinition.Type(childComplexity), true

	case "ChannelMapFixture.channelCount":
		if e.complexity.ChannelMapFixture.ChannelCount == nil {
			break
		}

		return e.complexity.ChannelMapFixture.ChannelCount(childComplexity), true
	case "ChannelMapFixture.endChannel":
		if e.complexity.ChannelMapFixture.EndChannel == nil {
			break
		}

		return e.complexity.ChannelMapFixture.EndChannel(childComplexity), true
	case "ChannelMapFixture.id":
		if e.complexity.ChannelMapFixture.ID == nil {
			break
		}

		return e.complexity.ChannelMapFixture.ID(childComplexity), true
	case "ChannelMapFixture.name":
		if e.complexity.ChannelMapFixture.Name == nil {
			break
		}

		return e.complexity.ChannelMapFixture.Name(childComplexity), true
	case "ChannelMapFixture.startChannel":
		if e.complexity.ChannelMapFixture.StartChannel == nil {
			break
		}

		return e.complexity.ChannelMapFixture.StartChannel(childComplexity), true
	case "ChannelMapFixture.type":
		if e.complexity.ChannelMapFixture.Type == nil {
			break
		}

		return e.complexity.ChannelMapFixture.Type(childComplexity), true

	case "ChannelMapResult.projectId":
		if e.complexity.ChannelMapResult.ProjectID == nil {
			break
		}

		return e.complexity.ChannelMapResult.ProjectID(childComplexity), true
	case "ChannelMapResult.universes":
		if e.complexity.ChannelMapResult.Universes == nil {
			break
		}

		return e.complexity.ChannelMapResult.Universes(childComplexity), true

	case "ChannelUsage.channelType":
		if e.complexity.ChannelUsage.ChannelType == nil {
			break
		}

		return e.complexity.ChannelUsage.ChannelType(childComplexity), true
	case "ChannelUsage.fixtureId":
		if e.complexity.ChannelUsage.FixtureID == nil {
			break
		}

		return e.complexity.ChannelUsage.FixtureID(childComplexity), true
	case "ChannelUsage.fixtureName":
		if e.complexity.ChannelUsage.FixtureName == nil {
			break
		}

		return e.complexity.ChannelUsage.FixtureName(childComplexity), true

	case "ChannelValue.offset":
		if e.complexity.ChannelValue.Offset == nil {
			break
		}

		return e.complexity.ChannelValue.Offset(childComplexity), true
	case "ChannelValue.value":
		if e.complexity.ChannelValue.Value == nil {
			break
		}

		return e.complexity.ChannelValue.Value(childComplexity), true

	case "Cue.cueList":
		if e.complexity.Cue.CueList == nil {
			break
		}

		return e.complexity.Cue.CueList(childComplexity), true
	case "Cue.cueNumber":
		if e.complexity.Cue.CueNumber == nil {
			break
		}

		return e.complexity.Cue.CueNumber(childComplexity), true
	case "Cue.easingType":
		if e.complexity.Cue.EasingType == nil {
			break
		}

		return e.complexity.Cue.EasingType(childComplexity), true
	case "Cue.fadeInTime":
		if e.complexity.Cue.FadeInTime == nil {
			break
		}

		return e.complexity.Cue.FadeInTime(childComplexity), true
	case "Cue.fadeOutTime":
		if e.complexity.Cue.FadeOutTime == nil {
			break
		}

		return e.complexity.Cue.FadeOutTime(childComplexity), true
	case "Cue.followTime":
		if e.complexity.Cue.FollowTime == nil {
			break
		}

		return e.complexity.Cue.FollowTime(childComplexity), true
	case "Cue.id":
		if e.complexity.Cue.ID == nil {
			break
		}

		return e.complexity.Cue.ID(childComplexity), true
	case "Cue.name":
		if e.complexity.Cue.Name == nil {
			break
		}

		return e.complexity.Cue.Name(childComplexity), true
	case "Cue.notes":
		if e.complexity.Cue.Notes == nil {
			break
		}

		return e.complexity.Cue.Notes(childComplexity), true
	case "Cue.scene":
		if e.complexity.Cue.Scene == nil {
			break
		}

		return e.complexity.Cue.Scene(childComplexity), true

	case "CueList.createdAt":
		if e.complexity.CueList.CreatedAt == nil {
			break
		}

		return e.complexity.CueList.CreatedAt(childComplexity), true
	case "CueList.cueCount":
		if e.complexity.CueList.CueCount == nil {
			break
		}

		return e.complexity.CueList.CueCount(childComplexity), true
	case "CueList.cues":
		if e.complexity.CueList.Cues == nil {
			break
		}

		return e.complexity.CueList.Cues(childComplexity), true
	case "CueList.description":
		if e.complexity.CueList.Description == nil {
			break
		}

		return e.complexity.CueList.Description(childComplexity), true
	case "CueList.id":
		if e.complexity.CueList.ID == nil {
			break
		}

		return e.complexity.CueList.ID(childComplexity), true
	case "CueList.loop":
		if e.complexity.CueList.Loop == nil {
			break
		}

		return e.complexity.CueList.Loop(childComplexity), true
	case "CueList.name":
		if e.complexity.CueList.Name == nil {
			break
		}

		return e.complexity.CueList.Name(childComplexity), true
	case "CueList.project":
		if e.complexity.CueList.Project == nil {
			break
		}

		return e.complexity.CueList.Project(childComplexity), true
	case "CueList.totalDuration":
		if e.complexity.CueList.TotalDuration == nil {
			break
		}

		return e.complexity.CueList.TotalDuration(childComplexity), true
	case "CueList.updatedAt":
		if e.complexity.CueList.UpdatedAt == nil {
			break
		}

		return e.complexity.CueList.UpdatedAt(childComplexity), true

	case "CueListPlaybackStatus.cueListId":
		if e.complexity.CueListPlaybackStatus.CueListID == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.CueListID(childComplexity), true
	case "CueListPlaybackStatus.currentCue":
		if e.complexity.CueListPlaybackStatus.CurrentCue == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.CurrentCue(childComplexity), true
	case "CueListPlaybackStatus.currentCueIndex":
		if e.complexity.CueListPlaybackStatus.CurrentCueIndex == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.CurrentCueIndex(childComplexity), true
	case "CueListPlaybackStatus.fadeProgress":
		if e.complexity.CueListPlaybackStatus.FadeProgress == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.FadeProgress(childComplexity), true
	case "CueListPlaybackStatus.isFading":
		if e.complexity.CueListPlaybackStatus.IsFading == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.IsFading(childComplexity), true
	case "CueListPlaybackStatus.isPlaying":
		if e.complexity.CueListPlaybackStatus.IsPlaying == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.IsPlaying(childComplexity), true
	case "CueListPlaybackStatus.lastUpdated":
		if e.complexity.CueListPlaybackStatus.LastUpdated == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.LastUpdated(childComplexity), true
	case "CueListPlaybackStatus.nextCue":
		if e.complexity.CueListPlaybackStatus.NextCue == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.NextCue(childComplexity), true
	case "CueListPlaybackStatus.previousCue":
		if e.complexity.CueListPlaybackStatus.PreviousCue == nil {
			break
		}

		return e.complexity.CueListPlaybackStatus.PreviousCue(childComplexity), true

	case "CueListSummary.createdAt":
		if e.complexity.CueListSummary.CreatedAt == nil {
			break
		}

		return e.complexity.CueListSummary.CreatedAt(childComplexity), true
	case "CueListSummary.cueCount":
		if e.complexity.CueListSummary.CueCount == nil {
			break
		}

		return e.complexity.CueListSummary.CueCount(childComplexity), true
	case "CueListSummary.description":
		if e.complexity.CueListSummary.Description == nil {
			break
		}

		return e.complexity.CueListSummary.Description(childComplexity), true
	case "CueListSummary.id":
		if e.complexity.CueListSummary.ID == nil {
			break
		}

		return e.complexity.CueListSummary.ID(childComplexity), true
	case "CueListSummary.loop":
		if e.complexity.CueListSummary.Loop == nil {
			break
		}

		return e.complexity.CueListSummary.Loop(childComplexity), true
	case "CueListSummary.name":
		if e.complexity.CueListSummary.Name == nil {
			break
		}

		return e.complexity.CueListSummary.Name(childComplexity), true
	case "CueListSummary.totalDuration":
		if e.complexity.CueListSummary.TotalDuration == nil {
			break
		}

		return e.complexity.CueListSummary.TotalDuration(childComplexity), true

	case "CuePage.cues":
		if e.complexity.CuePage.Cues == nil {
			break
		}

		return e.complexity.CuePage.Cues(childComplexity), true
	case "CuePage.pagination":
		if e.complexity.CuePage.Pagination == nil {
			break
		}

		return e.complexity.CuePage.Pagination(childComplexity), true

	case "CueUsageSummary.cueId":
		if e.complexity.CueUsageSummary.CueID == nil {
			break
		}

		return e.complexity.CueUsageSummary.CueID(childComplexity), true
	case "CueUsageSummary.cueListId":
		if e.complexity.CueUsageSummary.CueListID == nil {
			break
		}

		return e.complexity.CueUsageSummary.CueListID(childComplexity), true
	case "CueUsageSummary.cueListName":
		if e.complexity.CueUsageSummary.CueListName == nil {
			break
		}

		return e.complexity.CueUsageSummary.CueListName(childComplexity), true
	case "CueUsageSummary.cueName":
		if e.complexity.CueUsageSummary.CueName == nil {
			break
		}

		return e.complexity.CueUsageSummary.CueName(childComplexity), true
	case "CueUsageSummary.cueNumber":
		if e.complexity.CueUsageSummary.CueNumber == nil {
			break
		}

		return e.complexity.CueUsageSummary.CueNumber(childComplexity), true

	case "ExportResult.jsonContent":
		if e.complexity.ExportResult.JSONContent == nil {
			break
		}

		return e.complexity.ExportResult.JSONContent(childComplexity), true
	case "ExportResult.projectId":
		if e.complexity.ExportResult.ProjectID == nil {
			break
		}

		return e.complexity.ExportResult.ProjectID(childComplexity), true
	case "ExportResult.projectName":
		if e.complexity.ExportResult.ProjectName == nil {
			break
		}

		return e.complexity.ExportResult.ProjectName(childComplexity), true
	case "ExportResult.stats":
		if e.complexity.ExportResult.Stats == nil {
			break
		}

		return e.complexity.ExportResult.Stats(childComplexity), true

	case "ExportStats.cueListsCount":
		if e.complexity.ExportStats.CueListsCount == nil {
			break
		}

		return e.complexity.ExportStats.CueListsCount(childComplexity), true
	case "ExportStats.cuesCount":
		if e.complexity.ExportStats.CuesCount == nil {
			break
		}

		return e.complexity.ExportStats.CuesCount(childComplexity), true
	case "ExportStats.fixtureDefinitionsCount":
		if e.complexity.ExportStats.FixtureDefinitionsCount == nil {
			break
		}

		return e.complexity.ExportStats.FixtureDefinitionsCount(childComplexity), true
	case "ExportStats.fixtureInstancesCount":
		if e.complexity.ExportStats.FixtureInstancesCount == nil {
			break
		}

		return e.complexity.ExportStats.FixtureInstancesCount(childComplexity), true
	case "ExportStats.scenesCount":
		if e.complexity.ExportStats.ScenesCount == nil {
			break
		}

		return e.complexity.ExportStats.ScenesCount(childComplexity), true

	case "FixtureChannelAssignment.channelCount":
		if e.complexity.FixtureChannelAssignment.ChannelCount == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.ChannelCount(childComplexity), true
	case "FixtureChannelAssignment.channelRange":
		if e.complexity.FixtureChannelAssignment.ChannelRange == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.ChannelRange(childComplexity), true
	case "FixtureChannelAssignment.endChannel":
		if e.complexity.FixtureChannelAssignment.EndChannel == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.EndChannel(childComplexity), true
	case "FixtureChannelAssignment.fixtureName":
		if e.complexity.FixtureChannelAssignment.FixtureName == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.FixtureName(childComplexity), true
	case "FixtureChannelAssignment.manufacturer":
		if e.complexity.FixtureChannelAssignment.Manufacturer == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.Manufacturer(childComplexity), true
	case "FixtureChannelAssignment.mode":
		if e.complexity.FixtureChannelAssignment.Mode == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.Mode(childComplexity), true
	case "FixtureChannelAssignment.model":
		if e.complexity.FixtureChannelAssignment.Model == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.Model(childComplexity), true
	case "FixtureChannelAssignment.startChannel":
		if e.complexity.FixtureChannelAssignment.StartChannel == nil {
			break
		}

		return e.complexity.FixtureChannelAssignment.StartChannel(childComplexity), true

	case "FixtureDefinition.channels":
		if e.complexity.FixtureDefinition.Channels == nil {
			break
		}

		return e.complexity.FixtureDefinition.Channels(childComplexity), true
	case "FixtureDefinition.createdAt":
		if e.complexity.FixtureDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.FixtureDefinition.CreatedAt(childComplexity), true
	case "FixtureDefinition.id":
		if e.complexity.FixtureDefinition.ID == nil {
			break
		}

		return e.complexity.FixtureDefinition.ID(childComplexity), true
	case "FixtureDefinition.isBuiltIn":
		if e.complexity.FixtureDefinition.IsBuiltIn == nil {
			break
		}

		return e.complexity.FixtureDefinition.IsBuiltIn(childComplexity), true
	case "FixtureDefinition.manufacturer":
		if e.complexity.FixtureDefinition.Manufacturer == nil {
			break
		}

		return e.complexity.FixtureDefinition.Manufacturer(childComplexity), true
	case "FixtureDefinition.model":
		if e.complexity.FixtureDefinition.Model == nil {
			break
		}

		return e.complexity.FixtureDefinition.Model(childComplexity), true
	case "FixtureDefinition.modes":
		if e.complexity.FixtureDefinition.Modes == nil {
			break
		}

		return e.complexity.FixtureDefinition.Modes(childComplexity), true
	case "FixtureDefinition.type":
		if e.complexity.FixtureDefinition.Type == nil {
			break
		}

		return e.complexity.FixtureDefinition.Type(childComplexity), true

	case "FixtureInstance.channelCount":
		if e.complexity.FixtureInstance.ChannelCount == nil {
			break
		}

		return e.complexity.FixtureInstance.ChannelCount(childComplexity), true
	case "FixtureInstance.channels":
		if e.complexity.FixtureInstance.Channels == nil {
			break
		}

		return e.complexity.FixtureInstance.Channels(childComplexity), true
	case "FixtureInstance.createdAt":
		if e.complexity.FixtureInstance.CreatedAt == nil {
			break
		}

		return e.complexity.FixtureInstance.CreatedAt(childComplexity), true
	case "FixtureInstance.definitionId":
		if e.complexity.FixtureInstance.DefinitionID == nil {
			break
		}

		return e.complexity.FixtureInstance.DefinitionID(childComplexity), true
	case "FixtureInstance.description":
		if e.complexity.FixtureInstance.Description == nil {
			break
		}

		return e.complexity.FixtureInstance.Description(childComplexity), true
	case "FixtureInstance.id":
		if e.complexity.FixtureInstance.ID == nil {
			break
		}

		return e.complexity.FixtureInstance.ID(childComplexity), true
	case "FixtureInstance.layoutRotation":
		if e.complexity.FixtureInstance.LayoutRotation == nil {
			break
		}

		return e.complexity.FixtureInstance.LayoutRotation(childComplexity), true
	case "FixtureInstance.layoutX":
		if e.complexity.FixtureInstance.LayoutX == nil {
			break
		}

		return e.complexity.FixtureInstance.LayoutX(childComplexity), true
	case "FixtureInstance.layoutY":
		if e.complexity.FixtureInstance.LayoutY == nil {
			break
		}

		return e.complexity.FixtureInstance.LayoutY(childComplexity), true
	case "FixtureInstance.manufacturer":
		if e.complexity.FixtureInstance.Manufacturer == nil {
			break
		}

		return e.complexity.FixtureInstance.Manufacturer(childComplexity), true
	case "FixtureInstance.modeName":
		if e.complexity.FixtureInstance.ModeName == nil {
			break
		}

		return e.complexity.FixtureInstance.ModeName(childComplexity), true
	case "FixtureInstance.model":
		if e.complexity.FixtureInstance.Model == nil {
			break
		}

		return e.complexity.FixtureInstance.Model(childComplexity), true
	case "FixtureInstance.name":
		if e.complexity.FixtureInstance.Name == nil {
			break
		}

		return e.complexity.FixtureInstance.Name(childComplexity), true
	case "FixtureInstance.project":
		if e.complexity.FixtureInstance.Project == nil {
			break
		}

		return e.complexity.FixtureInstance.Project(childComplexity), true
	case "FixtureInstance.projectOrder":
		if e.complexity.FixtureInstance.ProjectOrder == nil {
			break
		}

		return e.complexity.FixtureInstance.ProjectOrder(childComplexity), true
	case "FixtureInstance.startChannel":
		if e.complexity.FixtureInstance.StartChannel == nil {
			break
		}

		return e.complexity.FixtureInstance.StartChannel(childComplexity), true
	case "FixtureInstance.tags":
		if e.complexity.FixtureInstance.Tags == nil {
			break
		}

		return e.complexity.FixtureInstance.Tags(childComplexity), true
	case "FixtureInstance.type":
		if e.complexity.FixtureInstance.Type == nil {
			break
		}

		return e.complexity.FixtureInstance.Type(childComplexity), true
	case "FixtureInstance.universe":
		if e.complexity.FixtureInstance.Universe == nil {
			break
		}

		return e.complexity.FixtureInstance.Universe(childComplexity), true

	case "FixtureInstancePage.fixtures":
		if e.complexity.FixtureInstancePage.Fixtures == nil {
			break
		}

		return e.complexity.FixtureInstancePage.Fixtures(childComplexity), true
	case "FixtureInstancePage.pagination":
		if e.complexity.FixtureInstancePage.Pagination == nil {
			break
		}

		return e.complexity.FixtureInstancePage.Pagination(childComplexity), true

	case "FixtureMapping.lacyLightsKey":
		if e.complexity.FixtureMapping.LacyLightsKey == nil {
			break
		}

		return e.complexity.FixtureMapping.LacyLightsKey(childComplexity), true
	case "FixtureMapping.qlcManufacturer":
		if e.complexity.FixtureMapping.QlcManufacturer == nil {
			break
		}

		return e.complexity.FixtureMapping.QlcManufacturer(childComplexity), true
	case "FixtureMapping.qlcMode":
		if e.complexity.FixtureMapping.QlcMode == nil {
			break
		}

		return e.complexity.FixtureMapping.QlcMode(childComplexity), true
	case "FixtureMapping.qlcModel":
		if e.complexity.FixtureMapping.QlcModel == nil {
			break
		}

		return e.complexity.FixtureMapping.QlcModel(childComplexity), true

	case "FixtureMappingSuggestion.fixture":
		if e.complexity.FixtureMappingSuggestion.Fixture == nil {
			break
		}

		return e.complexity.FixtureMappingSuggestion.Fixture(childComplexity), true
	case "FixtureMappingSuggestion.suggestions":
		if e.complexity.FixtureMappingSuggestion.Suggestions == nil {
			break
		}

		return e.complexity.FixtureMappingSuggestion.Suggestions(childComplexity), true

	case "FixtureMode.channelCount":
		if e.complexity.FixtureMode.ChannelCount == nil {
			break
		}

		return e.complexity.FixtureMode.ChannelCount(childComplexity), true
	case "FixtureMode.channels":
		if e.complexity.FixtureMode.Channels == nil {
			break
		}

		return e.complexity.FixtureMode.Channels(childComplexity), true
	case "FixtureMode.id":
		if e.complexity.FixtureMode.ID == nil {
			break
		}

		return e.complexity.FixtureMode.ID(childComplexity), true
	case "FixtureMode.name":
		if e.complexity.FixtureMode.Name == nil {
			break
		}

		return e.complexity.FixtureMode.Name(childComplexity), true
	case "FixtureMode.shortName":
		if e.complexity.FixtureMode.ShortName == nil {
			break
		}

		return e.complexity.FixtureMode.ShortName(childComplexity), true

	case "FixtureUsage.cues":
		if e.complexity.FixtureUsage.Cues == nil {
			break
		}

		return e.complexity.FixtureUsage.Cues(childComplexity), true
	case "FixtureUsage.fixtureId":
		if e.complexity.FixtureUsage.FixtureID == nil {
			break
		}

		return e.complexity.FixtureUsage.FixtureID(childComplexity), true
	case "FixtureUsage.fixtureName":
		if e.complexity.FixtureUsage.FixtureName == nil {
			break
		}

		return e.complexity.FixtureUsage.FixtureName(childComplexity), true
	case "FixtureUsage.scenes":
		if e.complexity.FixtureUsage.Scenes == nil {
			break
		}

		return e.complexity.FixtureUsage.Scenes(childComplexity), true

	case "FixtureValue.channels":
		if e.complexity.FixtureValue.Channels == nil {
			break
		}

		return e.complexity.FixtureValue.Channels(childComplexity), true
	case "FixtureValue.fixture":
		if e.complexity.FixtureValue.Fixture == nil {
			break
		}

		return e.complexity.FixtureValue.Fixture(childComplexity), true
	case "FixtureValue.id":
		if e.complexity.FixtureValue.ID == nil {
			break
		}

		return e.complexity.FixtureValue.ID(childComplexity), true
	case "FixtureValue.sceneOrder":
		if e.complexity.FixtureValue.SceneOrder == nil {
			break
		}

		return e.complexity.FixtureValue.SceneOrder(childComplexity), true

	case "ImportResult.projectId":
		if e.complexity.ImportResult.ProjectID == nil {
			break
		}

		return e.complexity.ImportResult.ProjectID(childComplexity), true
	case "ImportResult.stats":
		if e.complexity.ImportResult.Stats == nil {
			break
		}

		return e.complexity.ImportResult.Stats(childComplexity), true
	case "ImportResult.warnings":
		if e.complexity.ImportResult.Warnings == nil {
			break
		}

		return e.complexity.ImportResult.Warnings(childComplexity), true

	case "ImportStats.cueListsCreated":
		if e.complexity.ImportStats.CueListsCreated == nil {
			break
		}

		return e.complexity.ImportStats.CueListsCreated(childComplexity), true
	case "ImportStats.cuesCreated":
		if e.complexity.ImportStats.CuesCreated == nil {
			break
		}

		return e.complexity.ImportStats.CuesCreated(childComplexity), true
	case "ImportStats.fixtureDefinitionsCreated":
		if e.complexity.ImportStats.FixtureDefinitionsCreated == nil {
			break
		}

		return e.complexity.ImportStats.FixtureDefinitionsCreated(childComplexity), true
	case "ImportStats.fixtureInstancesCreated":
		if e.complexity.ImportStats.FixtureInstancesCreated == nil {
			break
		}

		return e.complexity.ImportStats.FixtureInstancesCreated(childComplexity), true
	case "ImportStats.scenesCreated":
		if e.complexity.ImportStats.ScenesCreated == nil {
			break
		}

		return e.complexity.ImportStats.ScenesCreated(childComplexity), true

	case "InstanceChannel.defaultValue":
		if e.complexity.InstanceChannel.DefaultValue == nil {
			break
		}

		return e.complexity.InstanceChannel.DefaultValue(childComplexity), true
	case "InstanceChannel.fadeBehavior":
		if e.complexity.InstanceChannel.FadeBehavior == nil {
			break
		}

		return e.complexity.InstanceChannel.FadeBehavior(childComplexity), true
	case "InstanceChannel.id":
		if e.complexity.InstanceChannel.ID == nil {
			break
		}

		return e.complexity.InstanceChannel.ID(childComplexity), true
	case "InstanceChannel.isDiscrete":
		if e.complexity.InstanceChannel.IsDiscrete == nil {
			break
		}

		return e.complexity.InstanceChannel.IsDiscrete(childComplexity), true
	case "InstanceChannel.maxValue":
		if e.complexity.InstanceChannel.MaxValue == nil {
			break
		}

		return e.complexity.InstanceChannel.MaxValue(childComplexity), true
	case "InstanceChannel.minValue":
		if e.complexity.InstanceChannel.MinValue == nil {
			break
		}

		return e.complexity.InstanceChannel.MinValue(childComplexity), true
	case "InstanceChannel.name":
		if e.complexity.InstanceChannel.Name == nil {
			break
		}

		return e.complexity.InstanceChannel.Name(childComplexity), true
	case "InstanceChannel.offset":
		if e.complexity.InstanceChannel.Offset == nil {
			break
		}

		return e.complexity.InstanceChannel.Offset(childComplexity), true
	case "InstanceChannel.type":
		if e.complexity.InstanceChannel.Type == nil {
			break
		}

		return e.complexity.InstanceChannel.Type(childComplexity), true

	case "LacyLightsFixture.manufacturer":
		if e.complexity.LacyLightsFixture.Manufacturer == nil {
			break
		}

		return e.complexity.LacyLightsFixture.Manufacturer(childComplexity), true
	case "LacyLightsFixture.model":
		if e.complexity.LacyLightsFixture.Model == nil {
			break
		}

		return e.complexity.LacyLightsFixture.Model(childComplexity), true

	case "ModeChannel.channel":
		if e.complexity.ModeChannel.Channel == nil {
			break
		}

		return e.complexity.ModeChannel.Channel(childComplexity), true
	case "ModeChannel.id":
		if e.complexity.ModeChannel.ID == nil {
			break
		}

		return e.complexity.ModeChannel.ID(childComplexity), true
	case "ModeChannel.offset":
		if e.complexity.ModeChannel.Offset == nil {
			break
		}

		return e.complexity.ModeChannel.Offset(childComplexity), true

	case "Mutation.activateSceneFromBoard":
		if e.complexity.Mutation.ActivateSceneFromBoard == nil {
			break
		}

		args, err := ec.field_Mutation_activateSceneFromBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ActivateSceneFromBoard(childComplexity, args["sceneBoardId"].(string), args["sceneId"].(string), args["fadeTimeOverride"].(*float64)), true
	case "Mutation.addFixturesToScene":
		if e.complexity.Mutation.AddFixturesToScene == nil {
			break
		}

		args, err := ec.field_Mutation_addFixturesToScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddFixturesToScene(childComplexity, args["sceneId"].(string), args["fixtureValues"].([]*FixtureValueInput), args["overwriteExisting"].(*bool)), true
	case "Mutation.addSceneToBoard":
		if e.complexity.Mutation.AddSceneToBoard == nil {
			break
		}

		args, err := ec.field_Mutation_addSceneToBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddSceneToBoard(childComplexity, args["input"].(CreateSceneBoardButtonInput)), true
	case "Mutation.bulkCreateCueLists":
		if e.complexity.Mutation.BulkCreateCueLists == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateCueLists_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateCueLists(childComplexity, args["input"].(BulkCueListCreateInput)), true
	case "Mutation.bulkCreateCues":
		if e.complexity.Mutation.BulkCreateCues == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateCues_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateCues(childComplexity, args["input"].(BulkCueCreateInput)), true
	case "Mutation.bulkCreateFixtureDefinitions":
		if e.complexity.Mutation.BulkCreateFixtureDefinitions == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateFixtureDefinitions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateFixtureDefinitions(childComplexity, args["input"].(BulkFixtureDefinitionCreateInput)), true
	case "Mutation.bulkCreateFixtures":
		if e.complexity.Mutation.BulkCreateFixtures == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateFixtures(childComplexity, args["input"].(BulkFixtureCreateInput)), true
	case "Mutation.bulkCreateProjects":
		if e.complexity.Mutation.BulkCreateProjects == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateProjects_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateProjects(childComplexity, args["input"].(BulkProjectCreateInput)), true
	case "Mutation.bulkCreateSceneBoardButtons":
		if e.complexity.Mutation.BulkCreateSceneBoardButtons == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateSceneBoardButtons_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateSceneBoardButtons(childComplexity, args["input"].(BulkSceneBoardButtonCreateInput)), true
	case "Mutation.bulkCreateSceneBoards":
		if e.complexity.Mutation.BulkCreateSceneBoards == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateSceneBoards_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateSceneBoards(childComplexity, args["input"].(BulkSceneBoardCreateInput)), true
	case "Mutation.bulkCreateScenes":
		if e.complexity.Mutation.BulkCreateScenes == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateScenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateScenes(childComplexity, args["input"].(BulkSceneCreateInput)), true
	case "Mutation.bulkDeleteCueLists":
		if e.complexity.Mutation.BulkDeleteCueLists == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteCueLists_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteCueLists(childComplexity, args["cueListIds"].([]string)), true
	case "Mutation.bulkDeleteCues":
		if e.complexity.Mutation.BulkDeleteCues == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteCues_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteCues(childComplexity, args["cueIds"].([]string)), true
	case "Mutation.bulkDeleteFixtureDefinitions":
		if e.complexity.Mutation.BulkDeleteFixtureDefinitions == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteFixtureDefinitions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteFixtureDefinitions(childComplexity, args["definitionIds"].([]string)), true
	case "Mutation.bulkDeleteFixtures":
		if e.complexity.Mutation.BulkDeleteFixtures == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteFixtures(childComplexity, args["fixtureIds"].([]string)), true
	case "Mutation.bulkDeleteProjects":
		if e.complexity.Mutation.BulkDeleteProjects == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteProjects_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteProjects(childComplexity, args["projectIds"].([]string)), true
	case "Mutation.bulkDeleteSceneBoardButtons":
		if e.complexity.Mutation.BulkDeleteSceneBoardButtons == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteSceneBoardButtons_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteSceneBoardButtons(childComplexity, args["buttonIds"].([]string)), true
	case "Mutation.bulkDeleteSceneBoards":
		if e.complexity.Mutation.BulkDeleteSceneBoards == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteSceneBoards_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteSceneBoards(childComplexity, args["sceneBoardIds"].([]string)), true
	case "Mutation.bulkDeleteScenes":
		if e.complexity.Mutation.BulkDeleteScenes == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteScenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteScenes(childComplexity, args["sceneIds"].([]string)), true
	case "Mutation.bulkUpdateCueLists":
		if e.complexity.Mutation.BulkUpdateCueLists == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateCueLists_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateCueLists(childComplexity, args["input"].(BulkCueListUpdateInput)), true
	case "Mutation.bulkUpdateCues":
		if e.complexity.Mutation.BulkUpdateCues == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateCues_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateCues(childComplexity, args["input"].(BulkCueUpdateInput)), true
	case "Mutation.bulkUpdateFixtureDefinitions":
		if e.complexity.Mutation.BulkUpdateFixtureDefinitions == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateFixtureDefinitions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateFixtureDefinitions(childComplexity, args["input"].(BulkFixtureDefinitionUpdateInput)), true
	case "Mutation.bulkUpdateFixtures":
		if e.complexity.Mutation.BulkUpdateFixtures == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateFixtures(childComplexity, args["input"].(BulkFixtureUpdateInput)), true
	case "Mutation.bulkUpdateInstanceChannelsFadeBehavior":
		if e.complexity.Mutation.BulkUpdateInstanceChannelsFadeBehavior == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateInstanceChannelsFadeBehavior_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateInstanceChannelsFadeBehavior(childComplexity, args["updates"].([]*ChannelFadeBehaviorInput)), true
	case "Mutation.bulkUpdateProjects":
		if e.complexity.Mutation.BulkUpdateProjects == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateProjects_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateProjects(childComplexity, args["input"].(BulkProjectUpdateInput)), true
	case "Mutation.bulkUpdateSceneBoardButtons":
		if e.complexity.Mutation.BulkUpdateSceneBoardButtons == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateSceneBoardButtons_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateSceneBoardButtons(childComplexity, args["input"].(BulkSceneBoardButtonUpdateInput)), true
	case "Mutation.bulkUpdateSceneBoards":
		if e.complexity.Mutation.BulkUpdateSceneBoards == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateSceneBoards_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateSceneBoards(childComplexity, args["input"].(BulkSceneBoardUpdateInput)), true
	case "Mutation.bulkUpdateScenes":
		if e.complexity.Mutation.BulkUpdateScenes == nil {
			break
		}

		args, err := ec.field_Mutation_bulkUpdateScenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkUpdateScenes(childComplexity, args["input"].(BulkSceneUpdateInput)), true
	case "Mutation.cancelOFLImport":
		if e.complexity.Mutation.CancelOFLImport == nil {
			break
		}

		return e.complexity.Mutation.CancelOFLImport(childComplexity), true
	case "Mutation.cancelPreviewSession":
		if e.complexity.Mutation.CancelPreviewSession == nil {
			break
		}

		args, err := ec.field_Mutation_cancelPreviewSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelPreviewSession(childComplexity, args["sessionId"].(string)), true
	case "Mutation.cloneScene":
		if e.complexity.Mutation.CloneScene == nil {
			break
		}

		args, err := ec.field_Mutation_cloneScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloneScene(childComplexity, args["sceneId"].(string), args["newName"].(string)), true
	case "Mutation.commitPreviewSession":
		if e.complexity.Mutation.CommitPreviewSession == nil {
			break
		}

		args, err := ec.field_Mutation_commitPreviewSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CommitPreviewSession(childComplexity, args["sessionId"].(string)), true
	case "Mutation.connectWiFi":
		if e.complexity.Mutation.ConnectWiFi == nil {
			break
		}

		args, err := ec.field_Mutation_connectWiFi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConnectWiFi(childComplexity, args["ssid"].(string), args["password"].(*string)), true
	case "Mutation.createCue":
		if e.complexity.Mutation.CreateCue == nil {
			break
		}

		args, err := ec.field_Mutation_createCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCue(childComplexity, args["input"].(CreateCueInput)), true
	case "Mutation.createCueList":
		if e.complexity.Mutation.CreateCueList == nil {
			break
		}

		args, err := ec.field_Mutation_createCueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCueList(childComplexity, args["input"].(CreateCueListInput)), true
	case "Mutation.createFixtureDefinition":
		if e.complexity.Mutation.CreateFixtureDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_createFixtureDefinition_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFixtureDefinition(childComplexity, args["input"].(CreateFixtureDefinitionInput)), true
	case "Mutation.createFixtureInstance":
		if e.complexity.Mutation.CreateFixtureInstance == nil {
			break
		}

		args, err := ec.field_Mutation_createFixtureInstance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFixtureInstance(childComplexity, args["input"].(CreateFixtureInstanceInput)), true
	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["input"].(CreateProjectInput)), true
	case "Mutation.createScene":
		if e.complexity.Mutation.CreateScene == nil {
			break
		}

		args, err := ec.field_Mutation_createScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateScene(childComplexity, args["input"].(CreateSceneInput)), true
	case "Mutation.createSceneBoard":
		if e.complexity.Mutation.CreateSceneBoard == nil {
			break
		}

		args, err := ec.field_Mutation_createSceneBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSceneBoard(childComplexity, args["input"].(CreateSceneBoardInput)), true
	case "Mutation.deleteCue":
		if e.complexity.Mutation.DeleteCue == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCue(childComplexity, args["id"].(string)), true
	case "Mutation.deleteCueList":
		if e.complexity.Mutation.DeleteCueList == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCueList(childComplexity, args["id"].(string)), true
	case "Mutation.deleteFixtureDefinition":
		if e.complexity.Mutation.DeleteFixtureDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFixtureDefinition_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFixtureDefinition(childComplexity, args["id"].(string)), true
	case "Mutation.deleteFixtureInstance":
		if e.complexity.Mutation.DeleteFixtureInstance == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFixtureInstance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFixtureInstance(childComplexity, args["id"].(string)), true
	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["id"].(string)), true
	case "Mutation.deleteScene":
		if e.complexity.Mutation.DeleteScene == nil {
			break
		}

		args, err := ec.field_Mutation_deleteScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteScene(childComplexity, args["id"].(string)), true
	case "Mutation.deleteSceneBoard":
		if e.complexity.Mutation.DeleteSceneBoard == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSceneBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSceneBoard(childComplexity, args["id"].(string)), true
	case "Mutation.disconnectWiFi":
		if e.complexity.Mutation.DisconnectWiFi == nil {
			break
		}

		return e.complexity.Mutation.DisconnectWiFi(childComplexity), true
	case "Mutation.duplicateScene":
		if e.complexity.Mutation.DuplicateScene == nil {
			break
		}

		args, err := ec.field_Mutation_duplicateScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DuplicateScene(childComplexity, args["id"].(string)), true
	case "Mutation.exportProject":
		if e.complexity.Mutation.ExportProject == nil {
			break
		}

		args, err := ec.field_Mutation_exportProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExportProject(childComplexity, args["projectId"].(string), args["options"].(*ExportOptionsInput)), true
	case "Mutation.exportProjectToQLC":
		if e.complexity.Mutation.ExportProjectToQlc == nil {
			break
		}

		args, err := ec.field_Mutation_exportProjectToQLC_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExportProjectToQlc(childComplexity, args["projectId"].(string), args["fixtureMappings"].([]*FixtureMappingInput)), true
	case "Mutation.fadeToBlack":
		if e.complexity.Mutation.FadeToBlack == nil {
			break
		}

		args, err := ec.field_Mutation_fadeToBlack_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FadeToBlack(childComplexity, args["fadeOutTime"].(float64)), true
	case "Mutation.forgetWiFiNetwork":
		if e.complexity.Mutation.ForgetWiFiNetwork == nil {
			break
		}

		args, err := ec.field_Mutation_forgetWiFiNetwork_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForgetWiFiNetwork(childComplexity, args["ssid"].(string)), true
	case "Mutation.goToCue":
		if e.complexity.Mutation.GoToCue == nil {
			break
		}

		args, err := ec.field_Mutation_goToCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GoToCue(childComplexity, args["cueListId"].(string), args["cueIndex"].(int), args["fadeInTime"].(*float64)), true
	case "Mutation.importOFLFixture":
		if e.complexity.Mutation.ImportOFLFixture == nil {
			break
		}

		args, err := ec.field_Mutation_importOFLFixture_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImportOFLFixture(childComplexity, args["input"].(ImportOFLFixtureInput)), true
	case "Mutation.importProject":
		if e.complexity.Mutation.ImportProject == nil {
			break
		}

		args, err := ec.field_Mutation_importProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImportProject(childComplexity, args["jsonContent"].(string), args["options"].(ImportOptionsInput)), true
	case "Mutation.importProjectFromQLC":
		if e.complexity.Mutation.ImportProjectFromQlc == nil {
			break
		}

		args, err := ec.field_Mutation_importProjectFromQLC_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImportProjectFromQlc(childComplexity, args["xmlContent"].(string), args["originalFileName"].(string)), true
	case "Mutation.initializePreviewWithScene":
		if e.complexity.Mutation.InitializePreviewWithScene == nil {
			break
		}

		args, err := ec.field_Mutation_initializePreviewWithScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InitializePreviewWithScene(childComplexity, args["sessionId"].(string), args["sceneId"].(string)), true
	case "Mutation.nextCue":
		if e.complexity.Mutation.NextCue == nil {
			break
		}

		args, err := ec.field_Mutation_nextCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NextCue(childComplexity, args["cueListId"].(string), args["fadeInTime"].(*float64)), true
	case "Mutation.playCue":
		if e.complexity.Mutation.PlayCue == nil {
			break
		}

		args, err := ec.field_Mutation_playCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PlayCue(childComplexity, args["cueId"].(string), args["fadeInTime"].(*float64)), true
	case "Mutation.previousCue":
		if e.complexity.Mutation.PreviousCue == nil {
			break
		}

		args, err := ec.field_Mutation_previousCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PreviousCue(childComplexity, args["cueListId"].(string), args["fadeInTime"].(*float64)), true
	case "Mutation.removeFixturesFromScene":
		if e.complexity.Mutation.RemoveFixturesFromScene == nil {
			break
		}

		args, err := ec.field_Mutation_removeFixturesFromScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveFixturesFromScene(childComplexity, args["sceneId"].(string), args["fixtureIds"].([]string)), true
	case "Mutation.removeSceneFromBoard":
		if e.complexity.Mutation.RemoveSceneFromBoard == nil {
			break
		}

		args, err := ec.field_Mutation_removeSceneFromBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveSceneFromBoard(childComplexity, args["buttonId"].(string)), true
	case "Mutation.reorderCues":
		if e.complexity.Mutation.ReorderCues == nil {
			break
		}

		args, err := ec.field_Mutation_reorderCues_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReorderCues(childComplexity, args["cueListId"].(string), args["cueOrders"].([]*CueOrderInput)), true
	case "Mutation.reorderProjectFixtures":
		if e.complexity.Mutation.ReorderProjectFixtures == nil {
			break
		}

		args, err := ec.field_Mutation_reorderProjectFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReorderProjectFixtures(childComplexity, args["projectId"].(string), args["fixtureOrders"].([]*FixtureOrderInput)), true
	case "Mutation.reorderSceneFixtures":
		if e.complexity.Mutation.ReorderSceneFixtures == nil {
			break
		}

		args, err := ec.field_Mutation_reorderSceneFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReorderSceneFixtures(childComplexity, args["sceneId"].(string), args["fixtureOrders"].([]*FixtureOrderInput)), true
	case "Mutation.setChannelValue":
		if e.complexity.Mutation.SetChannelValue == nil {
			break
		}

		args, err := ec.field_Mutation_setChannelValue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetChannelValue(childComplexity, args["universe"].(int), args["channel"].(int), args["value"].(int)), true
	case "Mutation.setSceneLive":
		if e.complexity.Mutation.SetSceneLive == nil {
			break
		}

		args, err := ec.field_Mutation_setSceneLive_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetSceneLive(childComplexity, args["sceneId"].(string)), true
	case "Mutation.setWiFiEnabled":
		if e.complexity.Mutation.SetWiFiEnabled == nil {
			break
		}

		args, err := ec.field_Mutation_setWiFiEnabled_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetWiFiEnabled(childComplexity, args["enabled"].(bool)), true
	case "Mutation.startCueList":
		if e.complexity.Mutation.StartCueList == nil {
			break
		}

		args, err := ec.field_Mutation_startCueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartCueList(childComplexity, args["cueListId"].(string), args["startFromCue"].(*int), args["fadeInTime"].(*float64)), true
	case "Mutation.startPreviewSession":
		if e.complexity.Mutation.StartPreviewSession == nil {
			break
		}

		args, err := ec.field_Mutation_startPreviewSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartPreviewSession(childComplexity, args["projectId"].(string)), true
	case "Mutation.stopCueList":
		if e.complexity.Mutation.StopCueList == nil {
			break
		}

		args, err := ec.field_Mutation_stopCueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StopCueList(childComplexity, args["cueListId"].(string)), true
	case "Mutation.triggerOFLImport":
		if e.complexity.Mutation.TriggerOFLImport == nil {
			break
		}

		args, err := ec.field_Mutation_triggerOFLImport_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TriggerOFLImport(childComplexity, args["options"].(*OFLImportOptionsInput)), true
	case "Mutation.updateAllRepositories":
		if e.complexity.Mutation.UpdateAllRepositories == nil {
			break
		}

		return e.complexity.Mutation.UpdateAllRepositories(childComplexity), true
	case "Mutation.updateCue":
		if e.complexity.Mutation.UpdateCue == nil {
			break
		}

		args, err := ec.field_Mutation_updateCue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCue(childComplexity, args["id"].(string), args["input"].(CreateCueInput)), true
	case "Mutation.updateCueList":
		if e.complexity.Mutation.UpdateCueList == nil {
			break
		}

		args, err := ec.field_Mutation_updateCueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCueList(childComplexity, args["id"].(string), args["input"].(CreateCueListInput)), true
	case "Mutation.updateFixtureDefinition":
		if e.complexity.Mutation.UpdateFixtureDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateFixtureDefinition_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFixtureDefinition(childComplexity, args["id"].(string), args["input"].(CreateFixtureDefinitionInput)), true
	case "Mutation.updateFixtureInstance":
		if e.complexity.Mutation.UpdateFixtureInstance == nil {
			break
		}

		args, err := ec.field_Mutation_updateFixtureInstance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFixtureInstance(childComplexity, args["id"].(string), args["input"].(UpdateFixtureInstanceInput)), true
	case "Mutation.updateFixturePositions":
		if e.complexity.Mutation.UpdateFixturePositions == nil {
			break
		}

		args, err := ec.field_Mutation_updateFixturePositions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFixturePositions(childComplexity, args["positions"].([]*FixturePositionInput)), true
	case "Mutation.updateInstanceChannelFadeBehavior":
		if e.complexity.Mutation.UpdateInstanceChannelFadeBehavior == nil {
			break
		}

		args, err := ec.field_Mutation_updateInstanceChannelFadeBehavior_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInstanceChannelFadeBehavior(childComplexity, args["channelId"].(string), args["fadeBehavior"].(FadeBehavior)), true
	case "Mutation.updatePreviewChannel":
		if e.complexity.Mutation.UpdatePreviewChannel == nil {
			break
		}

		args, err := ec.field_Mutation_updatePreviewChannel_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePreviewChannel(childComplexity, args["sessionId"].(string), args["fixtureId"].(string), args["channelIndex"].(int), args["value"].(int)), true
	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["id"].(string), args["input"].(CreateProjectInput)), true
	case "Mutation.updateRepository":
		if e.complexity.Mutation.UpdateRepository == nil {
			break
		}

		args, err := ec.field_Mutation_updateRepository_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRepository(childComplexity, args["repository"].(string), args["version"].(*string)), true
	case "Mutation.updateScene":
		if e.complexity.Mutation.UpdateScene == nil {
			break
		}

		args, err := ec.field_Mutation_updateScene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateScene(childComplexity, args["id"].(string), args["input"].(UpdateSceneInput)), true
	case "Mutation.updateSceneBoard":
		if e.complexity.Mutation.UpdateSceneBoard == nil {
			break
		}

		args, err := ec.field_Mutation_updateSceneBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSceneBoard(childComplexity, args["id"].(string), args["input"].(UpdateSceneBoardInput)), true
	case "Mutation.updateSceneBoardButton":
		if e.complexity.Mutation.UpdateSceneBoardButton == nil {
			break
		}

		args, err := ec.field_Mutation_updateSceneBoardButton_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSceneBoardButton(childComplexity, args["id"].(string), args["input"].(UpdateSceneBoardButtonInput)), true
	case "Mutation.updateSceneBoardButtonPositions":
		if e.complexity.Mutation.UpdateSceneBoardButtonPositions == nil {
			break
		}

		args, err := ec.field_Mutation_updateSceneBoardButtonPositions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSceneBoardButtonPositions(childComplexity, args["positions"].([]*SceneBoardButtonPositionInput)), true
	case "Mutation.updateScenePartial":
		if e.complexity.Mutation.UpdateScenePartial == nil {
			break
		}

		args, err := ec.field_Mutation_updateScenePartial_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateScenePartial(childComplexity, args["sceneId"].(string), args["name"].(*string), args["description"].(*string), args["fixtureValues"].([]*FixtureValueInput), args["mergeFixtures"].(*bool)), true
	case "Mutation.updateSetting":
		if e.complexity.Mutation.UpdateSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSetting(childComplexity, args["input"].(UpdateSettingInput)), true

	case "NetworkInterfaceOption.address":
		if e.complexity.NetworkInterfaceOption.Address == nil {
			break
		}

		return e.complexity.NetworkInterfaceOption.Address(childComplexity), true
	case "NetworkInterfaceOption.broadcast":
		if e.complexity.NetworkInterfaceOption.Broadcast == nil {
			break
		}

		return e.complexity.NetworkInterfaceOption.Broadcast(childComplexity), true
	case "NetworkInterfaceOption.description":
		if e.complexity.NetworkInterfaceOption.Description == nil {
			break
		}

		return e.complexity.NetworkInterfaceOption.Description(childComplexity), true
	case "NetworkInterfaceOption.interfaceType":
		if e.complexity.NetworkInterfaceOption.InterfaceType == nil {
			break
		}

		return e.complexity.NetworkInterfaceOption.InterfaceType(childComplexity), true
	case "NetworkInterfaceOption.name":
		if e.complexity.NetworkInterfaceOption.Name == nil {
			break
		}

		return e.complexity.NetworkInterfaceOption.Name(childComplexity), true

	case "OFLFixtureUpdate.changeType":
		if e.complexity.OFLFixtureUpdate.ChangeType == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.ChangeType(childComplexity), true
	case "OFLFixtureUpdate.currentHash":
		if e.complexity.OFLFixtureUpdate.CurrentHash == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.CurrentHash(childComplexity), true
	case "OFLFixtureUpdate.fixtureKey":
		if e.complexity.OFLFixtureUpdate.FixtureKey == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.FixtureKey(childComplexity), true
	case "OFLFixtureUpdate.instanceCount":
		if e.complexity.OFLFixtureUpdate.InstanceCount == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.InstanceCount(childComplexity), true
	case "OFLFixtureUpdate.isInUse":
		if e.complexity.OFLFixtureUpdate.IsInUse == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.IsInUse(childComplexity), true
	case "OFLFixtureUpdate.manufacturer":
		if e.complexity.OFLFixtureUpdate.Manufacturer == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.Manufacturer(childComplexity), true
	case "OFLFixtureUpdate.model":
		if e.complexity.OFLFixtureUpdate.Model == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.Model(childComplexity), true
	case "OFLFixtureUpdate.newHash":
		if e.complexity.OFLFixtureUpdate.NewHash == nil {
			break
		}

		return e.complexity.OFLFixtureUpdate.NewHash(childComplexity), true

	case "OFLImportResult.errorMessage":
		if e.complexity.OFLImportResult.ErrorMessage == nil {
			break
		}

		return e.complexity.OFLImportResult.ErrorMessage(childComplexity), true
	case "OFLImportResult.oflVersion":
		if e.complexity.OFLImportResult.OflVersion == nil {
			break
		}

		return e.complexity.OFLImportResult.OflVersion(childComplexity), true
	case "OFLImportResult.stats":
		if e.complexity.OFLImportResult.Stats == nil {
			break
		}

		return e.complexity.OFLImportResult.Stats(childComplexity), true
	case "OFLImportResult.success":
		if e.complexity.OFLImportResult.Success == nil {
			break
		}

		return e.complexity.OFLImportResult.Success(childComplexity), true

	case "OFLImportStats.durationSeconds":
		if e.complexity.OFLImportStats.DurationSeconds == nil {
			break
		}

		return e.complexity.OFLImportStats.DurationSeconds(childComplexity), true
	case "OFLImportStats.failedImports":
		if e.complexity.OFLImportStats.FailedImports == nil {
			break
		}

		return e.complexity.OFLImportStats.FailedImports(childComplexity), true
	case "OFLImportStats.skippedDuplicates":
		if e.complexity.OFLImportStats.SkippedDuplicates == nil {
			break
		}

		return e.complexity.OFLImportStats.SkippedDuplicates(childComplexity), true
	case "OFLImportStats.successfulImports":
		if e.complexity.OFLImportStats.SuccessfulImports == nil {
			break
		}

		return e.complexity.OFLImportStats.SuccessfulImports(childComplexity), true
	case "OFLImportStats.totalProcessed":
		if e.complexity.OFLImportStats.TotalProcessed == nil {
			break
		}

		return e.complexity.OFLImportStats.TotalProcessed(childComplexity), true
	case "OFLImportStats.updatedFixtures":
		if e.complexity.OFLImportStats.UpdatedFixtures == nil {
			break
		}

		return e.complexity.OFLImportStats.UpdatedFixtures(childComplexity), true

	case "OFLImportStatus.completedAt":
		if e.complexity.OFLImportStatus.CompletedAt == nil {
			break
		}

		return e.complexity.OFLImportStatus.CompletedAt(childComplexity), true
	case "OFLImportStatus.currentFixture":
		if e.complexity.OFLImportStatus.CurrentFixture == nil {
			break
		}

		return e.complexity.OFLImportStatus.CurrentFixture(childComplexity), true
	case "OFLImportStatus.currentManufacturer":
		if e.complexity.OFLImportStatus.CurrentManufacturer == nil {
			break
		}

		return e.complexity.OFLImportStatus.CurrentManufacturer(childComplexity), true
	case "OFLImportStatus.errorMessage":
		if e.complexity.OFLImportStatus.ErrorMessage == nil {
			break
		}

		return e.complexity.OFLImportStatus.ErrorMessage(childComplexity), true
	case "OFLImportStatus.estimatedSecondsRemaining":
		if e.complexity.OFLImportStatus.EstimatedSecondsRemaining == nil {
			break
		}

		return e.complexity.OFLImportStatus.EstimatedSecondsRemaining(childComplexity), true
	case "OFLImportStatus.failedCount":
		if e.complexity.OFLImportStatus.FailedCount == nil {
			break
		}

		return e.complexity.OFLImportStatus.FailedCount(childComplexity), true
	case "OFLImportStatus.importedCount":
		if e.complexity.OFLImportStatus.ImportedCount == nil {
			break
		}

		return e.complexity.OFLImportStatus.ImportedCount(childComplexity), true
	case "OFLImportStatus.isImporting":
		if e.complexity.OFLImportStatus.IsImporting == nil {
			break
		}

		return e.complexity.OFLImportStatus.IsImporting(childComplexity), true
	case "OFLImportStatus.oflVersion":
		if e.complexity.OFLImportStatus.OflVersion == nil {
			break
		}

		return e.complexity.OFLImportStatus.OflVersion(childComplexity), true
	case "OFLImportStatus.percentComplete":
		if e.complexity.OFLImportStatus.PercentComplete == nil {
			break
		}

		return e.complexity.OFLImportStatus.PercentComplete(childComplexity), true
	case "OFLImportStatus.phase":
		if e.complexity.OFLImportStatus.Phase == nil {
			break
		}

		return e.complexity.OFLImportStatus.Phase(childComplexity), true
	case "OFLImportStatus.skippedCount":
		if e.complexity.OFLImportStatus.SkippedCount == nil {
			break
		}

		return e.complexity.OFLImportStatus.SkippedCount(childComplexity), true
	case "OFLImportStatus.startedAt":
		if e.complexity.OFLImportStatus.StartedAt == nil {
			break
		}

		return e.complexity.OFLImportStatus.StartedAt(childComplexity), true
	case "OFLImportStatus.totalFixtures":
		if e.complexity.OFLImportStatus.TotalFixtures == nil {
			break
		}

		return e.complexity.OFLImportStatus.TotalFixtures(childComplexity), true
	case "OFLImportStatus.usingBundledData":
		if e.complexity.OFLImportStatus.UsingBundledData == nil {
			break
		}

		return e.complexity.OFLImportStatus.UsingBundledData(childComplexity), true

	case "OFLUpdateCheckResult.changedFixtureCount":
		if e.complexity.OFLUpdateCheckResult.ChangedFixtureCount == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.ChangedFixtureCount(childComplexity), true
	case "OFLUpdateCheckResult.changedInUseCount":
		if e.complexity.OFLUpdateCheckResult.ChangedInUseCount == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.ChangedInUseCount(childComplexity), true
	case "OFLUpdateCheckResult.checkedAt":
		if e.complexity.OFLUpdateCheckResult.CheckedAt == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.CheckedAt(childComplexity), true
	case "OFLUpdateCheckResult.currentFixtureCount":
		if e.complexity.OFLUpdateCheckResult.CurrentFixtureCount == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.CurrentFixtureCount(childComplexity), true
	case "OFLUpdateCheckResult.fixtureUpdates":
		if e.complexity.OFLUpdateCheckResult.FixtureUpdates == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.FixtureUpdates(childComplexity), true
	case "OFLUpdateCheckResult.newFixtureCount":
		if e.complexity.OFLUpdateCheckResult.NewFixtureCount == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.NewFixtureCount(childComplexity), true
	case "OFLUpdateCheckResult.oflFixtureCount":
		if e.complexity.OFLUpdateCheckResult.OflFixtureCount == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.OflFixtureCount(childComplexity), true
	case "OFLUpdateCheckResult.oflVersion":
		if e.complexity.OFLUpdateCheckResult.OflVersion == nil {
			break
		}

		return e.complexity.OFLUpdateCheckResult.OflVersion(childComplexity), true

	case "PaginationInfo.hasMore":
		if e.complexity.PaginationInfo.HasMore == nil {
			break
		}

		return e.complexity.PaginationInfo.HasMore(childComplexity), true
	case "PaginationInfo.page":
		if e.complexity.PaginationInfo.Page == nil {
			break
		}

		return e.complexity.PaginationInfo.Page(childComplexity), true
	case "PaginationInfo.perPage":
		if e.complexity.PaginationInfo.PerPage == nil {
			break
		}

		return e.complexity.PaginationInfo.PerPage(childComplexity), true
	case "PaginationInfo.total":
		if e.complexity.PaginationInfo.Total == nil {
			break
		}

		return e.complexity.PaginationInfo.Total(childComplexity), true
	case "PaginationInfo.totalPages":
		if e.complexity.PaginationInfo.TotalPages == nil {
			break
		}

		return e.complexity.PaginationInfo.TotalPages(childComplexity), true

	case "PreviewSession.createdAt":
		if e.complexity.PreviewSession.CreatedAt == nil {
			break
		}

		return e.complexity.PreviewSession.CreatedAt(childComplexity), true
	case "PreviewSession.dmxOutput":
		if e.complexity.PreviewSession.DmxOutput == nil {
			break
		}

		return e.complexity.PreviewSession.DmxOutput(childComplexity), true
	case "PreviewSession.id":
		if e.complexity.PreviewSession.ID == nil {
			break
		}

		return e.complexity.PreviewSession.ID(childComplexity), true
	case "PreviewSession.isActive":
		if e.complexity.PreviewSession.IsActive == nil {
			break
		}

		return e.complexity.PreviewSession.IsActive(childComplexity), true
	case "PreviewSession.project":
		if e.complexity.PreviewSession.Project == nil {
			break
		}

		return e.complexity.PreviewSession.Project(childComplexity), true
	case "PreviewSession.user":
		if e.complexity.PreviewSession.User == nil {
			break
		}

		return e.complexity.PreviewSession.User(childComplexity), true

	case "Project.createdAt":
		if e.complexity.Project.CreatedAt == nil {
			break
		}

		return e.complexity.Project.CreatedAt(childComplexity), true
	case "Project.cueListCount":
		if e.complexity.Project.CueListCount == nil {
			break
		}

		return e.complexity.Project.CueListCount(childComplexity), true
	case "Project.cueLists":
		if e.complexity.Project.CueLists == nil {
			break
		}

		return e.complexity.Project.CueLists(childComplexity), true
	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true
	case "Project.fixtureCount":
		if e.complexity.Project.FixtureCount == nil {
			break
		}

		return e.complexity.Project.FixtureCount(childComplexity), true
	case "Project.fixtures":
		if e.complexity.Project.Fixtures == nil {
			break
		}

		return e.complexity.Project.Fixtures(childComplexity), true
	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true
	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true
	case "Project.sceneBoards":
		if e.complexity.Project.SceneBoards == nil {
			break
		}

		return e.complexity.Project.SceneBoards(childComplexity), true
	case "Project.sceneCount":
		if e.complexity.Project.SceneCount == nil {
			break
		}

		return e.complexity.Project.SceneCount(childComplexity), true
	case "Project.scenes":
		if e.complexity.Project.Scenes == nil {
			break
		}

		return e.complexity.Project.Scenes(childComplexity), true
	case "Project.updatedAt":
		if e.complexity.Project.UpdatedAt == nil {
			break
		}

		return e.complexity.Project.UpdatedAt(childComplexity), true
	case "Project.users":
		if e.complexity.Project.Users == nil {
			break
		}

		return e.complexity.Project.Users(childComplexity), true

	case "ProjectUser.id":
		if e.complexity.ProjectUser.ID == nil {
			break
		}

		return e.complexity.ProjectUser.ID(childComplexity), true
	case "ProjectUser.joinedAt":
		if e.complexity.ProjectUser.JoinedAt == nil {
			break
		}

		return e.complexity.ProjectUser.JoinedAt(childComplexity), true
	case "ProjectUser.project":
		if e.complexity.ProjectUser.Project == nil {
			break
		}

		return e.complexity.ProjectUser.Project(childComplexity), true
	case "ProjectUser.role":
		if e.complexity.ProjectUser.Role == nil {
			break
		}

		return e.complexity.ProjectUser.Role(childComplexity), true
	case "ProjectUser.user":
		if e.complexity.ProjectUser.User == nil {
			break
		}

		return e.complexity.ProjectUser.User(childComplexity), true

	case "QLCExportResult.cueListCount":
		if e.complexity.QLCExportResult.CueListCount == nil {
			break
		}

		return e.complexity.QLCExportResult.CueListCount(childComplexity), true
	case "QLCExportResult.fixtureCount":
		if e.complexity.QLCExportResult.FixtureCount == nil {
			break
		}

		return e.complexity.QLCExportResult.FixtureCount(childComplexity), true
	case "QLCExportResult.projectName":
		if e.complexity.QLCExportResult.ProjectName == nil {
			break
		}

		return e.complexity.QLCExportResult.ProjectName(childComplexity), true
	case "QLCExportResult.sceneCount":
		if e.complexity.QLCExportResult.SceneCount == nil {
			break
		}

		return e.complexity.QLCExportResult.SceneCount(childComplexity), true
	case "QLCExportResult.xmlContent":
		if e.complexity.QLCExportResult.XMLContent == nil {
			break
		}

		return e.complexity.QLCExportResult.XMLContent(childComplexity), true

	case "QLCFixtureDefinition.manufacturer":
		if e.complexity.QLCFixtureDefinition.Manufacturer == nil {
			break
		}

		return e.complexity.QLCFixtureDefinition.Manufacturer(childComplexity), true
	case "QLCFixtureDefinition.model":
		if e.complexity.QLCFixtureDefinition.Model == nil {
			break
		}

		return e.complexity.QLCFixtureDefinition.Model(childComplexity), true
	case "QLCFixtureDefinition.modes":
		if e.complexity.QLCFixtureDefinition.Modes == nil {
			break
		}

		return e.complexity.QLCFixtureDefinition.Modes(childComplexity), true
	case "QLCFixtureDefinition.type":
		if e.complexity.QLCFixtureDefinition.Type == nil {
			break
		}

		return e.complexity.QLCFixtureDefinition.Type(childComplexity), true

	case "QLCFixtureMappingResult.defaultMappings":
		if e.complexity.QLCFixtureMappingResult.DefaultMappings == nil {
			break
		}

		return e.complexity.QLCFixtureMappingResult.DefaultMappings(childComplexity), true
	case "QLCFixtureMappingResult.lacyLightsFixtures":
		if e.complexity.QLCFixtureMappingResult.LacyLightsFixtures == nil {
			break
		}

		return e.complexity.QLCFixtureMappingResult.LacyLightsFixtures(childComplexity), true
	case "QLCFixtureMappingResult.projectId":
		if e.complexity.QLCFixtureMappingResult.ProjectID == nil {
			break
		}

		return e.complexity.QLCFixtureMappingResult.ProjectID(childComplexity), true
	case "QLCFixtureMappingResult.suggestions":
		if e.complexity.QLCFixtureMappingResult.Suggestions == nil {
			break
		}

		return e.complexity.QLCFixtureMappingResult.Suggestions(childComplexity), true

	case "QLCFixtureMode.channelCount":
		if e.complexity.QLCFixtureMode.ChannelCount == nil {
			break
		}

		return e.complexity.QLCFixtureMode.ChannelCount(childComplexity), true
	case "QLCFixtureMode.name":
		if e.complexity.QLCFixtureMode.Name == nil {
			break
		}

		return e.complexity.QLCFixtureMode.Name(childComplexity), true

	case "QLCImportResult.cueListCount":
		if e.complexity.QLCImportResult.CueListCount == nil {
			break
		}

		return e.complexity.QLCImportResult.CueListCount(childComplexity), true
	case "QLCImportResult.fixtureCount":
		if e.complexity.QLCImportResult.FixtureCount == nil {
			break
		}

		return e.complexity.QLCImportResult.FixtureCount(childComplexity), true
	case "QLCImportResult.originalFileName":
		if e.complexity.QLCImportResult.OriginalFileName == nil {
			break
		}

		return e.complexity.QLCImportResult.OriginalFileName(childComplexity), true
	case "QLCImportResult.project":
		if e.complexity.QLCImportResult.Project == nil {
			break
		}

		return e.complexity.QLCImportResult.Project(childComplexity), true
	case "QLCImportResult.sceneCount":
		if e.complexity.QLCImportResult.SceneCount == nil {
			break
		}

		return e.complexity.QLCImportResult.SceneCount(childComplexity), true
	case "QLCImportResult.warnings":
		if e.complexity.QLCImportResult.Warnings == nil {
			break
		}

		return e.complexity.QLCImportResult.Warnings(childComplexity), true

	case "Query.allDmxOutput":
		if e.complexity.Query.AllDmxOutput == nil {
			break
		}

		return e.complexity.Query.AllDmxOutput(childComplexity), true
	case "Query.availableVersions":
		if e.complexity.Query.AvailableVersions == nil {
			break
		}

		args, err := ec.field_Query_availableVersions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AvailableVersions(childComplexity, args["repository"].(string)), true
	case "Query.channelMap":
		if e.complexity.Query.ChannelMap == nil {
			break
		}

		args, err := ec.field_Query_channelMap_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChannelMap(childComplexity, args["projectId"].(string), args["universe"].(*int)), true
	case "Query.checkOFLUpdates":
		if e.complexity.Query.CheckOFLUpdates == nil {
			break
		}

		return e.complexity.Query.CheckOFLUpdates(childComplexity), true
	case "Query.compareScenes":
		if e.complexity.Query.CompareScenes == nil {
			break
		}

		args, err := ec.field_Query_compareScenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CompareScenes(childComplexity, args["sceneId1"].(string), args["sceneId2"].(string)), true
	case "Query.cue":
		if e.complexity.Query.Cue == nil {
			break
		}

		args, err := ec.field_Query_cue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cue(childComplexity, args["id"].(string)), true
	case "Query.cueList":
		if e.complexity.Query.CueList == nil {
			break
		}

		args, err := ec.field_Query_cueList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CueList(childComplexity, args["id"].(string), args["page"].(*int), args["perPage"].(*int), args["includeSceneDetails"].(*bool)), true
	case "Query.cueListPlaybackStatus":
		if e.complexity.Query.CueListPlaybackStatus == nil {
			break
		}

		args, err := ec.field_Query_cueListPlaybackStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CueListPlaybackStatus(childComplexity, args["cueListId"].(string)), true
	case "Query.cueLists":
		if e.complexity.Query.CueLists == nil {
			break
		}

		args, err := ec.field_Query_cueLists_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CueLists(childComplexity, args["projectId"].(string)), true
	case "Query.cueListsByIds":
		if e.complexity.Query.CueListsByIds == nil {
			break
		}

		args, err := ec.field_Query_cueListsByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CueListsByIds(childComplexity, args["ids"].([]string)), true
	case "Query.cuesByIds":
		if e.complexity.Query.CuesByIds == nil {
			break
		}

		args, err := ec.field_Query_cuesByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CuesByIds(childComplexity, args["ids"].([]string)), true
	case "Query.currentActiveScene":
		if e.complexity.Query.CurrentActiveScene == nil {
			break
		}

		return e.complexity.Query.CurrentActiveScene(childComplexity), true
	case "Query.dmxOutput":
		if e.complexity.Query.DmxOutput == nil {
			break
		}

		args, err := ec.field_Query_dmxOutput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DmxOutput(childComplexity, args["universe"].(int)), true
	case "Query.fixtureDefinition":
		if e.complexity.Query.FixtureDefinition == nil {
			break
		}

		args, err := ec.field_Query_fixtureDefinition_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureDefinition(childComplexity, args["id"].(string)), true
	case "Query.fixtureDefinitions":
		if e.complexity.Query.FixtureDefinitions == nil {
			break
		}

		args, err := ec.field_Query_fixtureDefinitions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureDefinitions(childComplexity, args["filter"].(*FixtureDefinitionFilter)), true
	case "Query.fixtureDefinitionsByIds":
		if e.complexity.Query.FixtureDefinitionsByIds == nil {
			break
		}

		args, err := ec.field_Query_fixtureDefinitionsByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureDefinitionsByIds(childComplexity, args["ids"].([]string)), true
	case "Query.fixtureInstance":
		if e.complexity.Query.FixtureInstance == nil {
			break
		}

		args, err := ec.field_Query_fixtureInstance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureInstance(childComplexity, args["id"].(string)), true
	case "Query.fixtureInstances":
		if e.complexity.Query.FixtureInstances == nil {
			break
		}

		args, err := ec.field_Query_fixtureInstances_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureInstances(childComplexity, args["projectId"].(string), args["page"].(*int), args["perPage"].(*int), args["filter"].(*FixtureFilterInput)), true
	case "Query.fixtureUsage":
		if e.complexity.Query.FixtureUsage == nil {
			break
		}

		args, err := ec.field_Query_fixtureUsage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixtureUsage(childComplexity, args["fixtureId"].(string)), true
	case "Query.fixturesByIds":
		if e.complexity.Query.FixturesByIds == nil {
			break
		}

		args, err := ec.field_Query_fixturesByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FixturesByIds(childComplexity, args["ids"].([]string)), true
	case "Query.getQLCFixtureMappingSuggestions":
		if e.complexity.Query.GetQLCFixtureMappingSuggestions == nil {
			break
		}

		args, err := ec.field_Query_getQLCFixtureMappingSuggestions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetQLCFixtureMappingSuggestions(childComplexity, args["projectId"].(string)), true
	case "Query.networkInterfaceOptions":
		if e.complexity.Query.NetworkInterfaceOptions == nil {
			break
		}

		return e.complexity.Query.NetworkInterfaceOptions(childComplexity), true
	case "Query.oflImportStatus":
		if e.complexity.Query.OflImportStatus == nil {
			break
		}

		return e.complexity.Query.OflImportStatus(childComplexity), true
	case "Query.previewSession":
		if e.complexity.Query.PreviewSession == nil {
			break
		}

		args, err := ec.field_Query_previewSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreviewSession(childComplexity, args["sessionId"].(string)), true
	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["id"].(string)), true
	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true
	case "Query.projectsByIds":
		if e.complexity.Query.ProjectsByIds == nil {
			break
		}

		args, err := ec.field_Query_projectsByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectsByIds(childComplexity, args["ids"].([]string)), true
	case "Query.savedWifiNetworks":
		if e.complexity.Query.SavedWifiNetworks == nil {
			break
		}

		return e.complexity.Query.SavedWifiNetworks(childComplexity), true
	case "Query.scene":
		if e.complexity.Query.Scene == nil {
			break
		}

		args, err := ec.field_Query_scene_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Scene(childComplexity, args["id"].(string), args["includeFixtureValues"].(*bool)), true
	case "Query.sceneBoard":
		if e.complexity.Query.SceneBoard == nil {
			break
		}

		args, err := ec.field_Query_sceneBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneBoard(childComplexity, args["id"].(string)), true
	case "Query.sceneBoardButton":
		if e.complexity.Query.SceneBoardButton == nil {
			break
		}

		args, err := ec.field_Query_sceneBoardButton_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneBoardButton(childComplexity, args["id"].(string)), true
	case "Query.sceneBoards":
		if e.complexity.Query.SceneBoards == nil {
			break
		}

		args, err := ec.field_Query_sceneBoards_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneBoards(childComplexity, args["projectId"].(string)), true
	case "Query.sceneBoardsByIds":
		if e.complexity.Query.SceneBoardsByIds == nil {
			break
		}

		args, err := ec.field_Query_sceneBoardsByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneBoardsByIds(childComplexity, args["ids"].([]string)), true
	case "Query.sceneFixtures":
		if e.complexity.Query.SceneFixtures == nil {
			break
		}

		args, err := ec.field_Query_sceneFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneFixtures(childComplexity, args["sceneId"].(string)), true
	case "Query.sceneUsage":
		if e.complexity.Query.SceneUsage == nil {
			break
		}

		args, err := ec.field_Query_sceneUsage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneUsage(childComplexity, args["sceneId"].(string)), true
	case "Query.scenes":
		if e.complexity.Query.Scenes == nil {
			break
		}

		args, err := ec.field_Query_scenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Scenes(childComplexity, args["projectId"].(string), args["page"].(*int), args["perPage"].(*int), args["filter"].(*SceneFilterInput), args["sortBy"].(*SceneSortField)), true
	case "Query.scenesByIds":
		if e.complexity.Query.ScenesByIds == nil {
			break
		}

		args, err := ec.field_Query_scenesByIds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScenesByIds(childComplexity, args["ids"].([]string)), true
	case "Query.searchCues":
		if e.complexity.Query.SearchCues == nil {
			break
		}

		args, err := ec.field_Query_searchCues_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchCues(childComplexity, args["cueListId"].(string), args["query"].(string), args["page"].(*int), args["perPage"].(*int)), true
	case "Query.searchFixtures":
		if e.complexity.Query.SearchFixtures == nil {
			break
		}

		args, err := ec.field_Query_searchFixtures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchFixtures(childComplexity, args["projectId"].(string), args["query"].(string), args["filter"].(*FixtureFilterInput), args["page"].(*int), args["perPage"].(*int)), true
	case "Query.searchScenes":
		if e.complexity.Query.SearchScenes == nil {
			break
		}

		args, err := ec.field_Query_searchScenes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchScenes(childComplexity, args["projectId"].(string), args["query"].(string), args["filter"].(*SceneFilterInput), args["page"].(*int), args["perPage"].(*int)), true
	case "Query.setting":
		if e.complexity.Query.Setting == nil {
			break
		}

		args, err := ec.field_Query_setting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Setting(childComplexity, args["key"].(string)), true
	case "Query.settings":
		if e.complexity.Query.Settings == nil {
			break
		}

		return e.complexity.Query.Settings(childComplexity), true
	case "Query.suggestChannelAssignment":
		if e.complexity.Query.SuggestChannelAssignment == nil {
			break
		}

		args, err := ec.field_Query_suggestChannelAssignment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SuggestChannelAssignment(childComplexity, args["input"].(ChannelAssignmentInput)), true
	case "Query.systemInfo":
		if e.complexity.Query.SystemInfo == nil {
			break
		}

		return e.complexity.Query.SystemInfo(childComplexity), true
	case "Query.systemVersions":
		if e.complexity.Query.SystemVersions == nil {
			break
		}

		return e.complexity.Query.SystemVersions(childComplexity), true
	case "Query.wifiNetworks":
		if e.complexity.Query.WifiNetworks == nil {
			break
		}

		args, err := ec.field_Query_wifiNetworks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WifiNetworks(childComplexity, args["rescan"].(*bool), args["deduplicate"].(*bool)), true
	case "Query.wifiStatus":
		if e.complexity.Query.WifiStatus == nil {
			break
		}

		return e.complexity.Query.WifiStatus(childComplexity), true

	case "RepositoryVersion.installed":
		if e.complexity.RepositoryVersion.Installed == nil {
			break
		}

		return e.complexity.RepositoryVersion.Installed(childComplexity), true
	case "RepositoryVersion.latest":
		if e.complexity.RepositoryVersion.Latest == nil {
			break
		}

		return e.complexity.RepositoryVersion.Latest(childComplexity), true
	case "RepositoryVersion.repository":
		if e.complexity.RepositoryVersion.Repository == nil {
			break
		}

		return e.complexity.RepositoryVersion.Repository(childComplexity), true
	case "RepositoryVersion.updateAvailable":
		if e.complexity.RepositoryVersion.UpdateAvailable == nil {
			break
		}

		return e.complexity.RepositoryVersion.UpdateAvailable(childComplexity), true

	case "Scene.createdAt":
		if e.complexity.Scene.CreatedAt == nil {
			break
		}

		return e.complexity.Scene.CreatedAt(childComplexity), true
	case "Scene.description":
		if e.complexity.Scene.Description == nil {
			break
		}

		return e.complexity.Scene.Description(childComplexity), true
	case "Scene.fixtureValues":
		if e.complexity.Scene.FixtureValues == nil {
			break
		}

		return e.complexity.Scene.FixtureValues(childComplexity), true
	case "Scene.id":
		if e.complexity.Scene.ID == nil {
			break
		}

		return e.complexity.Scene.ID(childComplexity), true
	case "Scene.name":
		if e.complexity.Scene.Name == nil {
			break
		}

		return e.complexity.Scene.Name(childComplexity), true
	case "Scene.project":
		if e.complexity.Scene.Project == nil {
			break
		}

		return e.complexity.Scene.Project(childComplexity), true
	case "Scene.updatedAt":
		if e.complexity.Scene.UpdatedAt == nil {
			break
		}

		return e.complexity.Scene.UpdatedAt(childComplexity), true

	case "SceneBoard.buttons":
		if e.complexity.SceneBoard.Buttons == nil {
			break
		}

		return e.complexity.SceneBoard.Buttons(childComplexity), true
	case "SceneBoard.canvasHeight":
		if e.complexity.SceneBoard.CanvasHeight == nil {
			break
		}

		return e.complexity.SceneBoard.CanvasHeight(childComplexity), true
	case "SceneBoard.canvasWidth":
		if e.complexity.SceneBoard.CanvasWidth == nil {
			break
		}

		return e.complexity.SceneBoard.CanvasWidth(childComplexity), true
	case "SceneBoard.createdAt":
		if e.complexity.SceneBoard.CreatedAt == nil {
			break
		}

		return e.complexity.SceneBoard.CreatedAt(childComplexity), true
	case "SceneBoard.defaultFadeTime":
		if e.complexity.SceneBoard.DefaultFadeTime == nil {
			break
		}

		return e.complexity.SceneBoard.DefaultFadeTime(childComplexity), true
	case "SceneBoard.description":
		if e.complexity.SceneBoard.Description == nil {
			break
		}

		return e.complexity.SceneBoard.Description(childComplexity), true
	case "SceneBoard.gridSize":
		if e.complexity.SceneBoard.GridSize == nil {
			break
		}

		return e.complexity.SceneBoard.GridSize(childComplexity), true
	case "SceneBoard.id":
		if e.complexity.SceneBoard.ID == nil {
			break
		}

		return e.complexity.SceneBoard.ID(childComplexity), true
	case "SceneBoard.name":
		if e.complexity.SceneBoard.Name == nil {
			break
		}

		return e.complexity.SceneBoard.Name(childComplexity), true
	case "SceneBoard.project":
		if e.complexity.SceneBoard.Project == nil {
			break
		}

		return e.complexity.SceneBoard.Project(childComplexity), true
	case "SceneBoard.updatedAt":
		if e.complexity.SceneBoard.UpdatedAt == nil {
			break
		}

		return e.complexity.SceneBoard.UpdatedAt(childComplexity), true

	case "SceneBoardButton.color":
		if e.complexity.SceneBoardButton.Color == nil {
			break
		}

		return e.complexity.SceneBoardButton.Color(childComplexity), true
	case "SceneBoardButton.createdAt":
		if e.complexity.SceneBoardButton.CreatedAt == nil {
			break
		}

		return e.complexity.SceneBoardButton.CreatedAt(childComplexity), true
	case "SceneBoardButton.height":
		if e.complexity.SceneBoardButton.Height == nil {
			break
		}

		return e.complexity.SceneBoardButton.Height(childComplexity), true
	case "SceneBoardButton.id":
		if e.complexity.SceneBoardButton.ID == nil {
			break
		}

		return e.complexity.SceneBoardButton.ID(childComplexity), true
	case "SceneBoardButton.label":
		if e.complexity.SceneBoardButton.Label == nil {
			break
		}

		return e.complexity.SceneBoardButton.Label(childComplexity), true
	case "SceneBoardButton.layoutX":
		if e.complexity.SceneBoardButton.LayoutX == nil {
			break
		}

		return e.complexity.SceneBoardButton.LayoutX(childComplexity), true
	case "SceneBoardButton.layoutY":
		if e.complexity.SceneBoardButton.LayoutY == nil {
			break
		}

		return e.complexity.SceneBoardButton.LayoutY(childComplexity), true
	case "SceneBoardButton.scene":
		if e.complexity.SceneBoardButton.Scene == nil {
			break
		}

		return e.complexity.SceneBoardButton.Scene(childComplexity), true
	case "SceneBoardButton.sceneBoard":
		if e.complexity.SceneBoardButton.SceneBoard == nil {
			break
		}

		return e.complexity.SceneBoardButton.SceneBoard(childComplexity), true
	case "SceneBoardButton.updatedAt":
		if e.complexity.SceneBoardButton.UpdatedAt == nil {
			break
		}

		return e.complexity.SceneBoardButton.UpdatedAt(childComplexity), true
	case "SceneBoardButton.width":
		if e.complexity.SceneBoardButton.Width == nil {
			break
		}

		return e.complexity.SceneBoardButton.Width(childComplexity), true

	case "SceneComparison.differences":
		if e.complexity.SceneComparison.Differences == nil {
			break
		}

		return e.complexity.SceneComparison.Differences(childComplexity), true
	case "SceneComparison.differentFixtureCount":
		if e.complexity.SceneComparison.DifferentFixtureCount == nil {
			break
		}

		return e.complexity.SceneComparison.DifferentFixtureCount(childComplexity), true
	case "SceneComparison.identicalFixtureCount":
		if e.complexity.SceneComparison.IdenticalFixtureCount == nil {
			break
		}

		return e.complexity.SceneComparison.IdenticalFixtureCount(childComplexity), true
	case "SceneComparison.scene1":
		if e.complexity.SceneComparison.Scene1 == nil {
			break
		}

		return e.complexity.SceneComparison.Scene1(childComplexity), true
	case "SceneComparison.scene2":
		if e.complexity.SceneComparison.Scene2 == nil {
			break
		}

		return e.complexity.SceneComparison.Scene2(childComplexity), true

	case "SceneDifference.differenceType":
		if e.complexity.SceneDifference.DifferenceType == nil {
			break
		}

		return e.complexity.SceneDifference.DifferenceType(childComplexity), true
	case "SceneDifference.fixtureId":
		if e.complexity.SceneDifference.FixtureID == nil {
			break
		}

		return e.complexity.SceneDifference.FixtureID(childComplexity), true
	case "SceneDifference.fixtureName":
		if e.complexity.SceneDifference.FixtureName == nil {
			break
		}

		return e.complexity.SceneDifference.FixtureName(childComplexity), true
	case "SceneDifference.scene1Values":
		if e.complexity.SceneDifference.Scene1Values == nil {
			break
		}

		return e.complexity.SceneDifference.Scene1Values(childComplexity), true
	case "SceneDifference.scene2Values":
		if e.complexity.SceneDifference.Scene2Values == nil {
			break
		}

		return e.complexity.SceneDifference.Scene2Values(childComplexity), true

	case "SceneFixtureSummary.fixtureId":
		if e.complexity.SceneFixtureSummary.FixtureID == nil {
			break
		}

		return e.complexity.SceneFixtureSummary.FixtureID(childComplexity), true
	case "SceneFixtureSummary.fixtureName":
		if e.complexity.SceneFixtureSummary.FixtureName == nil {
			break
		}

		return e.complexity.SceneFixtureSummary.FixtureName(childComplexity), true
	case "SceneFixtureSummary.fixtureType":
		if e.complexity.SceneFixtureSummary.FixtureType == nil {
			break
		}

		return e.complexity.SceneFixtureSummary.FixtureType(childComplexity), true

	case "ScenePage.pagination":
		if e.complexity.ScenePage.Pagination == nil {
			break
		}

		return e.complexity.ScenePage.Pagination(childComplexity), true
	case "ScenePage.scenes":
		if e.complexity.ScenePage.Scenes == nil {
			break
		}

		return e.complexity.ScenePage.Scenes(childComplexity), true

	case "SceneSummary.createdAt":
		if e.complexity.SceneSummary.CreatedAt == nil {
			break
		}

		return e.complexity.SceneSummary.CreatedAt(childComplexity), true
	case "SceneSummary.description":
		if e.complexity.SceneSummary.Description == nil {
			break
		}

		return e.complexity.SceneSummary.Description(childComplexity), true
	case "SceneSummary.fixtureCount":
		if e.complexity.SceneSummary.FixtureCount == nil {
			break
		}

		return e.complexity.SceneSummary.FixtureCount(childComplexity), true
	case "SceneSummary.id":
		if e.complexity.SceneSummary.ID == nil {
			break
		}

		return e.complexity.SceneSummary.ID(childComplexity), true
	case "SceneSummary.name":
		if e.complexity.SceneSummary.Name == nil {
			break
		}

		return e.complexity.SceneSummary.Name(childComplexity), true
	case "SceneSummary.updatedAt":
		if e.complexity.SceneSummary.UpdatedAt == nil {
			break
		}

		return e.complexity.SceneSummary.UpdatedAt(childComplexity), true

	case "SceneUsage.cues":
		if e.complexity.SceneUsage.Cues == nil {
			break
		}

		return e.complexity.SceneUsage.Cues(childComplexity), true
	case "SceneUsage.sceneId":
		if e.complexity.SceneUsage.SceneID == nil {
			break
		}

		return e.complexity.SceneUsage.SceneID(childComplexity), true
	case "SceneUsage.sceneName":
		if e.complexity.SceneUsage.SceneName == nil {
			break
		}

		return e.complexity.SceneUsage.SceneName(childComplexity), true

	case "Setting.createdAt":
		if e.complexity.Setting.CreatedAt == nil {
			break
		}

		return e.complexity.Setting.CreatedAt(childComplexity), true
	case "Setting.id":
		if e.complexity.Setting.ID == nil {
			break
		}

		return e.complexity.Setting.ID(childComplexity), true
	case "Setting.key":
		if e.complexity.Setting.Key == nil {
			break
		}

		return e.complexity.Setting.Key(childComplexity), true
	case "Setting.updatedAt":
		if e.complexity.Setting.UpdatedAt == nil {
			break
		}

		return e.complexity.Setting.UpdatedAt(childComplexity), true
	case "Setting.value":
		if e.complexity.Setting.Value == nil {
			break
		}

		return e.complexity.Setting.Value(childComplexity), true

	case "Subscription.cueListPlaybackUpdated":
		if e.complexity.Subscription.CueListPlaybackUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_cueListPlaybackUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CueListPlaybackUpdated(childComplexity, args["cueListId"].(string)), true
	case "Subscription.dmxOutputChanged":
		if e.complexity.Subscription.DmxOutputChanged == nil {
			break
		}

		args, err := ec.field_Subscription_dmxOutputChanged_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.DmxOutputChanged(childComplexity, args["universe"].(*int)), true
	case "Subscription.oflImportProgress":
		if e.complexity.Subscription.OflImportProgress == nil {
			break
		}

		return e.complexity.Subscription.OflImportProgress(childComplexity), true
	case "Subscription.previewSessionUpdated":
		if e.complexity.Subscription.PreviewSessionUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_previewSessionUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.PreviewSessionUpdated(childComplexity, args["projectId"].(string)), true
	case "Subscription.projectUpdated":
		if e.complexity.Subscription.ProjectUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_projectUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ProjectUpdated(childComplexity, args["projectId"].(string)), true
	case "Subscription.systemInfoUpdated":
		if e.complexity.Subscription.SystemInfoUpdated == nil {
			break
		}

		return e.complexity.Subscription.SystemInfoUpdated(childComplexity), true
	case "Subscription.wifiStatusUpdated":
		if e.complexity.Subscription.WifiStatusUpdated == nil {
			break
		}

		return e.complexity.Subscription.WifiStatusUpdated(childComplexity), true

	case "SystemInfo.artnetBroadcastAddress":
		if e.complexity.SystemInfo.ArtnetBroadcastAddress == nil {
			break
		}

		return e.complexity.SystemInfo.ArtnetBroadcastAddress(childComplexity), true
	case "SystemInfo.artnetEnabled":
		if e.complexity.SystemInfo.ArtnetEnabled == nil {
			break
		}

		return e.complexity.SystemInfo.ArtnetEnabled(childComplexity), true

	case "SystemVersionInfo.lastChecked":
		if e.complexity.SystemVersionInfo.LastChecked == nil {
			break
		}

		return e.complexity.SystemVersionInfo.LastChecked(childComplexity), true
	case "SystemVersionInfo.repositories":
		if e.complexity.SystemVersionInfo.Repositories == nil {
			break
		}

		return e.complexity.SystemVersionInfo.Repositories(childComplexity), true
	case "SystemVersionInfo.versionManagementSupported":
		if e.complexity.SystemVersionInfo.VersionManagementSupported == nil {
			break
		}

		return e.complexity.SystemVersionInfo.VersionManagementSupported(childComplexity), true

	case "UniverseChannelMap.availableChannels":
		if e.complexity.UniverseChannelMap.AvailableChannels == nil {
			break
		}

		return e.complexity.UniverseChannelMap.AvailableChannels(childComplexity), true
	case "UniverseChannelMap.channelUsage":
		if e.complexity.UniverseChannelMap.ChannelUsage == nil {
			break
		}

		return e.complexity.UniverseChannelMap.ChannelUsage(childComplexity), true
	case "UniverseChannelMap.fixtures":
		if e.complexity.UniverseChannelMap.Fixtures == nil {
			break
		}

		return e.complexity.UniverseChannelMap.Fixtures(childComplexity), true
	case "UniverseChannelMap.universe":
		if e.complexity.UniverseChannelMap.Universe == nil {
			break
		}

		return e.complexity.UniverseChannelMap.Universe(childComplexity), true
	case "UniverseChannelMap.usedChannels":
		if e.complexity.UniverseChannelMap.UsedChannels == nil {
			break
		}

		return e.complexity.UniverseChannelMap.UsedChannels(childComplexity), true

	case "UniverseOutput.channels":
		if e.complexity.UniverseOutput.Channels == nil {
			break
		}

		return e.complexity.UniverseOutput.Channels(childComplexity), true
	case "UniverseOutput.universe":
		if e.complexity.UniverseOutput.Universe == nil {
			break
		}

		return e.complexity.UniverseOutput.Universe(childComplexity), true

	case "UpdateResult.error":
		if e.complexity.UpdateResult.Error == nil {
			break
		}

		return e.complexity.UpdateResult.Error(childComplexity), true
	case "UpdateResult.message":
		if e.complexity.UpdateResult.Message == nil {
			break
		}

		return e.complexity.UpdateResult.Message(childComplexity), true
	case "UpdateResult.newVersion":
		if e.complexity.UpdateResult.NewVersion == nil {
			break
		}

		return e.complexity.UpdateResult.NewVersion(childComplexity), true
	case "UpdateResult.previousVersion":
		if e.complexity.UpdateResult.PreviousVersion == nil {
			break
		}

		return e.complexity.UpdateResult.PreviousVersion(childComplexity), true
	case "UpdateResult.repository":
		if e.complexity.UpdateResult.Repository == nil {
			break
		}

		return e.complexity.UpdateResult.Repository(childComplexity), true
	case "UpdateResult.success":
		if e.complexity.UpdateResult.Success == nil {
			break
		}

		return e.complexity.UpdateResult.Success(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true
	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true
	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true
	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true
	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "WiFiConnectionResult.connected":
		if e.complexity.WiFiConnectionResult.Connected == nil {
			break
		}

		return e.complexity.WiFiConnectionResult.Connected(childComplexity), true
	case "WiFiConnectionResult.message":
		if e.complexity.WiFiConnectionResult.Message == nil {
			break
		}

		return e.complexity.WiFiConnectionResult.Message(childComplexity), true
	case "WiFiConnectionResult.success":
		if e.complexity.WiFiConnectionResult.Success == nil {
			break
		}

		return e.complexity.WiFiConnectionResult.Success(childComplexity), true

	case "WiFiNetwork.frequency":
		if e.complexity.WiFiNetwork.Frequency == nil {
			break
		}

		return e.complexity.WiFiNetwork.Frequency(childComplexity), true
	case "WiFiNetwork.inUse":
		if e.complexity.WiFiNetwork.InUse == nil {
			break
		}

		return e.complexity.WiFiNetwork.InUse(childComplexity), true
	case "WiFiNetwork.saved":
		if e.complexity.WiFiNetwork.Saved == nil {
			break
		}

		return e.complexity.WiFiNetwork.Saved(childComplexity), true
	case "WiFiNetwork.security":
		if e.complexity.WiFiNetwork.Security == nil {
			break
		}

		return e.complexity.WiFiNetwork.Security(childComplexity), true
	case "WiFiNetwork.signalStrength":
		if e.complexity.WiFiNetwork.SignalStrength == nil {
			break
		}

		return e.complexity.WiFiNetwork.SignalStrength(childComplexity), true
	case "WiFiNetwork.ssid":
		if e.complexity.WiFiNetwork.Ssid == nil {
			break
		}

		return e.complexity.WiFiNetwork.Ssid(childComplexity), true

	case "WiFiStatus.available":
		if e.complexity.WiFiStatus.Available == nil {
			break
		}

		return e.complexity.WiFiStatus.Available(childComplexity), true
	case "WiFiStatus.connected":
		if e.complexity.WiFiStatus.Connected == nil {
			break
		}

		return e.complexity.WiFiStatus.Connected(childComplexity), true
	case "WiFiStatus.enabled":
		if e.complexity.WiFiStatus.Enabled == nil {
			break
		}

		return e.complexity.WiFiStatus.Enabled(childComplexity), true
	case "WiFiStatus.frequency":
		if e.complexity.WiFiStatus.Frequency == nil {
			break
		}

		return e.complexity.WiFiStatus.Frequency(childComplexity), true
	case "WiFiStatus.ipAddress":
		if e.complexity.WiFiStatus.IPAddress == nil {
			break
		}

		return e.complexity.WiFiStatus.IPAddress(childComplexity), true
	case "WiFiStatus.macAddress":
		if e.complexity.WiFiStatus.MacAddress == nil {
			break
		}

		return e.complexity.WiFiStatus.MacAddress(childComplexity), true
	case "WiFiStatus.signalStrength":
		if e.complexity.WiFiStatus.SignalStrength == nil {
			break
		}

		return e.complexity.WiFiStatus.SignalStrength(childComplexity), true
	case "WiFiStatus.ssid":
		if e.complexity.WiFiStatus.Ssid == nil {
			break
		}

		return e.complexity.WiFiStatus.Ssid(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBulkCueCreateInput,
		ec.unmarshalInputBulkCueListCreateInput,
		ec.unmarshalInputBulkCueListUpdateInput,
		ec.unmarshalInputBulkCueUpdateInput,
		ec.unmarshalInputBulkFixtureCreateInput,
		ec.unmarshalInputBulkFixtureDefinitionCreateInput,
		ec.unmarshalInputBulkFixtureDefinitionUpdateInput,
		ec.unmarshalInputBulkFixtureUpdateInput,
		ec.unmarshalInputBulkProjectCreateInput,
		ec.unmarshalInputBulkProjectUpdateInput,
		ec.unmarshalInputBulkSceneBoardButtonCreateInput,
		ec.unmarshalInputBulkSceneBoardButtonUpdateInput,
		ec.unmarshalInputBulkSceneBoardCreateInput,
		ec.unmarshalInputBulkSceneBoardUpdateInput,
		ec.unmarshalInputBulkSceneCreateInput,
		ec.unmarshalInputBulkSceneUpdateInput,
		ec.unmarshalInputChannelAssignmentInput,
		ec.unmarshalInputChannelFadeBehaviorInput,
		ec.unmarshalInputChannelValueInput,
		ec.unmarshalInputCreateChannelDefinitionInput,
		ec.unmarshalInputCreateCueInput,
		ec.unmarshalInputCreateCueListInput,
		ec.unmarshalInputCreateFixtureDefinitionInput,
		ec.unmarshalInputCreateFixtureInstanceInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputCreateSceneBoardButtonInput,
		ec.unmarshalInputCreateSceneBoardInput,
		ec.unmarshalInputCreateSceneInput,
		ec.unmarshalInputCueListUpdateItem,
		ec.unmarshalInputCueOrderInput,
		ec.unmarshalInputExportOptionsInput,
		ec.unmarshalInputFixtureDefinitionFilter,
		ec.unmarshalInputFixtureDefinitionUpdateItem,
		ec.unmarshalInputFixtureFilterInput,
		ec.unmarshalInputFixtureMappingInput,
		ec.unmarshalInputFixtureOrderInput,
		ec.unmarshalInputFixturePositionInput,
		ec.unmarshalInputFixtureSpecInput,
		ec.unmarshalInputFixtureUpdateItem,
		ec.unmarshalInputFixtureValueInput,
		ec.unmarshalInputImportOFLFixtureInput,
		ec.unmarshalInputImportOptionsInput,
		ec.unmarshalInputOFLImportOptionsInput,
		ec.unmarshalInputProjectUpdateItem,
		ec.unmarshalInputSceneBoardButtonPositionInput,
		ec.unmarshalInputSceneBoardButtonUpdateItem,
		ec.unmarshalInputSceneBoardUpdateItem,
		ec.unmarshalInputSceneFilterInput,
		ec.unmarshalInputSceneUpdateItem,
		ec.unmarshalInputUpdateFixtureInstanceInput,
		ec.unmarshalInputUpdateSceneBoardButtonInput,
		ec.unmarshalInputUpdateSceneBoardInput,
		ec.unmarshalInputUpdateSceneInput,
		ec.unmarshalInputUpdateSettingInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `# LacyLights GraphQL Schema
# This schema is 100% compatible with lacylights-node

# =============================================================================
# ENUMS
# =============================================================================

enum FixtureType {
  LED_PAR
  MOVING_HEAD
  STROBE
  DIMMER
  OTHER
}

enum ChannelType {
  INTENSITY
  RED
  GREEN
  BLUE
  WHITE
  AMBER
  UV
  PAN
  TILT
  ZOOM
  FOCUS
  IRIS
  GOBO
  COLOR_WHEEL
  EFFECT
  STROBE
  MACRO
  OTHER
}

enum UserRole {
  ADMIN
  USER
}

enum ProjectRole {
  OWNER
  EDITOR
  VIEWER
}

enum EasingType {
  LINEAR
  EASE_IN_OUT_CUBIC
  EASE_IN_OUT_SINE
  EASE_OUT_EXPONENTIAL
  BEZIER
  S_CURVE
}

"""
Determines how a channel behaves during scene transitions.
FADE - Interpolate smoothly between values (default for intensity, colors)
SNAP - Jump to target value at start of transition (for gobos, macros, effects)
SNAP_END - Jump to target value at end of transition
"""
enum FadeBehavior {
  FADE
  SNAP
  SNAP_END
}

enum SceneSortField {
  NAME
  CREATED_AT
  UPDATED_AT
}

enum DifferenceType {
  VALUES_CHANGED
  ONLY_IN_SCENE1
  ONLY_IN_SCENE2
}

enum WiFiSecurityType {
  OPEN
  WEP
  WPA_PSK
  WPA_EAP
  WPA3_PSK
  WPA3_EAP
  OWE
}

"""
Phases of the OFL import process
"""
enum OFLImportPhase {
  IDLE
  DOWNLOADING
  EXTRACTING
  PARSING
  IMPORTING
  COMPLETE
  FAILED
  CANCELLED
}

"""
Type of fixture change detected during OFL update check
"""
enum OFLFixtureChangeType {
  NEW
  UPDATED
  UNCHANGED
}

enum ImportMode {
  CREATE
  MERGE
}

enum FixtureConflictStrategy {
  SKIP
  REPLACE
  ERROR
}

# =============================================================================
# CORE TYPES
# =============================================================================

type Project {
  id: ID!
  name: String!
  description: String
  fixtureCount: Int!
  sceneCount: Int!
  cueListCount: Int!
  createdAt: String!
  updatedAt: String!
  fixtures: [FixtureInstance!]!
  scenes: [Scene!]!
  cueLists: [CueList!]!
  sceneBoards: [SceneBoard!]!
  users: [ProjectUser!]!
}

type FixtureDefinition {
  id: ID!
  manufacturer: String!
  model: String!
  type: FixtureType!
  channels: [ChannelDefinition!]!
  modes: [FixtureMode!]!
  isBuiltIn: Boolean!
  createdAt: String!
}

type FixtureMode {
  id: ID!
  name: String!
  shortName: String
  channelCount: Int!
  channels: [ModeChannel!]!
}

type ModeChannel {
  id: ID!
  offset: Int!
  channel: ChannelDefinition!
}

type ChannelDefinition {
  id: ID!
  name: String!
  type: ChannelType!
  offset: Int!
  minValue: Int!
  maxValue: Int!
  defaultValue: Int!
  fadeBehavior: FadeBehavior!
  isDiscrete: Boolean!
}

type FixtureInstance {
  id: ID!
  name: String!
  description: String

  # Fixture Definition Info (flattened)
  definitionId: ID!
  manufacturer: String!
  model: String!
  type: FixtureType!

  # Mode Info (flattened)
  modeName: String!
  channelCount: Int!
  channels: [InstanceChannel!]!

  # DMX Configuration
  project: Project!
  universe: Int!
  startChannel: Int!
  tags: [String!]!
  projectOrder: Int

  # 2D Layout Position (normalized 0-1 coordinates)
  layoutX: Float
  layoutY: Float
  layoutRotation: Float

  createdAt: String!
}

type InstanceChannel {
  id: ID!
  offset: Int!
  name: String!
  type: ChannelType!
  minValue: Int!
  maxValue: Int!
  defaultValue: Int!
  fadeBehavior: FadeBehavior!
  isDiscrete: Boolean!
}

type Scene {
  id: ID!
  name: String!
  description: String
  project: Project!
  fixtureValues: [FixtureValue!]!
  createdAt: String!
  updatedAt: String!
}

type ChannelValue {
  offset: Int!
  value: Int!
}

type FixtureValue {
  id: ID!
  fixture: FixtureInstance!
  channels: [ChannelValue!]!
  sceneOrder: Int
}

type SceneBoard {
  id: ID!
  name: String!
  description: String
  project: Project!
  defaultFadeTime: Float!
  gridSize: Int
  canvasWidth: Int!
  canvasHeight: Int!
  buttons: [SceneBoardButton!]!
  createdAt: String!
  updatedAt: String!
}

type SceneBoardButton {
  id: ID!
  sceneBoard: SceneBoard!
  scene: Scene!
  layoutX: Int!
  layoutY: Int!
  width: Int
  height: Int
  color: String
  label: String
  createdAt: String!
  updatedAt: String!
}

type CueList {
  id: ID!
  name: String!
  description: String
  loop: Boolean!
  project: Project!
  cues: [Cue!]!
  cueCount: Int!
  totalDuration: Float!
  createdAt: String!
  updatedAt: String!
}

type Cue {
  id: ID!
  name: String!
  cueNumber: Float!
  scene: Scene!
  cueList: CueList!
  fadeInTime: Float!
  fadeOutTime: Float!
  followTime: Float
  easingType: EasingType
  notes: String
}

type CueListPlaybackStatus {
  cueListId: ID!
  currentCueIndex: Int
  "True when a scene's values are currently active on DMX fixtures (stays true after fade completes until stopped)"
  isPlaying: Boolean!
  "True when a fade-in transition is in progress"
  isFading: Boolean!
  currentCue: Cue
  nextCue: Cue
  previousCue: Cue
  fadeProgress: Float
  lastUpdated: String!
}

type User {
  id: ID!
  email: String!
  name: String
  role: UserRole!
  createdAt: String!
}

type ProjectUser {
  id: ID!
  user: User!
  project: Project!
  role: ProjectRole!
  joinedAt: String!
}

type PreviewSession {
  id: ID!
  project: Project!
  user: User!
  isActive: Boolean!
  createdAt: String!
  dmxOutput: [UniverseOutput!]!
}

type UniverseOutput {
  universe: Int!
  channels: [Int!]!
}

type Setting {
  id: ID!
  key: String!
  value: String!
  createdAt: String!
  updatedAt: String!
}

type SystemInfo {
  artnetBroadcastAddress: String!
  artnetEnabled: Boolean!
}

# =============================================================================
# PAGINATION TYPES
# =============================================================================

type PaginationInfo {
  total: Int!
  page: Int!
  perPage: Int!
  totalPages: Int!
  hasMore: Boolean!
}

type CueListSummary {
  id: ID!
  name: String!
  description: String
  cueCount: Int!
  totalDuration: Float!
  loop: Boolean!
  createdAt: String!
}

type CuePage {
  cues: [Cue!]!
  pagination: PaginationInfo!
}

type SceneSummary {
  id: ID!
  name: String!
  description: String
  fixtureCount: Int!
  createdAt: String!
  updatedAt: String!
}

type ScenePage {
  scenes: [SceneSummary!]!
  pagination: PaginationInfo!
}

type SceneFixtureSummary {
  fixtureId: ID!
  fixtureName: String!
  fixtureType: FixtureType!
}

type FixtureInstancePage {
  fixtures: [FixtureInstance!]!
  pagination: PaginationInfo!
}

# =============================================================================
# RELATIONSHIP TYPES
# =============================================================================

type CueUsageSummary {
  cueId: ID!
  cueNumber: Float!
  cueName: String!
  cueListId: ID!
  cueListName: String!
}

type FixtureUsage {
  fixtureId: ID!
  fixtureName: String!
  scenes: [SceneSummary!]!
  cues: [CueUsageSummary!]!
}

type SceneUsage {
  sceneId: ID!
  sceneName: String!
  cues: [CueUsageSummary!]!
}

type SceneDifference {
  fixtureId: ID!
  fixtureName: String!
  differenceType: DifferenceType!
  scene1Values: [Int!]
  scene2Values: [Int!]
}

type SceneComparison {
  scene1: SceneSummary!
  scene2: SceneSummary!
  differences: [SceneDifference!]!
  identicalFixtureCount: Int!
  differentFixtureCount: Int!
}

# =============================================================================
# DMX CHANNEL ASSIGNMENT TYPES
# =============================================================================

type ChannelMapResult {
  projectId: ID!
  universes: [UniverseChannelMap!]!
}

type UniverseChannelMap {
  universe: Int!
  fixtures: [ChannelMapFixture!]!
  channelUsage: [ChannelUsage]!
  availableChannels: Int!
  usedChannels: Int!
}

type ChannelMapFixture {
  id: ID!
  name: String!
  type: FixtureType!
  startChannel: Int!
  endChannel: Int!
  channelCount: Int!
}

type ChannelUsage {
  fixtureId: ID!
  fixtureName: String!
  channelType: ChannelType!
}

type ChannelAssignmentSuggestion {
  universe: Int!
  assignments: [FixtureChannelAssignment!]!
  totalChannelsNeeded: Int!
  availableChannelsRemaining: Int!
}

type FixtureChannelAssignment {
  fixtureName: String!
  manufacturer: String!
  model: String!
  mode: String
  startChannel: Int!
  endChannel: Int!
  channelCount: Int!
  channelRange: String!
}

# =============================================================================
# OFL (OPEN FIXTURE LIBRARY) TYPES
# =============================================================================

"""
Real-time status of an OFL import operation
"""
type OFLImportStatus {
  "Whether an import is currently in progress"
  isImporting: Boolean!
  "Current phase of the import"
  phase: OFLImportPhase!
  "Total number of fixtures to import"
  totalFixtures: Int!
  "Number of fixtures successfully imported"
  importedCount: Int!
  "Number of fixtures that failed to import"
  failedCount: Int!
  "Number of fixtures skipped (already exist)"
  skippedCount: Int!
  "Percentage complete (0-100)"
  percentComplete: Float!
  "Name of the current fixture being imported"
  currentFixture: String
  "Current manufacturer being processed"
  currentManufacturer: String
  "Estimated seconds remaining (null if unknown)"
  estimatedSecondsRemaining: Int
  "Error message if phase is FAILED"
  errorMessage: String
  "When the import started"
  startedAt: String
  "When the import completed (if done)"
  completedAt: String
  "OFL version/commit being imported"
  oflVersion: String
  "Whether using bundled data (offline) or fetched from GitHub"
  usingBundledData: Boolean!
}

"""
Information about a fixture that may need updating
"""
type OFLFixtureUpdate {
  "Unique key (manufacturer/model)"
  fixtureKey: String!
  "Manufacturer name"
  manufacturer: String!
  "Model name"
  model: String!
  "Type of change"
  changeType: OFLFixtureChangeType!
  "Whether this fixture is currently in use by any project"
  isInUse: Boolean!
  "Number of instances using this definition"
  instanceCount: Int!
  "Current hash (null if new)"
  currentHash: String
  "New hash from OFL"
  newHash: String!
}

"""
Result of checking for OFL updates
"""
type OFLUpdateCheckResult {
  "Total fixtures in current database"
  currentFixtureCount: Int!
  "Total fixtures in OFL source"
  oflFixtureCount: Int!
  "Number of new fixtures available"
  newFixtureCount: Int!
  "Number of changed fixtures"
  changedFixtureCount: Int!
  "Number of changed fixtures that are in use"
  changedInUseCount: Int!
  "Detailed list of fixture changes (limited)"
  fixtureUpdates: [OFLFixtureUpdate!]!
  "OFL version/commit being checked"
  oflVersion: String!
  "When this check was performed"
  checkedAt: String!
}

"""
Statistics about an OFL import
"""
type OFLImportStats {
  totalProcessed: Int!
  successfulImports: Int!
  failedImports: Int!
  skippedDuplicates: Int!
  updatedFixtures: Int!
  durationSeconds: Float!
}

"""
Final result of an OFL import operation
"""
type OFLImportResult {
  success: Boolean!
  stats: OFLImportStats!
  errorMessage: String
  oflVersion: String!
}

# =============================================================================
# VERSION MANAGEMENT TYPES
# =============================================================================

type RepositoryVersion {
  repository: String!
  installed: String!
  latest: String!
  updateAvailable: Boolean!
}

type SystemVersionInfo {
  repositories: [RepositoryVersion!]!
  lastChecked: String!
  versionManagementSupported: Boolean!
}

type UpdateResult {
  success: Boolean!
  repository: String!
  previousVersion: String!
  newVersion: String!
  message: String
  error: String
}

type NetworkInterfaceOption {
  name: String!
  address: String!
  broadcast: String!
  description: String!
  interfaceType: String!
}

# =============================================================================
# WIFI TYPES
# =============================================================================

type WiFiNetwork {
  ssid: String!
  signalStrength: Int!
  frequency: String!
  security: WiFiSecurityType!
  inUse: Boolean!
  saved: Boolean!
}

type WiFiStatus {
  available: Boolean!
  enabled: Boolean!
  connected: Boolean!
  ssid: String
  signalStrength: Int
  ipAddress: String
  macAddress: String
  frequency: String
}

type WiFiConnectionResult {
  success: Boolean!
  message: String
  connected: Boolean!
}

# =============================================================================
# EXPORT/IMPORT TYPES
# =============================================================================

type ExportResult {
  projectId: String!
  projectName: String!
  jsonContent: String!
  stats: ExportStats!
}

type ExportStats {
  fixtureDefinitionsCount: Int!
  fixtureInstancesCount: Int!
  scenesCount: Int!
  cueListsCount: Int!
  cuesCount: Int!
}

type ImportResult {
  projectId: String!
  stats: ImportStats!
  warnings: [String!]!
}

type ImportStats {
  fixtureDefinitionsCreated: Int!
  fixtureInstancesCreated: Int!
  scenesCreated: Int!
  cueListsCreated: Int!
  cuesCreated: Int!
}

# =============================================================================
# QLC+ TYPES
# =============================================================================

type QLCExportResult {
  projectName: String!
  xmlContent: String!
  fixtureCount: Int!
  sceneCount: Int!
  cueListCount: Int!
}

type QLCImportResult {
  project: Project!
  originalFileName: String!
  fixtureCount: Int!
  sceneCount: Int!
  cueListCount: Int!
  warnings: [String!]!
}

type QLCFixtureDefinition {
  manufacturer: String!
  model: String!
  type: String!
  modes: [QLCFixtureMode!]!
}

type QLCFixtureMode {
  name: String!
  channelCount: Int!
}

type FixtureMapping {
  lacyLightsKey: String!
  qlcManufacturer: String!
  qlcModel: String!
  qlcMode: String!
}

type FixtureMappingSuggestion {
  fixture: LacyLightsFixture!
  suggestions: [QLCFixtureDefinition!]!
}

type LacyLightsFixture {
  manufacturer: String!
  model: String!
}

type QLCFixtureMappingResult {
  projectId: String!
  lacyLightsFixtures: [LacyLightsFixture!]!
  suggestions: [FixtureMappingSuggestion!]!
  defaultMappings: [FixtureMapping!]!
}

# =============================================================================
# INPUT TYPES
# =============================================================================

input CreateProjectInput {
  name: String!
  description: String
}

input CreateFixtureDefinitionInput {
  manufacturer: String!
  model: String!
  type: FixtureType!
  channels: [CreateChannelDefinitionInput!]!
}

input CreateChannelDefinitionInput {
  name: String!
  type: ChannelType!
  offset: Int!
  minValue: Int!
  maxValue: Int!
  defaultValue: Int!
  fadeBehavior: FadeBehavior
  isDiscrete: Boolean
}

input ChannelFadeBehaviorInput {
  channelId: ID!
  fadeBehavior: FadeBehavior!
}

input ImportOFLFixtureInput {
  manufacturer: String!
  oflFixtureJson: String!
  replace: Boolean
}

input CreateFixtureInstanceInput {
  name: String!
  description: String
  definitionId: ID!
  modeId: ID
  projectId: ID!
  universe: Int!
  startChannel: Int!
  tags: [String!]
}

input UpdateFixtureInstanceInput {
  name: String
  description: String
  definitionId: ID
  modeId: ID
  universe: Int
  startChannel: Int
  tags: [String!]
  projectOrder: Int
  layoutX: Float
  layoutY: Float
  layoutRotation: Float
}

input FixturePositionInput {
  fixtureId: ID!
  layoutX: Float!
  layoutY: Float!
  layoutRotation: Float
}

input FixtureOrderInput {
  fixtureId: ID!
  order: Int!
}

input CueOrderInput {
  cueId: ID!
  cueNumber: Float!
}

input CreateSceneInput {
  name: String!
  description: String
  projectId: ID!
  fixtureValues: [FixtureValueInput!]!
}

input UpdateSceneInput {
  name: String
  description: String
  fixtureValues: [FixtureValueInput!]
}

input ChannelValueInput {
  offset: Int!
  value: Int!
}

input FixtureValueInput {
  fixtureId: ID!
  channels: [ChannelValueInput!]!
  sceneOrder: Int
}

input SceneFilterInput {
  nameContains: String
  usesFixture: ID
}

input CreateSceneBoardInput {
  name: String!
  description: String
  projectId: ID!
  defaultFadeTime: Float = 3.0
  gridSize: Int = 50
  canvasWidth: Int = 2000
  canvasHeight: Int = 2000
}

input UpdateSceneBoardInput {
  name: String
  description: String
  defaultFadeTime: Float
  gridSize: Int
  canvasWidth: Int
  canvasHeight: Int
}

input CreateSceneBoardButtonInput {
  sceneBoardId: ID!
  sceneId: ID!
  layoutX: Int!
  layoutY: Int!
  width: Int = 200
  height: Int = 120
  color: String
  label: String
}

input UpdateSceneBoardButtonInput {
  layoutX: Int
  layoutY: Int
  width: Int
  height: Int
  color: String
  label: String
}

input SceneBoardButtonPositionInput {
  buttonId: ID!
  layoutX: Int!
  layoutY: Int!
}

input FixtureDefinitionFilter {
  manufacturer: String
  model: String
  type: FixtureType
  isBuiltIn: Boolean
  channelTypes: [ChannelType!]
}

input FixtureFilterInput {
  type: FixtureType
  universe: Int
  tags: [String!]
  manufacturer: String
  model: String
}

input CreateCueListInput {
  name: String!
  description: String
  loop: Boolean
  projectId: ID!
}

input CreateCueInput {
  name: String!
  cueNumber: Float!
  cueListId: ID!
  sceneId: ID!
  fadeInTime: Float!
  fadeOutTime: Float!
  followTime: Float
  easingType: EasingType
  notes: String
}

input BulkCueUpdateInput {
  cueIds: [ID!]!
  fadeInTime: Float
  fadeOutTime: Float
  followTime: Float
  easingType: EasingType
}

input FixtureUpdateItem {
  fixtureId: ID!
  name: String
  description: String
  universe: Int
  startChannel: Int
  tags: [String!]
  layoutX: Float
  layoutY: Float
  layoutRotation: Float
}

input BulkFixtureUpdateInput {
  fixtures: [FixtureUpdateItem!]!
}

input BulkFixtureCreateInput {
  fixtures: [CreateFixtureInstanceInput!]!
}

# =============================================================================
# BULK OPERATION TYPES
# =============================================================================

# Common result type for bulk deletes
type BulkDeleteResult {
  deletedCount: Int!
  deletedIds: [ID!]!
}

# Bulk Create Inputs
input BulkSceneCreateInput {
  scenes: [CreateSceneInput!]!
}

input BulkCueCreateInput {
  cues: [CreateCueInput!]!
}

input BulkCueListCreateInput {
  cueLists: [CreateCueListInput!]!
}

input BulkSceneBoardCreateInput {
  sceneBoards: [CreateSceneBoardInput!]!
}

input BulkSceneBoardButtonCreateInput {
  buttons: [CreateSceneBoardButtonInput!]!
}

input BulkFixtureDefinitionCreateInput {
  definitions: [CreateFixtureDefinitionInput!]!
}

input BulkProjectCreateInput {
  projects: [CreateProjectInput!]!
}

# Bulk Update Inputs
input BulkSceneUpdateInput {
  scenes: [SceneUpdateItem!]!
}

input SceneUpdateItem {
  sceneId: ID!
  name: String
  description: String
}

input BulkCueListUpdateInput {
  cueLists: [CueListUpdateItem!]!
}

input CueListUpdateItem {
  cueListId: ID!
  name: String
  description: String
  loop: Boolean
}

input BulkSceneBoardUpdateInput {
  sceneBoards: [SceneBoardUpdateItem!]!
}

input SceneBoardUpdateItem {
  sceneBoardId: ID!
  name: String
  description: String
  defaultFadeTime: Float
  gridSize: Int
  canvasWidth: Int
  canvasHeight: Int
}

input BulkSceneBoardButtonUpdateInput {
  buttons: [SceneBoardButtonUpdateItem!]!
}

input SceneBoardButtonUpdateItem {
  buttonId: ID!
  layoutX: Int
  layoutY: Int
  width: Int
  height: Int
  color: String
  label: String
}

input BulkFixtureDefinitionUpdateInput {
  definitions: [FixtureDefinitionUpdateItem!]!
}

input FixtureDefinitionUpdateItem {
  definitionId: ID!
  manufacturer: String
  model: String
  type: FixtureType
}

input BulkProjectUpdateInput {
  projects: [ProjectUpdateItem!]!
}

input ProjectUpdateItem {
  projectId: ID!
  name: String
  description: String
}

input FixtureMappingInput {
  lacyLightsKey: String!
  qlcManufacturer: String!
  qlcModel: String!
  qlcMode: String!
}

input ChannelAssignmentInput {
  projectId: ID!
  universe: Int = 1
  startingChannel: Int = 1
  fixtureSpecs: [FixtureSpecInput!]!
}

input FixtureSpecInput {
  name: String!
  manufacturer: String!
  model: String!
  mode: String
  channelCount: Int
}

input ExportOptionsInput {
  description: String
  includeFixtures: Boolean
  includeScenes: Boolean
  includeCueLists: Boolean
}

input ImportOptionsInput {
  mode: ImportMode!
  targetProjectId: ID
  projectName: String
  fixtureConflictStrategy: FixtureConflictStrategy
  importBuiltInFixtures: Boolean
}

input UpdateSettingInput {
  key: String!
  value: String!
}

"""
Options for triggering an OFL import
"""
input OFLImportOptionsInput {
  "Force reimport of all fixtures, even if unchanged"
  forceReimport: Boolean = false
  "Update fixtures that are currently in use by projects"
  updateInUseFixtures: Boolean = false
  "Only import specific manufacturers (empty = all)"
  manufacturers: [String!]
  "Prefer bundled data over fetching from GitHub"
  preferBundled: Boolean = false
}

# =============================================================================
# QUERIES
# =============================================================================

type Query {
  # Projects
  projects: [Project!]!
  project(id: ID!): Project

  # Fixtures
  fixtureDefinitions(filter: FixtureDefinitionFilter): [FixtureDefinition!]!
  fixtureDefinition(id: ID!): FixtureDefinition
  fixtureInstances(
    projectId: ID!
    page: Int = 1
    perPage: Int = 50
    filter: FixtureFilterInput
  ): FixtureInstancePage!
  fixtureInstance(id: ID!): FixtureInstance

  # Search Queries
  searchFixtures(
    projectId: ID!
    query: String!
    filter: FixtureFilterInput
    page: Int = 1
    perPage: Int = 50
  ): FixtureInstancePage!

  # DMX Channel Assignment
  channelMap(projectId: ID!, universe: Int): ChannelMapResult!
  suggestChannelAssignment(input: ChannelAssignmentInput!): ChannelAssignmentSuggestion!

  # Scenes
  scenes(
    projectId: ID!
    page: Int = 1
    perPage: Int = 50
    filter: SceneFilterInput
    sortBy: SceneSortField = CREATED_AT
  ): ScenePage!
  scene(id: ID!, includeFixtureValues: Boolean = true): Scene
  sceneFixtures(sceneId: ID!): [SceneFixtureSummary!]!

  searchScenes(
    projectId: ID!
    query: String!
    filter: SceneFilterInput
    page: Int = 1
    perPage: Int = 50
  ): ScenePage!

  # Scene Boards
  sceneBoards(projectId: ID!): [SceneBoard!]!
  sceneBoard(id: ID!): SceneBoard
  sceneBoardButton(id: ID!): SceneBoardButton

  # Relationship Queries
  fixtureUsage(fixtureId: ID!): FixtureUsage!
  sceneUsage(sceneId: ID!): SceneUsage!
  compareScenes(sceneId1: ID!, sceneId2: ID!): SceneComparison!

  # Cue Lists
  cueLists(projectId: ID!): [CueListSummary!]!
  cueList(
    id: ID!
    page: Int = 1
    perPage: Int = 50
    includeSceneDetails: Boolean = false
  ): CueList
  cueListPlaybackStatus(cueListId: ID!): CueListPlaybackStatus

  # Cues
  cue(id: ID!): Cue

  searchCues(
    cueListId: ID!
    query: String!
    page: Int = 1
    perPage: Int = 50
  ): CuePage!

  # DMX Output
  dmxOutput(universe: Int!): [Int!]!
  allDmxOutput: [UniverseOutput!]!

  # Preview System
  previewSession(sessionId: ID!): PreviewSession

  # Active Scene Tracking
  currentActiveScene: Scene

  # Settings
  settings: [Setting!]!
  setting(key: String!): Setting

  # System Information
  systemInfo: SystemInfo!
  networkInterfaceOptions: [NetworkInterfaceOption!]!

  # WiFi Configuration
  wifiNetworks(rescan: Boolean = true, deduplicate: Boolean = true): [WiFiNetwork!]!
  wifiStatus: WiFiStatus!
  savedWifiNetworks: [WiFiNetwork!]!

  # QLC+ Fixture Mapping Suggestions (read-only)
  getQLCFixtureMappingSuggestions(projectId: ID!): QLCFixtureMappingResult!

  # Version Management
  systemVersions: SystemVersionInfo!
  availableVersions(repository: String!): [String!]!

  # Open Fixture Library
  "Get the current status of any ongoing OFL import"
  oflImportStatus: OFLImportStatus!
  "Check for available OFL updates without importing"
  checkOFLUpdates: OFLUpdateCheckResult!

  # Bulk Read Queries
  fixturesByIds(ids: [ID!]!): [FixtureInstance!]!
  scenesByIds(ids: [ID!]!): [Scene!]!
  cuesByIds(ids: [ID!]!): [Cue!]!
  cueListsByIds(ids: [ID!]!): [CueList!]!
  sceneBoardsByIds(ids: [ID!]!): [SceneBoard!]!
  fixtureDefinitionsByIds(ids: [ID!]!): [FixtureDefinition!]!
  projectsByIds(ids: [ID!]!): [Project!]!
}

# =============================================================================
# MUTATIONS
# =============================================================================

type Mutation {
  # Project Management
  createProject(input: CreateProjectInput!): Project!
  updateProject(id: ID!, input: CreateProjectInput!): Project!
  deleteProject(id: ID!): Boolean!
  bulkCreateProjects(input: BulkProjectCreateInput!): [Project!]!
  bulkUpdateProjects(input: BulkProjectUpdateInput!): [Project!]!
  bulkDeleteProjects(projectIds: [ID!]!): BulkDeleteResult!

  # Fixture Definitions
  createFixtureDefinition(
    input: CreateFixtureDefinitionInput!
  ): FixtureDefinition!
  importOFLFixture(input: ImportOFLFixtureInput!): FixtureDefinition!
  updateFixtureDefinition(
    id: ID!
    input: CreateFixtureDefinitionInput!
  ): FixtureDefinition!
  deleteFixtureDefinition(id: ID!): Boolean!
  bulkCreateFixtureDefinitions(input: BulkFixtureDefinitionCreateInput!): [FixtureDefinition!]!
  bulkUpdateFixtureDefinitions(input: BulkFixtureDefinitionUpdateInput!): [FixtureDefinition!]!
  bulkDeleteFixtureDefinitions(definitionIds: [ID!]!): BulkDeleteResult!

  # Fixture Instances
  createFixtureInstance(input: CreateFixtureInstanceInput!): FixtureInstance!
  updateFixtureInstance(
    id: ID!
    input: UpdateFixtureInstanceInput!
  ): FixtureInstance!
  bulkUpdateFixtures(input: BulkFixtureUpdateInput!): [FixtureInstance!]!
  bulkCreateFixtures(input: BulkFixtureCreateInput!): [FixtureInstance!]!
  deleteFixtureInstance(id: ID!): Boolean!
  bulkDeleteFixtures(fixtureIds: [ID!]!): BulkDeleteResult!

  # Instance Channel Updates
  updateInstanceChannelFadeBehavior(
    channelId: ID!
    fadeBehavior: FadeBehavior!
  ): InstanceChannel!
  bulkUpdateInstanceChannelsFadeBehavior(
    updates: [ChannelFadeBehaviorInput!]!
  ): [InstanceChannel!]!

  # Fixture Ordering
  reorderProjectFixtures(
    projectId: ID!
    fixtureOrders: [FixtureOrderInput!]!
  ): Boolean!
  reorderSceneFixtures(
    sceneId: ID!
    fixtureOrders: [FixtureOrderInput!]!
  ): Boolean!

  # Fixture Layout Positions
  updateFixturePositions(positions: [FixturePositionInput!]!): Boolean!

  # Scenes
  createScene(input: CreateSceneInput!): Scene!
  updateScene(id: ID!, input: UpdateSceneInput!): Scene!
  duplicateScene(id: ID!): Scene!
  cloneScene(sceneId: ID!, newName: String!): Scene!
  deleteScene(id: ID!): Boolean!
  bulkCreateScenes(input: BulkSceneCreateInput!): [Scene!]!
  bulkUpdateScenes(input: BulkSceneUpdateInput!): [Scene!]!
  bulkDeleteScenes(sceneIds: [ID!]!): BulkDeleteResult!

  # Safe Scene Updates (Additive)
  addFixturesToScene(
    sceneId: ID!
    fixtureValues: [FixtureValueInput!]!
    overwriteExisting: Boolean = false
  ): Scene!
  removeFixturesFromScene(sceneId: ID!, fixtureIds: [ID!]!): Scene!
  updateScenePartial(
    sceneId: ID!
    name: String
    description: String
    fixtureValues: [FixtureValueInput!]
    mergeFixtures: Boolean = true
  ): Scene!

  # Scene Boards
  createSceneBoard(input: CreateSceneBoardInput!): SceneBoard!
  updateSceneBoard(id: ID!, input: UpdateSceneBoardInput!): SceneBoard!
  deleteSceneBoard(id: ID!): Boolean!
  bulkCreateSceneBoards(input: BulkSceneBoardCreateInput!): [SceneBoard!]!
  bulkUpdateSceneBoards(input: BulkSceneBoardUpdateInput!): [SceneBoard!]!
  bulkDeleteSceneBoards(sceneBoardIds: [ID!]!): BulkDeleteResult!

  # Scene Board Buttons
  addSceneToBoard(input: CreateSceneBoardButtonInput!): SceneBoardButton!
  updateSceneBoardButton(
    id: ID!
    input: UpdateSceneBoardButtonInput!
  ): SceneBoardButton!
  removeSceneFromBoard(buttonId: ID!): Boolean!
  updateSceneBoardButtonPositions(
    positions: [SceneBoardButtonPositionInput!]!
  ): Boolean!
  bulkCreateSceneBoardButtons(input: BulkSceneBoardButtonCreateInput!): [SceneBoardButton!]!
  bulkUpdateSceneBoardButtons(input: BulkSceneBoardButtonUpdateInput!): [SceneBoardButton!]!
  bulkDeleteSceneBoardButtons(buttonIds: [ID!]!): BulkDeleteResult!

  # Scene Board Playback (activates scene with board's fade time)
  activateSceneFromBoard(
    sceneBoardId: ID!
    sceneId: ID!
    fadeTimeOverride: Float
  ): Boolean!

  # Cue Lists
  createCueList(input: CreateCueListInput!): CueList!
  updateCueList(id: ID!, input: CreateCueListInput!): CueList!
  deleteCueList(id: ID!): Boolean!
  bulkCreateCueLists(input: BulkCueListCreateInput!): [CueList!]!
  bulkUpdateCueLists(input: BulkCueListUpdateInput!): [CueList!]!
  bulkDeleteCueLists(cueListIds: [ID!]!): BulkDeleteResult!

  # Cues
  createCue(input: CreateCueInput!): Cue!
  updateCue(id: ID!, input: CreateCueInput!): Cue!
  deleteCue(id: ID!): Boolean!
  reorderCues(cueListId: ID!, cueOrders: [CueOrderInput!]!): Boolean!
  bulkCreateCues(input: BulkCueCreateInput!): [Cue!]!
  bulkUpdateCues(input: BulkCueUpdateInput!): [Cue!]!
  bulkDeleteCues(cueIds: [ID!]!): BulkDeleteResult!

  # Preview System
  startPreviewSession(projectId: ID!): PreviewSession!
  commitPreviewSession(sessionId: ID!): Boolean!
  cancelPreviewSession(sessionId: ID!): Boolean!
  updatePreviewChannel(
    sessionId: ID!
    fixtureId: ID!
    channelIndex: Int!
    value: Int!
  ): Boolean!
  initializePreviewWithScene(sessionId: ID!, sceneId: ID!): Boolean!

  # DMX Control
  setChannelValue(universe: Int!, channel: Int!, value: Int!): Boolean!
  setSceneLive(sceneId: ID!): Boolean!
  playCue(cueId: ID!, fadeInTime: Float): Boolean!
  fadeToBlack(fadeOutTime: Float!): Boolean!

  # Cue List Playback Control
  startCueList(cueListId: ID!, startFromCue: Int, fadeInTime: Float): Boolean!
  nextCue(cueListId: ID!, fadeInTime: Float): Boolean!
  previousCue(cueListId: ID!, fadeInTime: Float): Boolean!
  goToCue(cueListId: ID!, cueIndex: Int!, fadeInTime: Float): Boolean!
  stopCueList(cueListId: ID!): Boolean!

  # Native LacyLights Import/Export
  exportProject(projectId: ID!, options: ExportOptionsInput): ExportResult!
  importProject(jsonContent: String!, options: ImportOptionsInput!): ImportResult!

  # QLC+ Import/Export (data-modifying operations)
  importProjectFromQLC(
    xmlContent: String!
    originalFileName: String!
  ): QLCImportResult!
  exportProjectToQLC(
    projectId: ID!
    fixtureMappings: [FixtureMappingInput!]
  ): QLCExportResult!

  # Settings
  updateSetting(input: UpdateSettingInput!): Setting!

  # WiFi Configuration
  connectWiFi(ssid: String!, password: String): WiFiConnectionResult!
  disconnectWiFi: WiFiConnectionResult!
  setWiFiEnabled(enabled: Boolean!): WiFiStatus!
  forgetWiFiNetwork(ssid: String!): Boolean!

  # Version Management
  updateRepository(repository: String!, version: String = "latest"): UpdateResult!
  updateAllRepositories: [UpdateResult!]!

  # Open Fixture Library
  "Trigger an OFL import/update operation"
  triggerOFLImport(options: OFLImportOptionsInput): OFLImportResult!
  "Cancel an ongoing OFL import"
  cancelOFLImport: Boolean!
}

# =============================================================================
# SUBSCRIPTIONS
# =============================================================================

type Subscription {
  dmxOutputChanged(universe: Int): UniverseOutput!
  projectUpdated(projectId: ID!): Project!
  previewSessionUpdated(projectId: ID!): PreviewSession!
  cueListPlaybackUpdated(cueListId: ID!): CueListPlaybackStatus!
  systemInfoUpdated: SystemInfo!
  wifiStatusUpdated: WiFiStatus!
  "Real-time updates during OFL import"
  oflImportProgress: OFLImportStatus!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_activateSceneFromBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneBoardId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneBoardId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "fadeTimeOverride", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeTimeOverride"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_addFixturesToScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureValues", ec.unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput)
	if err != nil {
		return nil, err
	}
	args["fixtureValues"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "overwriteExisting", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["overwriteExisting"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_addSceneToBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateCueLists_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCueListCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueListCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateCues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCueCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateFixtureDefinitions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkFixtureDefinitionCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureDefinitionCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkFixtureCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateProjects_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkProjectCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkProjectCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateSceneBoardButtons_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneBoardButtonCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardButtonCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateSceneBoards_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneBoardCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateScenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneCreateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteCueLists_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteCues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteFixtureDefinitions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "definitionIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["definitionIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["fixtureIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteProjects_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteSceneBoardButtons_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "buttonIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["buttonIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteSceneBoards_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneBoardIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneBoardIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteScenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateCueLists_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCueListUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueListUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateCues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCueUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateFixtureDefinitions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkFixtureDefinitionUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureDefinitionUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkFixtureUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateInstanceChannelsFadeBehavior_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "updates", ec.unmarshalNChannelFadeBehaviorInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelFadeBehaviorInput)
	if err != nil {
		return nil, err
	}
	args["updates"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateProjects_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkProjectUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkProjectUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateSceneBoardButtons_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneBoardButtonUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardButtonUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateSceneBoards_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneBoardUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkUpdateScenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkSceneUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneUpdateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelPreviewSession_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sessionId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cloneScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "newName", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["newName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_commitPreviewSession_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sessionId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_connectWiFi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ssid", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["ssid"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "password", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["password"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createCueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFixtureDefinition_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFixtureInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSceneBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFixtureDefinition_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFixtureInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSceneBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_duplicateScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_exportProjectToQLC_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureMappings", ec.unmarshalOFixtureMappingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingInput)
	if err != nil {
		return nil, err
	}
	args["fixtureMappings"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_exportProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalOExportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportOptionsInput)
	if err != nil {
		return nil, err
	}
	args["options"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_fadeToBlack_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "fadeOutTime", ec.unmarshalNFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeOutTime"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_forgetWiFiNetwork_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ssid", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["ssid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_goToCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "cueIndex", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["cueIndex"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "fadeInTime", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeInTime"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_importOFLFixture_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNImportOFLFixtureInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportOFLFixtureInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_importProjectFromQLC_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "xmlContent", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["xmlContent"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "originalFileName", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["originalFileName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_importProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "jsonContent", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["jsonContent"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNImportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportOptionsInput)
	if err != nil {
		return nil, err
	}
	args["options"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_initializePreviewWithScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sessionId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sessionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_nextCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fadeInTime", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeInTime"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_playCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fadeInTime", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeInTime"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_previousCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fadeInTime", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeInTime"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_removeFixturesFromScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureIds", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["fixtureIds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_removeSceneFromBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "buttonId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["buttonId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reorderCues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "cueOrders", ec.unmarshalNCueOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueOrderInput)
	if err != nil {
		return nil, err
	}
	args["cueOrders"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reorderProjectFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureOrders", ec.unmarshalNFixtureOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureOrderInput)
	if err != nil {
		return nil, err
	}
	args["fixtureOrders"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reorderSceneFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureOrders", ec.unmarshalNFixtureOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureOrderInput)
	if err != nil {
		return nil, err
	}
	args["fixtureOrders"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setChannelValue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "universe", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["universe"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "channel", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["channel"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "value", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setSceneLive_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setWiFiEnabled_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "enabled", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["enabled"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_startCueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "startFromCue", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["startFromCue"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "fadeInTime", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["fadeInTime"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_startPreviewSession_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_stopCueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_triggerOFLImport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalOOFLImportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportOptionsInput)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFixtureDefinition_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFixtureInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateFixtureInstanceInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFixturePositions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "positions", ec.unmarshalNFixturePositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixturePositionInput)
	if err != nil {
		return nil, err
	}
	args["positions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateInstanceChannelFadeBehavior_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "channelId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["channelId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fadeBehavior", ec.unmarshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior)
	if err != nil {
		return nil, err
	}
	args["fadeBehavior"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePreviewChannel_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sessionId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sessionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["fixtureId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "channelIndex", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["channelIndex"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "value", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["value"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRepository_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "repository", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["repository"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "version", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["version"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSceneBoardButtonPositions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "positions", ec.unmarshalNSceneBoardButtonPositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonPositionInput)
	if err != nil {
		return nil, err
	}
	args["positions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSceneBoardButton_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneBoardButtonInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSceneBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneBoardInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateScenePartial_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "description", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["description"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureValues", ec.unmarshalOFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput)
	if err != nil {
		return nil, err
	}
	args["fixtureValues"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "mergeFixtures", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["mergeFixtures"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_updateScene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateSettingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSettingInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_availableVersions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "repository", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["repository"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_channelMap_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "universe", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["universe"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_compareScenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId1", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId1"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId2", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId2"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cueListPlaybackStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cueList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "includeSceneDetails", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeSceneDetails"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_cueListsByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cueLists_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cuesByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_dmxOutput_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "universe", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["universe"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixtureDefinition_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixtureDefinitionsByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixtureDefinitions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOFixtureDefinitionFilter2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixtureInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixtureInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOFixtureFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_fixtureUsage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "fixtureId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["fixtureId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fixturesByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getQLCFixtureMappingSuggestions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_previewSession_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sessionId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_projectsByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneBoardButton_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneBoard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneBoardsByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneBoards_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sceneUsage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "sceneId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["sceneId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_scene_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "includeFixtureValues", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeFixtureValues"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_scenesByIds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_scenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOSceneFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "sortBy", ec.unmarshalOSceneSortField2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSortField)
	if err != nil {
		return nil, err
	}
	args["sortBy"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_searchCues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_searchFixtures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOFixtureFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_searchScenes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOSceneFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "perPage", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["perPage"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_setting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "key", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_suggestChannelAssignment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNChannelAssignmentInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelAssignmentInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_wifiNetworks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "rescan", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["rescan"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "deduplicate", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["deduplicate"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_cueListPlaybackUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cueListId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["cueListId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_dmxOutputChanged_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "universe", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["universe"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_previewSessionUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_projectUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BulkDeleteResult_deletedCount(ctx context.Context, field graphql.CollectedField, obj *BulkDeleteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkDeleteResult_deletedCount,
		func(ctx context.Context) (any, error) {
			return obj.DeletedCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkDeleteResult_deletedCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkDeleteResult_deletedIds(ctx context.Context, field graphql.CollectedField, obj *BulkDeleteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkDeleteResult_deletedIds,
		func(ctx context.Context) (any, error) {
			return obj.DeletedIds, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkDeleteResult_deletedIds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAssignmentSuggestion_universe(ctx context.Context, field graphql.CollectedField, obj *ChannelAssignmentSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelAssignmentSuggestion_universe,
		func(ctx context.Context) (any, error) {
			return obj.Universe, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelAssignmentSuggestion_universe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAssignmentSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAssignmentSuggestion_assignments(ctx context.Context, field graphql.CollectedField, obj *ChannelAssignmentSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelAssignmentSuggestion_assignments,
		func(ctx context.Context) (any, error) {
			return obj.Assignments, nil
		},
		nil,
		ec.marshalNFixtureChannelAssignment2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureChannelAssignment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelAssignmentSuggestion_assignments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAssignmentSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureName":
				return ec.fieldContext_FixtureChannelAssignment_fixtureName(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureChannelAssignment_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureChannelAssignment_model(ctx, field)
			case "mode":
				return ec.fieldContext_FixtureChannelAssignment_mode(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureChannelAssignment_startChannel(ctx, field)
			case "endChannel":
				return ec.fieldContext_FixtureChannelAssignment_endChannel(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureChannelAssignment_channelCount(ctx, field)
			case "channelRange":
				return ec.fieldContext_FixtureChannelAssignment_channelRange(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureChannelAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAssignmentSuggestion_totalChannelsNeeded(ctx context.Context, field graphql.CollectedField, obj *ChannelAssignmentSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelAssignmentSuggestion_totalChannelsNeeded,
		func(ctx context.Context) (any, error) {
			return obj.TotalChannelsNeeded, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelAssignmentSuggestion_totalChannelsNeeded(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAssignmentSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAssignmentSuggestion_availableChannelsRemaining(ctx context.Context, field graphql.CollectedField, obj *ChannelAssignmentSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelAssignmentSuggestion_availableChannelsRemaining,
		func(ctx context.Context) (any, error) {
			return obj.AvailableChannelsRemaining, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelAssignmentSuggestion_availableChannelsRemaining(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAssignmentSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_id(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_name(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_type(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ChannelDefinition().Type(ctx, obj)
		},
		nil,
		ec.marshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChannelType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_offset(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_offset,
		func(ctx context.Context) (any, error) {
			return obj.Offset, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_minValue(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_minValue,
		func(ctx context.Context) (any, error) {
			return obj.MinValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_minValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_maxValue(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_maxValue,
		func(ctx context.Context) (any, error) {
			return obj.MaxValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_maxValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_defaultValue(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_fadeBehavior(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_fadeBehavior,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ChannelDefinition().FadeBehavior(ctx, obj)
		},
		nil,
		ec.marshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_fadeBehavior(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FadeBehavior does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelDefinition_isDiscrete(ctx context.Context, field graphql.CollectedField, obj *models.ChannelDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelDefinition_isDiscrete,
		func(ctx context.Context) (any, error) {
			return obj.IsDiscrete, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelDefinition_isDiscrete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_id(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_name(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_type(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixtureType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_startChannel(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_startChannel,
		func(ctx context.Context) (any, error) {
			return obj.StartChannel, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_startChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_endChannel(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_endChannel,
		func(ctx context.Context) (any, error) {
			return obj.EndChannel, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_endChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapFixture_channelCount(ctx context.Context, field graphql.CollectedField, obj *ChannelMapFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapFixture_channelCount,
		func(ctx context.Context) (any, error) {
			return obj.ChannelCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapFixture_channelCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapResult_projectId(ctx context.Context, field graphql.CollectedField, obj *ChannelMapResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapResult_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapResult_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMapResult_universes(ctx context.Context, field graphql.CollectedField, obj *ChannelMapResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelMapResult_universes,
		func(ctx context.Context) (any, error) {
			return obj.Universes, nil
		},
		nil,
		ec.marshalNUniverseChannelMap2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseChannelMap,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelMapResult_universes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMapResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "universe":
				return ec.fieldContext_UniverseChannelMap_universe(ctx, field)
			case "fixtures":
				return ec.fieldContext_UniverseChannelMap_fixtures(ctx, field)
			case "channelUsage":
				return ec.fieldContext_UniverseChannelMap_channelUsage(ctx, field)
			case "availableChannels":
				return ec.fieldContext_UniverseChannelMap_availableChannels(ctx, field)
			case "usedChannels":
				return ec.fieldContext_UniverseChannelMap_usedChannels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UniverseChannelMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelUsage_fixtureId(ctx context.Context, field graphql.CollectedField, obj *ChannelUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelUsage_fixtureId,
		func(ctx context.Context) (any, error) {
			return obj.FixtureID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelUsage_fixtureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelUsage_fixtureName(ctx context.Context, field graphql.CollectedField, obj *ChannelUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelUsage_fixtureName,
		func(ctx context.Context) (any, error) {
			return obj.FixtureName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelUsage_fixtureName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelUsage_channelType(ctx context.Context, field graphql.CollectedField, obj *ChannelUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelUsage_channelType,
		func(ctx context.Context) (any, error) {
			return obj.ChannelType, nil
		},
		nil,
		ec.marshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelUsage_channelType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChannelType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelValue_offset(ctx context.Context, field graphql.CollectedField, obj *models.ChannelValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelValue_offset,
		func(ctx context.Context) (any, error) {
			return obj.Offset, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelValue_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelValue_value(ctx context.Context, field graphql.CollectedField, obj *models.ChannelValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChannelValue_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChannelValue_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_id(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_name(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_cueNumber(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_cueNumber,
		func(ctx context.Context) (any, error) {
			return obj.CueNumber, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_cueNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_scene(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_scene,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Cue().Scene(ctx, obj)
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_scene(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_cueList(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_cueList,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Cue().CueList(ctx, obj)
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_cueList(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_fadeInTime(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_fadeInTime,
		func(ctx context.Context) (any, error) {
			return obj.FadeInTime, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_fadeInTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_fadeOutTime(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_fadeOutTime,
		func(ctx context.Context) (any, error) {
			return obj.FadeOutTime, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Cue_fadeOutTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_followTime(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_followTime,
		func(ctx context.Context) (any, error) {
			return obj.FollowTime, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Cue_followTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_easingType(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_easingType,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Cue().EasingType(ctx, obj)
		},
		nil,
		ec.marshalOEasingType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedEasingType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Cue_easingType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EasingType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cue_notes(ctx context.Context, field graphql.CollectedField, obj *models.Cue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cue_notes,
		func(ctx context.Context) (any, error) {
			return obj.Notes, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Cue_notes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_id(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_name(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_description(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueList_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_loop(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_loop,
		func(ctx context.Context) (any, error) {
			return obj.Loop, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_loop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_project(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_cues(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_cues,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().Cues(ctx, obj)
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_cues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_cueCount(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_cueCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().CueCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_cueCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_totalDuration(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_totalDuration,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().TotalDuration(ctx, obj)
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_totalDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueList_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.CueList) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueList_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CueList().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueList_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_cueListId(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_cueListId,
		func(ctx context.Context) (any, error) {
			return obj.CueListID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_cueListId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_currentCueIndex(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_currentCueIndex,
		func(ctx context.Context) (any, error) {
			return obj.CurrentCueIndex, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_currentCueIndex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_isPlaying(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_isPlaying,
		func(ctx context.Context) (any, error) {
			return obj.IsPlaying, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_isPlaying(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_isFading(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_isFading,
		func(ctx context.Context) (any, error) {
			return obj.IsFading, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_isFading(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_currentCue(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_currentCue,
		func(ctx context.Context) (any, error) {
			return obj.CurrentCue, nil
		},
		nil,
		ec.marshalOCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_currentCue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_nextCue(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_nextCue,
		func(ctx context.Context) (any, error) {
			return obj.NextCue, nil
		},
		nil,
		ec.marshalOCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_nextCue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_previousCue(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_previousCue,
		func(ctx context.Context) (any, error) {
			return obj.PreviousCue, nil
		},
		nil,
		ec.marshalOCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_previousCue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_fadeProgress(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_fadeProgress,
		func(ctx context.Context) (any, error) {
			return obj.FadeProgress, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_fadeProgress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListPlaybackStatus_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *CueListPlaybackStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListPlaybackStatus_lastUpdated,
		func(ctx context.Context) (any, error) {
			return obj.LastUpdated, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListPlaybackStatus_lastUpdated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListPlaybackStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_id(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_name(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_description(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_cueCount(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_cueCount,
		func(ctx context.Context) (any, error) {
			return obj.CueCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_cueCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_totalDuration(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_totalDuration,
		func(ctx context.Context) (any, error) {
			return obj.TotalDuration, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_totalDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_loop(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_loop,
		func(ctx context.Context) (any, error) {
			return obj.Loop, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_loop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueListSummary_createdAt(ctx context.Context, field graphql.CollectedField, obj *CueListSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueListSummary_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueListSummary_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueListSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CuePage_cues(ctx context.Context, field graphql.CollectedField, obj *CuePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CuePage_cues,
		func(ctx context.Context) (any, error) {
			return obj.Cues, nil
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CuePage_cues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CuePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CuePage_pagination(ctx context.Context, field graphql.CollectedField, obj *CuePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CuePage_pagination,
		func(ctx context.Context) (any, error) {
			return obj.Pagination, nil
		},
		nil,
		ec.marshalNPaginationInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedPaginationInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CuePage_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CuePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "perPage":
				return ec.fieldContext_PaginationInfo_perPage(ctx, field)
			case "totalPages":
				return ec.fieldContext_PaginationInfo_totalPages(ctx, field)
			case "hasMore":
				return ec.fieldContext_PaginationInfo_hasMore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueUsageSummary_cueId(ctx context.Context, field graphql.CollectedField, obj *CueUsageSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueUsageSummary_cueId,
		func(ctx context.Context) (any, error) {
			return obj.CueID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueUsageSummary_cueId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueUsageSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueUsageSummary_cueNumber(ctx context.Context, field graphql.CollectedField, obj *CueUsageSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueUsageSummary_cueNumber,
		func(ctx context.Context) (any, error) {
			return obj.CueNumber, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueUsageSummary_cueNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueUsageSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueUsageSummary_cueName(ctx context.Context, field graphql.CollectedField, obj *CueUsageSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueUsageSummary_cueName,
		func(ctx context.Context) (any, error) {
			return obj.CueName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueUsageSummary_cueName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueUsageSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueUsageSummary_cueListId(ctx context.Context, field graphql.CollectedField, obj *CueUsageSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueUsageSummary_cueListId,
		func(ctx context.Context) (any, error) {
			return obj.CueListID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueUsageSummary_cueListId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueUsageSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CueUsageSummary_cueListName(ctx context.Context, field graphql.CollectedField, obj *CueUsageSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CueUsageSummary_cueListName,
		func(ctx context.Context) (any, error) {
			return obj.CueListName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CueUsageSummary_cueListName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CueUsageSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportResult_projectId(ctx context.Context, field graphql.CollectedField, obj *ExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportResult_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportResult_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportResult_projectName(ctx context.Context, field graphql.CollectedField, obj *ExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportResult_projectName,
		func(ctx context.Context) (any, error) {
			return obj.ProjectName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportResult_projectName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportResult_jsonContent(ctx context.Context, field graphql.CollectedField, obj *ExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportResult_jsonContent,
		func(ctx context.Context) (any, error) {
			return obj.JSONContent, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportResult_jsonContent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportResult_stats(ctx context.Context, field graphql.CollectedField, obj *ExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportResult_stats,
		func(ctx context.Context) (any, error) {
			return obj.Stats, nil
		},
		nil,
		ec.marshalNExportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportResult_stats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureDefinitionsCount":
				return ec.fieldContext_ExportStats_fixtureDefinitionsCount(ctx, field)
			case "fixtureInstancesCount":
				return ec.fieldContext_ExportStats_fixtureInstancesCount(ctx, field)
			case "scenesCount":
				return ec.fieldContext_ExportStats_scenesCount(ctx, field)
			case "cueListsCount":
				return ec.fieldContext_ExportStats_cueListsCount(ctx, field)
			case "cuesCount":
				return ec.fieldContext_ExportStats_cuesCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExportStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportStats_fixtureDefinitionsCount(ctx context.Context, field graphql.CollectedField, obj *ExportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportStats_fixtureDefinitionsCount,
		func(ctx context.Context) (any, error) {
			return obj.FixtureDefinitionsCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportStats_fixtureDefinitionsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportStats_fixtureInstancesCount(ctx context.Context, field graphql.CollectedField, obj *ExportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportStats_fixtureInstancesCount,
		func(ctx context.Context) (any, error) {
			return obj.FixtureInstancesCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportStats_fixtureInstancesCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportStats_scenesCount(ctx context.Context, field graphql.CollectedField, obj *ExportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportStats_scenesCount,
		func(ctx context.Context) (any, error) {
			return obj.ScenesCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportStats_scenesCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportStats_cueListsCount(ctx context.Context, field graphql.CollectedField, obj *ExportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportStats_cueListsCount,
		func(ctx context.Context) (any, error) {
			return obj.CueListsCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportStats_cueListsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportStats_cuesCount(ctx context.Context, field graphql.CollectedField, obj *ExportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExportStats_cuesCount,
		func(ctx context.Context) (any, error) {
			return obj.CuesCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExportStats_cuesCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_fixtureName(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_fixtureName,
		func(ctx context.Context) (any, error) {
			return obj.FixtureName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_fixtureName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_manufacturer(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_model(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_mode(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_mode,
		func(ctx context.Context) (any, error) {
			return obj.Mode, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_mode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_startChannel(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_startChannel,
		func(ctx context.Context) (any, error) {
			return obj.StartChannel, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_startChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_endChannel(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_endChannel,
		func(ctx context.Context) (any, error) {
			return obj.EndChannel, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_endChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_channelCount(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_channelCount,
		func(ctx context.Context) (any, error) {
			return obj.ChannelCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_channelCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureChannelAssignment_channelRange(ctx context.Context, field graphql.CollectedField, obj *FixtureChannelAssignment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureChannelAssignment_channelRange,
		func(ctx context.Context) (any, error) {
			return obj.ChannelRange, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureChannelAssignment_channelRange(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureChannelAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_id(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_manufacturer(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_model(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_type(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureDefinition().Type(ctx, obj)
		},
		nil,
		ec.marshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixtureType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_channels(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_channels,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureDefinition().Channels(ctx, obj)
		},
		nil,
		ec.marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_channels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChannelDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_ChannelDefinition_name(ctx, field)
			case "type":
				return ec.fieldContext_ChannelDefinition_type(ctx, field)
			case "offset":
				return ec.fieldContext_ChannelDefinition_offset(ctx, field)
			case "minValue":
				return ec.fieldContext_ChannelDefinition_minValue(ctx, field)
			case "maxValue":
				return ec.fieldContext_ChannelDefinition_maxValue(ctx, field)
			case "defaultValue":
				return ec.fieldContext_ChannelDefinition_defaultValue(ctx, field)
			case "fadeBehavior":
				return ec.fieldContext_ChannelDefinition_fadeBehavior(ctx, field)
			case "isDiscrete":
				return ec.fieldContext_ChannelDefinition_isDiscrete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_modes(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_modes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureDefinition().Modes(ctx, obj)
		},
		nil,
		ec.marshalNFixtureMode2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureMode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_modes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureMode_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureMode_name(ctx, field)
			case "shortName":
				return ec.fieldContext_FixtureMode_shortName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureMode_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureMode_channels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureMode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_isBuiltIn(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_isBuiltIn,
		func(ctx context.Context) (any, error) {
			return obj.IsBuiltIn, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_isBuiltIn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureDefinition_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.FixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureDefinition_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureDefinition().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureDefinition_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_id(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_name(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_description(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_definitionId(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_definitionId,
		func(ctx context.Context) (any, error) {
			return obj.DefinitionID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_definitionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_manufacturer(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_manufacturer,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Manufacturer(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_model(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_model,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Model(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_type(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Type(ctx, obj)
		},
		nil,
		ec.marshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixtureType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_modeName(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_modeName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().ModeName(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_modeName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_channelCount(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_channelCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().ChannelCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_channelCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_channels(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_channels,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Channels(ctx, obj)
		},
		nil,
		ec.marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_channels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InstanceChannel_id(ctx, field)
			case "offset":
				return ec.fieldContext_InstanceChannel_offset(ctx, field)
			case "name":
				return ec.fieldContext_InstanceChannel_name(ctx, field)
			case "type":
				return ec.fieldContext_InstanceChannel_type(ctx, field)
			case "minValue":
				return ec.fieldContext_InstanceChannel_minValue(ctx, field)
			case "maxValue":
				return ec.fieldContext_InstanceChannel_maxValue(ctx, field)
			case "defaultValue":
				return ec.fieldContext_InstanceChannel_defaultValue(ctx, field)
			case "fadeBehavior":
				return ec.fieldContext_InstanceChannel_fadeBehavior(ctx, field)
			case "isDiscrete":
				return ec.fieldContext_InstanceChannel_isDiscrete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceChannel", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_project(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_universe(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_universe,
		func(ctx context.Context) (any, error) {
			return obj.Universe, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_universe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_startChannel(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_startChannel,
		func(ctx context.Context) (any, error) {
			return obj.StartChannel, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_startChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_tags(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_tags,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().Tags(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_projectOrder(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_projectOrder,
		func(ctx context.Context) (any, error) {
			return obj.ProjectOrder, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_projectOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_layoutX(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_layoutX,
		func(ctx context.Context) (any, error) {
			return obj.LayoutX, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_layoutX(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_layoutY(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_layoutY,
		func(ctx context.Context) (any, error) {
			return obj.LayoutY, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_layoutY(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_layoutRotation(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_layoutRotation,
		func(ctx context.Context) (any, error) {
			return obj.LayoutRotation, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_layoutRotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstance_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.FixtureInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstance_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureInstance().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstance_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstancePage_fixtures(ctx context.Context, field graphql.CollectedField, obj *FixtureInstancePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstancePage_fixtures,
		func(ctx context.Context) (any, error) {
			return obj.Fixtures, nil
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstancePage_fixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstancePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureInstancePage_pagination(ctx context.Context, field graphql.CollectedField, obj *FixtureInstancePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureInstancePage_pagination,
		func(ctx context.Context) (any, error) {
			return obj.Pagination, nil
		},
		nil,
		ec.marshalNPaginationInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedPaginationInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureInstancePage_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureInstancePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "perPage":
				return ec.fieldContext_PaginationInfo_perPage(ctx, field)
			case "totalPages":
				return ec.fieldContext_PaginationInfo_totalPages(ctx, field)
			case "hasMore":
				return ec.fieldContext_PaginationInfo_hasMore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMapping_lacyLightsKey(ctx context.Context, field graphql.CollectedField, obj *FixtureMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMapping_lacyLightsKey,
		func(ctx context.Context) (any, error) {
			return obj.LacyLightsKey, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMapping_lacyLightsKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMapping_qlcManufacturer(ctx context.Context, field graphql.CollectedField, obj *FixtureMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMapping_qlcManufacturer,
		func(ctx context.Context) (any, error) {
			return obj.QlcManufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMapping_qlcManufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMapping_qlcModel(ctx context.Context, field graphql.CollectedField, obj *FixtureMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMapping_qlcModel,
		func(ctx context.Context) (any, error) {
			return obj.QlcModel, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMapping_qlcModel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMapping_qlcMode(ctx context.Context, field graphql.CollectedField, obj *FixtureMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMapping_qlcMode,
		func(ctx context.Context) (any, error) {
			return obj.QlcMode, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMapping_qlcMode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMappingSuggestion_fixture(ctx context.Context, field graphql.CollectedField, obj *FixtureMappingSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMappingSuggestion_fixture,
		func(ctx context.Context) (any, error) {
			return obj.Fixture, nil
		},
		nil,
		ec.marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMappingSuggestion_fixture(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMappingSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "manufacturer":
				return ec.fieldContext_LacyLightsFixture_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_LacyLightsFixture_model(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LacyLightsFixture", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMappingSuggestion_suggestions(ctx context.Context, field graphql.CollectedField, obj *FixtureMappingSuggestion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMappingSuggestion_suggestions,
		func(ctx context.Context) (any, error) {
			return obj.Suggestions, nil
		},
		nil,
		ec.marshalNQLCFixtureDefinition2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMappingSuggestion_suggestions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMappingSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "manufacturer":
				return ec.fieldContext_QLCFixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_QLCFixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_QLCFixtureDefinition_type(ctx, field)
			case "modes":
				return ec.fieldContext_QLCFixtureDefinition_modes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QLCFixtureDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMode_id(ctx context.Context, field graphql.CollectedField, obj *models.FixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMode_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMode_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMode_name(ctx context.Context, field graphql.CollectedField, obj *models.FixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMode_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMode_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMode_shortName(ctx context.Context, field graphql.CollectedField, obj *models.FixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMode_shortName,
		func(ctx context.Context) (any, error) {
			return obj.ShortName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureMode_shortName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMode_channelCount(ctx context.Context, field graphql.CollectedField, obj *models.FixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMode_channelCount,
		func(ctx context.Context) (any, error) {
			return obj.ChannelCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMode_channelCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureMode_channels(ctx context.Context, field graphql.CollectedField, obj *models.FixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureMode_channels,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureMode().Channels(ctx, obj)
		},
		nil,
		ec.marshalNModeChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsModeChannel,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureMode_channels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureMode",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModeChannel_id(ctx, field)
			case "offset":
				return ec.fieldContext_ModeChannel_offset(ctx, field)
			case "channel":
				return ec.fieldContext_ModeChannel_channel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModeChannel", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureUsage_fixtureId(ctx context.Context, field graphql.CollectedField, obj *FixtureUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureUsage_fixtureId,
		func(ctx context.Context) (any, error) {
			return obj.FixtureID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureUsage_fixtureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureUsage_fixtureName(ctx context.Context, field graphql.CollectedField, obj *FixtureUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureUsage_fixtureName,
		func(ctx context.Context) (any, error) {
			return obj.FixtureName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureUsage_fixtureName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureUsage_scenes(ctx context.Context, field graphql.CollectedField, obj *FixtureUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureUsage_scenes,
		func(ctx context.Context) (any, error) {
			return obj.Scenes, nil
		},
		nil,
		ec.marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureUsage_scenes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneSummary_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneSummary_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_SceneSummary_fixtureCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneSummary_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneSummary_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureUsage_cues(ctx context.Context, field graphql.CollectedField, obj *FixtureUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureUsage_cues,
		func(ctx context.Context) (any, error) {
			return obj.Cues, nil
		},
		nil,
		ec.marshalNCueUsageSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueUsageSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureUsage_cues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cueId":
				return ec.fieldContext_CueUsageSummary_cueId(ctx, field)
			case "cueNumber":
				return ec.fieldContext_CueUsageSummary_cueNumber(ctx, field)
			case "cueName":
				return ec.fieldContext_CueUsageSummary_cueName(ctx, field)
			case "cueListId":
				return ec.fieldContext_CueUsageSummary_cueListId(ctx, field)
			case "cueListName":
				return ec.fieldContext_CueUsageSummary_cueListName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueUsageSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureValue_id(ctx context.Context, field graphql.CollectedField, obj *models.FixtureValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureValue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureValue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureValue_fixture(ctx context.Context, field graphql.CollectedField, obj *models.FixtureValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureValue_fixture,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureValue().Fixture(ctx, obj)
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureValue_fixture(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureValue_channels(ctx context.Context, field graphql.CollectedField, obj *models.FixtureValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureValue_channels,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FixtureValue().Channels(ctx, obj)
		},
		nil,
		ec.marshalNChannelValue2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FixtureValue_channels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "offset":
				return ec.fieldContext_ChannelValue_offset(ctx, field)
			case "value":
				return ec.fieldContext_ChannelValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FixtureValue_sceneOrder(ctx context.Context, field graphql.CollectedField, obj *models.FixtureValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FixtureValue_sceneOrder,
		func(ctx context.Context) (any, error) {
			return obj.SceneOrder, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FixtureValue_sceneOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FixtureValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportResult_projectId(ctx context.Context, field graphql.CollectedField, obj *ImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportResult_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportResult_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportResult_stats(ctx context.Context, field graphql.CollectedField, obj *ImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportResult_stats,
		func(ctx context.Context) (any, error) {
			return obj.Stats, nil
		},
		nil,
		ec.marshalNImportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportResult_stats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureDefinitionsCreated":
				return ec.fieldContext_ImportStats_fixtureDefinitionsCreated(ctx, field)
			case "fixtureInstancesCreated":
				return ec.fieldContext_ImportStats_fixtureInstancesCreated(ctx, field)
			case "scenesCreated":
				return ec.fieldContext_ImportStats_scenesCreated(ctx, field)
			case "cueListsCreated":
				return ec.fieldContext_ImportStats_cueListsCreated(ctx, field)
			case "cuesCreated":
				return ec.fieldContext_ImportStats_cuesCreated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImportStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportResult_warnings(ctx context.Context, field graphql.CollectedField, obj *ImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportResult_warnings,
		func(ctx context.Context) (any, error) {
			return obj.Warnings, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportResult_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportStats_fixtureDefinitionsCreated(ctx context.Context, field graphql.CollectedField, obj *ImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportStats_fixtureDefinitionsCreated,
		func(ctx context.Context) (any, error) {
			return obj.FixtureDefinitionsCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportStats_fixtureDefinitionsCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportStats_fixtureInstancesCreated(ctx context.Context, field graphql.CollectedField, obj *ImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportStats_fixtureInstancesCreated,
		func(ctx context.Context) (any, error) {
			return obj.FixtureInstancesCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportStats_fixtureInstancesCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportStats_scenesCreated(ctx context.Context, field graphql.CollectedField, obj *ImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportStats_scenesCreated,
		func(ctx context.Context) (any, error) {
			return obj.ScenesCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportStats_scenesCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportStats_cueListsCreated(ctx context.Context, field graphql.CollectedField, obj *ImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportStats_cueListsCreated,
		func(ctx context.Context) (any, error) {
			return obj.CueListsCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportStats_cueListsCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportStats_cuesCreated(ctx context.Context, field graphql.CollectedField, obj *ImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportStats_cuesCreated,
		func(ctx context.Context) (any, error) {
			return obj.CuesCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportStats_cuesCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_id(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_offset(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_offset,
		func(ctx context.Context) (any, error) {
			return obj.Offset, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_name(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_type(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InstanceChannel().Type(ctx, obj)
		},
		nil,
		ec.marshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChannelType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_minValue(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_minValue,
		func(ctx context.Context) (any, error) {
			return obj.MinValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_minValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_maxValue(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_maxValue,
		func(ctx context.Context) (any, error) {
			return obj.MaxValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_maxValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_defaultValue(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_fadeBehavior(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_fadeBehavior,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InstanceChannel().FadeBehavior(ctx, obj)
		},
		nil,
		ec.marshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_fadeBehavior(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FadeBehavior does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceChannel_isDiscrete(ctx context.Context, field graphql.CollectedField, obj *models.InstanceChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceChannel_isDiscrete,
		func(ctx context.Context) (any, error) {
			return obj.IsDiscrete, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceChannel_isDiscrete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LacyLightsFixture_manufacturer(ctx context.Context, field graphql.CollectedField, obj *LacyLightsFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LacyLightsFixture_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LacyLightsFixture_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LacyLightsFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LacyLightsFixture_model(ctx context.Context, field graphql.CollectedField, obj *LacyLightsFixture) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LacyLightsFixture_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LacyLightsFixture_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LacyLightsFixture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModeChannel_id(ctx context.Context, field graphql.CollectedField, obj *models.ModeChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModeChannel_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModeChannel_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModeChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModeChannel_offset(ctx context.Context, field graphql.CollectedField, obj *models.ModeChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModeChannel_offset,
		func(ctx context.Context) (any, error) {
			return obj.Offset, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModeChannel_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModeChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModeChannel_channel(ctx context.Context, field graphql.CollectedField, obj *models.ModeChannel) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModeChannel_channel,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ModeChannel().Channel(ctx, obj)
		},
		nil,
		ec.marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModeChannel_channel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModeChannel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChannelDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_ChannelDefinition_name(ctx, field)
			case "type":
				return ec.fieldContext_ChannelDefinition_type(ctx, field)
			case "offset":
				return ec.fieldContext_ChannelDefinition_offset(ctx, field)
			case "minValue":
				return ec.fieldContext_ChannelDefinition_minValue(ctx, field)
			case "maxValue":
				return ec.fieldContext_ChannelDefinition_maxValue(ctx, field)
			case "defaultValue":
				return ec.fieldContext_ChannelDefinition_defaultValue(ctx, field)
			case "fadeBehavior":
				return ec.fieldContext_ChannelDefinition_fadeBehavior(ctx, field)
			case "isDiscrete":
				return ec.fieldContext_ChannelDefinition_isDiscrete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateProject(ctx, fc.Args["input"].(CreateProjectInput))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateProject(ctx, fc.Args["id"].(string), fc.Args["input"].(CreateProjectInput))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteProject(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateProjects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateProjects,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateProjects(ctx, fc.Args["input"].(BulkProjectCreateInput))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateProjects_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateProjects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateProjects,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateProjects(ctx, fc.Args["input"].(BulkProjectUpdateInput))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateProjects_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteProjects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteProjects,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteProjects(ctx, fc.Args["projectIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteProjects_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFixtureDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createFixtureDefinition,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateFixtureDefinition(ctx, fc.Args["input"].(CreateFixtureDefinitionInput))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createFixtureDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFixtureDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_importOFLFixture(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_importOFLFixture,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ImportOFLFixture(ctx, fc.Args["input"].(ImportOFLFixtureInput))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_importOFLFixture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_importOFLFixture_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFixtureDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateFixtureDefinition,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateFixtureDefinition(ctx, fc.Args["id"].(string), fc.Args["input"].(CreateFixtureDefinitionInput))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateFixtureDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFixtureDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFixtureDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteFixtureDefinition,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteFixtureDefinition(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteFixtureDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFixtureDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateFixtureDefinitions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateFixtureDefinitions(ctx, fc.Args["input"].(BulkFixtureDefinitionCreateInput))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateFixtureDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateFixtureDefinitions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateFixtureDefinitions(ctx, fc.Args["input"].(BulkFixtureDefinitionUpdateInput))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateFixtureDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteFixtureDefinitions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteFixtureDefinitions(ctx, fc.Args["definitionIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteFixtureDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteFixtureDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFixtureInstance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createFixtureInstance,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateFixtureInstance(ctx, fc.Args["input"].(CreateFixtureInstanceInput))
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createFixtureInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFixtureInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFixtureInstance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateFixtureInstance,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateFixtureInstance(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateFixtureInstanceInput))
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateFixtureInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFixtureInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateFixtures(ctx, fc.Args["input"].(BulkFixtureUpdateInput))
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateFixtures(ctx, fc.Args["input"].(BulkFixtureCreateInput))
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFixtureInstance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteFixtureInstance,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteFixtureInstance(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteFixtureInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFixtureInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteFixtures(ctx, fc.Args["fixtureIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateInstanceChannelFadeBehavior(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateInstanceChannelFadeBehavior,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateInstanceChannelFadeBehavior(ctx, fc.Args["channelId"].(string), fc.Args["fadeBehavior"].(FadeBehavior))
		},
		nil,
		ec.marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateInstanceChannelFadeBehavior(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InstanceChannel_id(ctx, field)
			case "offset":
				return ec.fieldContext_InstanceChannel_offset(ctx, field)
			case "name":
				return ec.fieldContext_InstanceChannel_name(ctx, field)
			case "type":
				return ec.fieldContext_InstanceChannel_type(ctx, field)
			case "minValue":
				return ec.fieldContext_InstanceChannel_minValue(ctx, field)
			case "maxValue":
				return ec.fieldContext_InstanceChannel_maxValue(ctx, field)
			case "defaultValue":
				return ec.fieldContext_InstanceChannel_defaultValue(ctx, field)
			case "fadeBehavior":
				return ec.fieldContext_InstanceChannel_fadeBehavior(ctx, field)
			case "isDiscrete":
				return ec.fieldContext_InstanceChannel_isDiscrete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceChannel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateInstanceChannelFadeBehavior_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateInstanceChannelsFadeBehavior(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateInstanceChannelsFadeBehavior,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateInstanceChannelsFadeBehavior(ctx, fc.Args["updates"].([]*ChannelFadeBehaviorInput))
		},
		nil,
		ec.marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateInstanceChannelsFadeBehavior(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InstanceChannel_id(ctx, field)
			case "offset":
				return ec.fieldContext_InstanceChannel_offset(ctx, field)
			case "name":
				return ec.fieldContext_InstanceChannel_name(ctx, field)
			case "type":
				return ec.fieldContext_InstanceChannel_type(ctx, field)
			case "minValue":
				return ec.fieldContext_InstanceChannel_minValue(ctx, field)
			case "maxValue":
				return ec.fieldContext_InstanceChannel_maxValue(ctx, field)
			case "defaultValue":
				return ec.fieldContext_InstanceChannel_defaultValue(ctx, field)
			case "fadeBehavior":
				return ec.fieldContext_InstanceChannel_fadeBehavior(ctx, field)
			case "isDiscrete":
				return ec.fieldContext_InstanceChannel_isDiscrete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceChannel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateInstanceChannelsFadeBehavior_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reorderProjectFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_reorderProjectFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ReorderProjectFixtures(ctx, fc.Args["projectId"].(string), fc.Args["fixtureOrders"].([]*FixtureOrderInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_reorderProjectFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reorderProjectFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reorderSceneFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_reorderSceneFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ReorderSceneFixtures(ctx, fc.Args["sceneId"].(string), fc.Args["fixtureOrders"].([]*FixtureOrderInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_reorderSceneFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reorderSceneFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFixturePositions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateFixturePositions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateFixturePositions(ctx, fc.Args["positions"].([]*FixturePositionInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateFixturePositions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFixturePositions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateScene(ctx, fc.Args["input"].(CreateSceneInput))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateScene(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateSceneInput))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_duplicateScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_duplicateScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DuplicateScene(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_duplicateScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_duplicateScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cloneScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_cloneScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CloneScene(ctx, fc.Args["sceneId"].(string), fc.Args["newName"].(string))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_cloneScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cloneScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteScene(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateScenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateScenes(ctx, fc.Args["input"].(BulkSceneCreateInput))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateScenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateScenes(ctx, fc.Args["input"].(BulkSceneUpdateInput))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteScenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteScenes(ctx, fc.Args["sceneIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addFixturesToScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_addFixturesToScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AddFixturesToScene(ctx, fc.Args["sceneId"].(string), fc.Args["fixtureValues"].([]*FixtureValueInput), fc.Args["overwriteExisting"].(*bool))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_addFixturesToScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addFixturesToScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeFixturesFromScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removeFixturesFromScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemoveFixturesFromScene(ctx, fc.Args["sceneId"].(string), fc.Args["fixtureIds"].([]string))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removeFixturesFromScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeFixturesFromScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateScenePartial(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateScenePartial,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateScenePartial(ctx, fc.Args["sceneId"].(string), fc.Args["name"].(*string), fc.Args["description"].(*string), fc.Args["fixtureValues"].([]*FixtureValueInput), fc.Args["mergeFixtures"].(*bool))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateScenePartial(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateScenePartial_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSceneBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createSceneBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateSceneBoard(ctx, fc.Args["input"].(CreateSceneBoardInput))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createSceneBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSceneBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSceneBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSceneBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSceneBoard(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateSceneBoardInput))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSceneBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSceneBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSceneBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteSceneBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteSceneBoard(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteSceneBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSceneBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateSceneBoards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateSceneBoards,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateSceneBoards(ctx, fc.Args["input"].(BulkSceneBoardCreateInput))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateSceneBoards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateSceneBoards_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateSceneBoards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateSceneBoards,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateSceneBoards(ctx, fc.Args["input"].(BulkSceneBoardUpdateInput))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateSceneBoards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateSceneBoards_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteSceneBoards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteSceneBoards,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteSceneBoards(ctx, fc.Args["sceneBoardIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteSceneBoards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteSceneBoards_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addSceneToBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_addSceneToBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AddSceneToBoard(ctx, fc.Args["input"].(CreateSceneBoardButtonInput))
		},
		nil,
		ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_addSceneToBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addSceneToBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSceneBoardButton(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSceneBoardButton,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSceneBoardButton(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateSceneBoardButtonInput))
		},
		nil,
		ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSceneBoardButton(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSceneBoardButton_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeSceneFromBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removeSceneFromBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemoveSceneFromBoard(ctx, fc.Args["buttonId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removeSceneFromBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeSceneFromBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSceneBoardButtonPositions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSceneBoardButtonPositions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSceneBoardButtonPositions(ctx, fc.Args["positions"].([]*SceneBoardButtonPositionInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSceneBoardButtonPositions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSceneBoardButtonPositions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateSceneBoardButtons,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateSceneBoardButtons(ctx, fc.Args["input"].(BulkSceneBoardButtonCreateInput))
		},
		nil,
		ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateSceneBoardButtons_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateSceneBoardButtons,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateSceneBoardButtons(ctx, fc.Args["input"].(BulkSceneBoardButtonUpdateInput))
		},
		nil,
		ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateSceneBoardButtons_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteSceneBoardButtons,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteSceneBoardButtons(ctx, fc.Args["buttonIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteSceneBoardButtons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteSceneBoardButtons_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_activateSceneFromBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_activateSceneFromBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ActivateSceneFromBoard(ctx, fc.Args["sceneBoardId"].(string), fc.Args["sceneId"].(string), fc.Args["fadeTimeOverride"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_activateSceneFromBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_activateSceneFromBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createCueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateCueList(ctx, fc.Args["input"].(CreateCueListInput))
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createCueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateCueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateCueList(ctx, fc.Args["id"].(string), fc.Args["input"].(CreateCueListInput))
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateCueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteCueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteCueList(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteCueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateCueLists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateCueLists,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateCueLists(ctx, fc.Args["input"].(BulkCueListCreateInput))
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateCueLists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateCueLists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateCueLists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateCueLists,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateCueLists(ctx, fc.Args["input"].(BulkCueListUpdateInput))
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateCueLists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateCueLists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteCueLists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteCueLists,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteCueLists(ctx, fc.Args["cueListIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteCueLists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteCueLists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateCue(ctx, fc.Args["input"].(CreateCueInput))
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateCue(ctx, fc.Args["id"].(string), fc.Args["input"].(CreateCueInput))
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteCue(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reorderCues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_reorderCues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ReorderCues(ctx, fc.Args["cueListId"].(string), fc.Args["cueOrders"].([]*CueOrderInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_reorderCues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reorderCues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateCues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateCues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateCues(ctx, fc.Args["input"].(BulkCueCreateInput))
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateCues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateCues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkUpdateCues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkUpdateCues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkUpdateCues(ctx, fc.Args["input"].(BulkCueUpdateInput))
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkUpdateCues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkUpdateCues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteCues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteCues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteCues(ctx, fc.Args["cueIds"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteCues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedCount":
				return ec.fieldContext_BulkDeleteResult_deletedCount(ctx, field)
			case "deletedIds":
				return ec.fieldContext_BulkDeleteResult_deletedIds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteCues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_startPreviewSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_startPreviewSession,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().StartPreviewSession(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_startPreviewSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PreviewSession_id(ctx, field)
			case "project":
				return ec.fieldContext_PreviewSession_project(ctx, field)
			case "user":
				return ec.fieldContext_PreviewSession_user(ctx, field)
			case "isActive":
				return ec.fieldContext_PreviewSession_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_PreviewSession_createdAt(ctx, field)
			case "dmxOutput":
				return ec.fieldContext_PreviewSession_dmxOutput(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_startPreviewSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_commitPreviewSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_commitPreviewSession,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CommitPreviewSession(ctx, fc.Args["sessionId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_commitPreviewSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_commitPreviewSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelPreviewSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_cancelPreviewSession,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CancelPreviewSession(ctx, fc.Args["sessionId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_cancelPreviewSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelPreviewSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePreviewChannel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updatePreviewChannel,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdatePreviewChannel(ctx, fc.Args["sessionId"].(string), fc.Args["fixtureId"].(string), fc.Args["channelIndex"].(int), fc.Args["value"].(int))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updatePreviewChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePreviewChannel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_initializePreviewWithScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_initializePreviewWithScene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().InitializePreviewWithScene(ctx, fc.Args["sessionId"].(string), fc.Args["sceneId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_initializePreviewWithScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_initializePreviewWithScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setChannelValue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setChannelValue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetChannelValue(ctx, fc.Args["universe"].(int), fc.Args["channel"].(int), fc.Args["value"].(int))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setChannelValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setChannelValue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setSceneLive(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setSceneLive,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetSceneLive(ctx, fc.Args["sceneId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setSceneLive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setSceneLive_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_playCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_playCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().PlayCue(ctx, fc.Args["cueId"].(string), fc.Args["fadeInTime"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_playCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_playCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_fadeToBlack(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_fadeToBlack,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().FadeToBlack(ctx, fc.Args["fadeOutTime"].(float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_fadeToBlack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_fadeToBlack_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_startCueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_startCueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().StartCueList(ctx, fc.Args["cueListId"].(string), fc.Args["startFromCue"].(*int), fc.Args["fadeInTime"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_startCueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_startCueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_nextCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_nextCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().NextCue(ctx, fc.Args["cueListId"].(string), fc.Args["fadeInTime"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_nextCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_nextCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_previousCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_previousCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().PreviousCue(ctx, fc.Args["cueListId"].(string), fc.Args["fadeInTime"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_previousCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_previousCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_goToCue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_goToCue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().GoToCue(ctx, fc.Args["cueListId"].(string), fc.Args["cueIndex"].(int), fc.Args["fadeInTime"].(*float64))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_goToCue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_goToCue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_stopCueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_stopCueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().StopCueList(ctx, fc.Args["cueListId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_stopCueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_stopCueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exportProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_exportProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ExportProject(ctx, fc.Args["projectId"].(string), fc.Args["options"].(*ExportOptionsInput))
		},
		nil,
		ec.marshalNExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_exportProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ExportResult_projectId(ctx, field)
			case "projectName":
				return ec.fieldContext_ExportResult_projectName(ctx, field)
			case "jsonContent":
				return ec.fieldContext_ExportResult_jsonContent(ctx, field)
			case "stats":
				return ec.fieldContext_ExportResult_stats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exportProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_importProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_importProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ImportProject(ctx, fc.Args["jsonContent"].(string), fc.Args["options"].(ImportOptionsInput))
		},
		nil,
		ec.marshalNImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_importProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ImportResult_projectId(ctx, field)
			case "stats":
				return ec.fieldContext_ImportResult_stats(ctx, field)
			case "warnings":
				return ec.fieldContext_ImportResult_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_importProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_importProjectFromQLC(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_importProjectFromQLC,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ImportProjectFromQlc(ctx, fc.Args["xmlContent"].(string), fc.Args["originalFileName"].(string))
		},
		nil,
		ec.marshalNQLCImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCImportResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_importProjectFromQLC(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "project":
				return ec.fieldContext_QLCImportResult_project(ctx, field)
			case "originalFileName":
				return ec.fieldContext_QLCImportResult_originalFileName(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_QLCImportResult_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_QLCImportResult_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_QLCImportResult_cueListCount(ctx, field)
			case "warnings":
				return ec.fieldContext_QLCImportResult_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QLCImportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_importProjectFromQLC_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exportProjectToQLC(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_exportProjectToQLC,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ExportProjectToQlc(ctx, fc.Args["projectId"].(string), fc.Args["fixtureMappings"].([]*FixtureMappingInput))
		},
		nil,
		ec.marshalNQLCExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCExportResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_exportProjectToQLC(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectName":
				return ec.fieldContext_QLCExportResult_projectName(ctx, field)
			case "xmlContent":
				return ec.fieldContext_QLCExportResult_xmlContent(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_QLCExportResult_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_QLCExportResult_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_QLCExportResult_cueListCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QLCExportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exportProjectToQLC_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSetting,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSetting(ctx, fc.Args["input"].(UpdateSettingInput))
		},
		nil,
		ec.marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "key":
				return ec.fieldContext_Setting_key(ctx, field)
			case "value":
				return ec.fieldContext_Setting_value(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_connectWiFi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_connectWiFi,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ConnectWiFi(ctx, fc.Args["ssid"].(string), fc.Args["password"].(*string))
		},
		nil,
		ec.marshalNWiFiConnectionResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiConnectionResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_connectWiFi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WiFiConnectionResult_success(ctx, field)
			case "message":
				return ec.fieldContext_WiFiConnectionResult_message(ctx, field)
			case "connected":
				return ec.fieldContext_WiFiConnectionResult_connected(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiConnectionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_connectWiFi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disconnectWiFi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_disconnectWiFi,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().DisconnectWiFi(ctx)
		},
		nil,
		ec.marshalNWiFiConnectionResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiConnectionResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_disconnectWiFi(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WiFiConnectionResult_success(ctx, field)
			case "message":
				return ec.fieldContext_WiFiConnectionResult_message(ctx, field)
			case "connected":
				return ec.fieldContext_WiFiConnectionResult_connected(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiConnectionResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setWiFiEnabled(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setWiFiEnabled,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetWiFiEnabled(ctx, fc.Args["enabled"].(bool))
		},
		nil,
		ec.marshalNWiFiStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setWiFiEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "available":
				return ec.fieldContext_WiFiStatus_available(ctx, field)
			case "enabled":
				return ec.fieldContext_WiFiStatus_enabled(ctx, field)
			case "connected":
				return ec.fieldContext_WiFiStatus_connected(ctx, field)
			case "ssid":
				return ec.fieldContext_WiFiStatus_ssid(ctx, field)
			case "signalStrength":
				return ec.fieldContext_WiFiStatus_signalStrength(ctx, field)
			case "ipAddress":
				return ec.fieldContext_WiFiStatus_ipAddress(ctx, field)
			case "macAddress":
				return ec.fieldContext_WiFiStatus_macAddress(ctx, field)
			case "frequency":
				return ec.fieldContext_WiFiStatus_frequency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setWiFiEnabled_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_forgetWiFiNetwork(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_forgetWiFiNetwork,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ForgetWiFiNetwork(ctx, fc.Args["ssid"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_forgetWiFiNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_forgetWiFiNetwork_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateRepository,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateRepository(ctx, fc.Args["repository"].(string), fc.Args["version"].(*string))
		},
		nil,
		ec.marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateRepository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateResult_success(ctx, field)
			case "repository":
				return ec.fieldContext_UpdateResult_repository(ctx, field)
			case "previousVersion":
				return ec.fieldContext_UpdateResult_previousVersion(ctx, field)
			case "newVersion":
				return ec.fieldContext_UpdateResult_newVersion(ctx, field)
			case "message":
				return ec.fieldContext_UpdateResult_message(ctx, field)
			case "error":
				return ec.fieldContext_UpdateResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRepository_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAllRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateAllRepositories,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().UpdateAllRepositories(ctx)
		},
		nil,
		ec.marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateAllRepositories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateResult_success(ctx, field)
			case "repository":
				return ec.fieldContext_UpdateResult_repository(ctx, field)
			case "previousVersion":
				return ec.fieldContext_UpdateResult_previousVersion(ctx, field)
			case "newVersion":
				return ec.fieldContext_UpdateResult_newVersion(ctx, field)
			case "message":
				return ec.fieldContext_UpdateResult_message(ctx, field)
			case "error":
				return ec.fieldContext_UpdateResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_triggerOFLImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_triggerOFLImport,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().TriggerOFLImport(ctx, fc.Args["options"].(*OFLImportOptionsInput))
		},
		nil,
		ec.marshalNOFLImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_triggerOFLImport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_OFLImportResult_success(ctx, field)
			case "stats":
				return ec.fieldContext_OFLImportResult_stats(ctx, field)
			case "errorMessage":
				return ec.fieldContext_OFLImportResult_errorMessage(ctx, field)
			case "oflVersion":
				return ec.fieldContext_OFLImportResult_oflVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLImportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_triggerOFLImport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelOFLImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_cancelOFLImport,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().CancelOFLImport(ctx)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_cancelOFLImport(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkInterfaceOption_name(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NetworkInterfaceOption_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NetworkInterfaceOption_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkInterfaceOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkInterfaceOption_address(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NetworkInterfaceOption_address,
		func(ctx context.Context) (any, error) {
			return obj.Address, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NetworkInterfaceOption_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkInterfaceOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkInterfaceOption_broadcast(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NetworkInterfaceOption_broadcast,
		func(ctx context.Context) (any, error) {
			return obj.Broadcast, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NetworkInterfaceOption_broadcast(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkInterfaceOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkInterfaceOption_description(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NetworkInterfaceOption_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NetworkInterfaceOption_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkInterfaceOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkInterfaceOption_interfaceType(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NetworkInterfaceOption_interfaceType,
		func(ctx context.Context) (any, error) {
			return obj.InterfaceType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NetworkInterfaceOption_interfaceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkInterfaceOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_fixtureKey(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_fixtureKey,
		func(ctx context.Context) (any, error) {
			return obj.FixtureKey, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_fixtureKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_manufacturer(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_model(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_changeType(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_changeType,
		func(ctx context.Context) (any, error) {
			return obj.ChangeType, nil
		},
		nil,
		ec.marshalNOFLFixtureChangeType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureChangeType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_changeType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OFLFixtureChangeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_isInUse(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_isInUse,
		func(ctx context.Context) (any, error) {
			return obj.IsInUse, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_isInUse(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_instanceCount(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_instanceCount,
		func(ctx context.Context) (any, error) {
			return obj.InstanceCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_instanceCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_currentHash(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_currentHash,
		func(ctx context.Context) (any, error) {
			return obj.CurrentHash, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_currentHash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLFixtureUpdate_newHash(ctx context.Context, field graphql.CollectedField, obj *OFLFixtureUpdate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLFixtureUpdate_newHash,
		func(ctx context.Context) (any, error) {
			return obj.NewHash, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLFixtureUpdate_newHash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLFixtureUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportResult_success(ctx context.Context, field graphql.CollectedField, obj *OFLImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportResult_success,
		func(ctx context.Context) (any, error) {
			return obj.Success, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportResult_stats(ctx context.Context, field graphql.CollectedField, obj *OFLImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportResult_stats,
		func(ctx context.Context) (any, error) {
			return obj.Stats, nil
		},
		nil,
		ec.marshalNOFLImportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportResult_stats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalProcessed":
				return ec.fieldContext_OFLImportStats_totalProcessed(ctx, field)
			case "successfulImports":
				return ec.fieldContext_OFLImportStats_successfulImports(ctx, field)
			case "failedImports":
				return ec.fieldContext_OFLImportStats_failedImports(ctx, field)
			case "skippedDuplicates":
				return ec.fieldContext_OFLImportStats_skippedDuplicates(ctx, field)
			case "updatedFixtures":
				return ec.fieldContext_OFLImportStats_updatedFixtures(ctx, field)
			case "durationSeconds":
				return ec.fieldContext_OFLImportStats_durationSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLImportStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportResult_errorMessage(ctx context.Context, field graphql.CollectedField, obj *OFLImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportResult_errorMessage,
		func(ctx context.Context) (any, error) {
			return obj.ErrorMessage, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportResult_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportResult_oflVersion(ctx context.Context, field graphql.CollectedField, obj *OFLImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportResult_oflVersion,
		func(ctx context.Context) (any, error) {
			return obj.OflVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportResult_oflVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_totalProcessed(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_totalProcessed,
		func(ctx context.Context) (any, error) {
			return obj.TotalProcessed, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_totalProcessed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_successfulImports(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_successfulImports,
		func(ctx context.Context) (any, error) {
			return obj.SuccessfulImports, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_successfulImports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_failedImports(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_failedImports,
		func(ctx context.Context) (any, error) {
			return obj.FailedImports, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_failedImports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_skippedDuplicates(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_skippedDuplicates,
		func(ctx context.Context) (any, error) {
			return obj.SkippedDuplicates, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_skippedDuplicates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_updatedFixtures(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_updatedFixtures,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedFixtures, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_updatedFixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStats_durationSeconds(ctx context.Context, field graphql.CollectedField, obj *OFLImportStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStats_durationSeconds,
		func(ctx context.Context) (any, error) {
			return obj.DurationSeconds, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStats_durationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_isImporting(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_isImporting,
		func(ctx context.Context) (any, error) {
			return obj.IsImporting, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_isImporting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_phase(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_phase,
		func(ctx context.Context) (any, error) {
			return obj.Phase, nil
		},
		nil,
		ec.marshalNOFLImportPhase2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportPhase,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_phase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OFLImportPhase does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_totalFixtures(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_totalFixtures,
		func(ctx context.Context) (any, error) {
			return obj.TotalFixtures, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_totalFixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_importedCount(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_importedCount,
		func(ctx context.Context) (any, error) {
			return obj.ImportedCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_importedCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_failedCount(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_failedCount,
		func(ctx context.Context) (any, error) {
			return obj.FailedCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_failedCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_skippedCount(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_skippedCount,
		func(ctx context.Context) (any, error) {
			return obj.SkippedCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_skippedCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_percentComplete(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_percentComplete,
		func(ctx context.Context) (any, error) {
			return obj.PercentComplete, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_percentComplete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_currentFixture(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_currentFixture,
		func(ctx context.Context) (any, error) {
			return obj.CurrentFixture, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_currentFixture(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_currentManufacturer(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_currentManufacturer,
		func(ctx context.Context) (any, error) {
			return obj.CurrentManufacturer, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_currentManufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_estimatedSecondsRemaining(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_estimatedSecondsRemaining,
		func(ctx context.Context) (any, error) {
			return obj.EstimatedSecondsRemaining, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_estimatedSecondsRemaining(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_errorMessage(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_errorMessage,
		func(ctx context.Context) (any, error) {
			return obj.ErrorMessage, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_startedAt(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_startedAt,
		func(ctx context.Context) (any, error) {
			return obj.StartedAt, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_completedAt(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_completedAt,
		func(ctx context.Context) (any, error) {
			return obj.CompletedAt, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_oflVersion(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_oflVersion,
		func(ctx context.Context) (any, error) {
			return obj.OflVersion, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_oflVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLImportStatus_usingBundledData(ctx context.Context, field graphql.CollectedField, obj *OFLImportStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLImportStatus_usingBundledData,
		func(ctx context.Context) (any, error) {
			return obj.UsingBundledData, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLImportStatus_usingBundledData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLImportStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_currentFixtureCount(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_currentFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.CurrentFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_currentFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_oflFixtureCount(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_oflFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.OflFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_oflFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_newFixtureCount(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_newFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.NewFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_newFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_changedFixtureCount(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_changedFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.ChangedFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_changedFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_changedInUseCount(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_changedInUseCount,
		func(ctx context.Context) (any, error) {
			return obj.ChangedInUseCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_changedInUseCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_fixtureUpdates(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_fixtureUpdates,
		func(ctx context.Context) (any, error) {
			return obj.FixtureUpdates, nil
		},
		nil,
		ec.marshalNOFLFixtureUpdate2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureUpdate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_fixtureUpdates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureKey":
				return ec.fieldContext_OFLFixtureUpdate_fixtureKey(ctx, field)
			case "manufacturer":
				return ec.fieldContext_OFLFixtureUpdate_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_OFLFixtureUpdate_model(ctx, field)
			case "changeType":
				return ec.fieldContext_OFLFixtureUpdate_changeType(ctx, field)
			case "isInUse":
				return ec.fieldContext_OFLFixtureUpdate_isInUse(ctx, field)
			case "instanceCount":
				return ec.fieldContext_OFLFixtureUpdate_instanceCount(ctx, field)
			case "currentHash":
				return ec.fieldContext_OFLFixtureUpdate_currentHash(ctx, field)
			case "newHash":
				return ec.fieldContext_OFLFixtureUpdate_newHash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLFixtureUpdate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_oflVersion(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_oflVersion,
		func(ctx context.Context) (any, error) {
			return obj.OflVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_oflVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OFLUpdateCheckResult_checkedAt(ctx context.Context, field graphql.CollectedField, obj *OFLUpdateCheckResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OFLUpdateCheckResult_checkedAt,
		func(ctx context.Context) (any, error) {
			return obj.CheckedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OFLUpdateCheckResult_checkedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OFLUpdateCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_total(ctx context.Context, field graphql.CollectedField, obj *PaginationInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PaginationInfo_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PaginationInfo_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_page(ctx context.Context, field graphql.CollectedField, obj *PaginationInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PaginationInfo_page,
		func(ctx context.Context) (any, error) {
			return obj.Page, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PaginationInfo_page(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_perPage(ctx context.Context, field graphql.CollectedField, obj *PaginationInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PaginationInfo_perPage,
		func(ctx context.Context) (any, error) {
			return obj.PerPage, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PaginationInfo_perPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_totalPages(ctx context.Context, field graphql.CollectedField, obj *PaginationInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PaginationInfo_totalPages,
		func(ctx context.Context) (any, error) {
			return obj.TotalPages, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PaginationInfo_totalPages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_hasMore(ctx context.Context, field graphql.CollectedField, obj *PaginationInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PaginationInfo_hasMore,
		func(ctx context.Context) (any, error) {
			return obj.HasMore, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PaginationInfo_hasMore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_id(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_project(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PreviewSession().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_user(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_user,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PreviewSession().User(ctx, obj)
		},
		nil,
		ec.marshalNUser2githubcombbernsteinlacylightsgointernaldatabasemodelsUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_isActive(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_isActive,
		func(ctx context.Context) (any, error) {
			return obj.IsActive, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_isActive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PreviewSession().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewSession_dmxOutput(ctx context.Context, field graphql.CollectedField, obj *models.PreviewSession) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreviewSession_dmxOutput,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PreviewSession().DmxOutput(ctx, obj)
		},
		nil,
		ec.marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreviewSession_dmxOutput(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewSession",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "universe":
				return ec.fieldContext_UniverseOutput_universe(ctx, field)
			case "channels":
				return ec.fieldContext_UniverseOutput_channels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UniverseOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_name(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_description(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_fixtureCount(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_fixtureCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().FixtureCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_fixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_sceneCount(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_sceneCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().SceneCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_sceneCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_cueListCount(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_cueListCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().CueListCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_cueListCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_fixtures(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_fixtures,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().Fixtures(ctx, obj)
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_fixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_scenes(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_scenes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().Scenes(ctx, obj)
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_scenes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_cueLists(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_cueLists,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().CueLists(ctx, obj)
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_cueLists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_sceneBoards(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_sceneBoards,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().SceneBoards(ctx, obj)
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_sceneBoards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_users(ctx context.Context, field graphql.CollectedField, obj *models.Project) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_users,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().Users(ctx, obj)
		},
		nil,
		ec.marshalNProjectUser2githubcombbernsteinlacylightsgointernaldatabasemodelsProjectUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectUser_id(ctx, field)
			case "user":
				return ec.fieldContext_ProjectUser_user(ctx, field)
			case "project":
				return ec.fieldContext_ProjectUser_project(ctx, field)
			case "role":
				return ec.fieldContext_ProjectUser_role(ctx, field)
			case "joinedAt":
				return ec.fieldContext_ProjectUser_joinedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUser_id(ctx context.Context, field graphql.CollectedField, obj *models.ProjectUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectUser_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUser_user(ctx context.Context, field graphql.CollectedField, obj *models.ProjectUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectUser_user,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectUser().User(ctx, obj)
		},
		nil,
		ec.marshalNUser2githubcombbernsteinlacylightsgointernaldatabasemodelsUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectUser_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUser_project(ctx context.Context, field graphql.CollectedField, obj *models.ProjectUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectUser_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectUser().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectUser_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUser_role(ctx context.Context, field graphql.CollectedField, obj *models.ProjectUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectUser_role,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectUser().Role(ctx, obj)
		},
		nil,
		ec.marshalNProjectRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectRole,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectUser_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUser_joinedAt(ctx context.Context, field graphql.CollectedField, obj *models.ProjectUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectUser_joinedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectUser().JoinedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectUser_joinedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCExportResult_projectName(ctx context.Context, field graphql.CollectedField, obj *QLCExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCExportResult_projectName,
		func(ctx context.Context) (any, error) {
			return obj.ProjectName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCExportResult_projectName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCExportResult_xmlContent(ctx context.Context, field graphql.CollectedField, obj *QLCExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCExportResult_xmlContent,
		func(ctx context.Context) (any, error) {
			return obj.XMLContent, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCExportResult_xmlContent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCExportResult_fixtureCount(ctx context.Context, field graphql.CollectedField, obj *QLCExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCExportResult_fixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.FixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCExportResult_fixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCExportResult_sceneCount(ctx context.Context, field graphql.CollectedField, obj *QLCExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCExportResult_sceneCount,
		func(ctx context.Context) (any, error) {
			return obj.SceneCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCExportResult_sceneCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCExportResult_cueListCount(ctx context.Context, field graphql.CollectedField, obj *QLCExportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCExportResult_cueListCount,
		func(ctx context.Context) (any, error) {
			return obj.CueListCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCExportResult_cueListCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCExportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureDefinition_manufacturer(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureDefinition_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureDefinition_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureDefinition_model(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureDefinition_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureDefinition_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureDefinition_type(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureDefinition_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureDefinition_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureDefinition_modes(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureDefinition_modes,
		func(ctx context.Context) (any, error) {
			return obj.Modes, nil
		},
		nil,
		ec.marshalNQLCFixtureMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureDefinition_modes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_QLCFixtureMode_name(ctx, field)
			case "channelCount":
				return ec.fieldContext_QLCFixtureMode_channelCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QLCFixtureMode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMappingResult_projectId(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMappingResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMappingResult_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMappingResult_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMappingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMappingResult_lacyLightsFixtures(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMappingResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMappingResult_lacyLightsFixtures,
		func(ctx context.Context) (any, error) {
			return obj.LacyLightsFixtures, nil
		},
		nil,
		ec.marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMappingResult_lacyLightsFixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMappingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "manufacturer":
				return ec.fieldContext_LacyLightsFixture_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_LacyLightsFixture_model(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LacyLightsFixture", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMappingResult_suggestions(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMappingResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMappingResult_suggestions,
		func(ctx context.Context) (any, error) {
			return obj.Suggestions, nil
		},
		nil,
		ec.marshalNFixtureMappingSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingSuggestion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMappingResult_suggestions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMappingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixture":
				return ec.fieldContext_FixtureMappingSuggestion_fixture(ctx, field)
			case "suggestions":
				return ec.fieldContext_FixtureMappingSuggestion_suggestions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureMappingSuggestion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMappingResult_defaultMappings(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMappingResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMappingResult_defaultMappings,
		func(ctx context.Context) (any, error) {
			return obj.DefaultMappings, nil
		},
		nil,
		ec.marshalNFixtureMapping2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMapping,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMappingResult_defaultMappings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMappingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lacyLightsKey":
				return ec.fieldContext_FixtureMapping_lacyLightsKey(ctx, field)
			case "qlcManufacturer":
				return ec.fieldContext_FixtureMapping_qlcManufacturer(ctx, field)
			case "qlcModel":
				return ec.fieldContext_FixtureMapping_qlcModel(ctx, field)
			case "qlcMode":
				return ec.fieldContext_FixtureMapping_qlcMode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureMapping", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMode_name(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMode_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMode_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCFixtureMode_channelCount(ctx context.Context, field graphql.CollectedField, obj *QLCFixtureMode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCFixtureMode_channelCount,
		func(ctx context.Context) (any, error) {
			return obj.ChannelCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCFixtureMode_channelCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCFixtureMode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_project(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_originalFileName(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_originalFileName,
		func(ctx context.Context) (any, error) {
			return obj.OriginalFileName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_originalFileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_fixtureCount(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_fixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.FixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_fixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_sceneCount(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_sceneCount,
		func(ctx context.Context) (any, error) {
			return obj.SceneCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_sceneCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_cueListCount(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_cueListCount,
		func(ctx context.Context) (any, error) {
			return obj.CueListCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_cueListCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QLCImportResult_warnings(ctx context.Context, field graphql.CollectedField, obj *QLCImportResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QLCImportResult_warnings,
		func(ctx context.Context) (any, error) {
			return obj.Warnings, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QLCImportResult_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QLCImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_projects,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Projects(ctx)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_project,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Project(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_project_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureDefinitions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureDefinitions(ctx, fc.Args["filter"].(*FixtureDefinitionFilter))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureDefinition,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureDefinition(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureInstances(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureInstances,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureInstances(ctx, fc.Args["projectId"].(string), fc.Args["page"].(*int), fc.Args["perPage"].(*int), fc.Args["filter"].(*FixtureFilterInput))
		},
		nil,
		ec.marshalNFixtureInstancePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureInstancePage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtures":
				return ec.fieldContext_FixtureInstancePage_fixtures(ctx, field)
			case "pagination":
				return ec.fieldContext_FixtureInstancePage_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstancePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureInstance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureInstance,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureInstance(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_searchFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SearchFixtures(ctx, fc.Args["projectId"].(string), fc.Args["query"].(string), fc.Args["filter"].(*FixtureFilterInput), fc.Args["page"].(*int), fc.Args["perPage"].(*int))
		},
		nil,
		ec.marshalNFixtureInstancePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureInstancePage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_searchFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtures":
				return ec.fieldContext_FixtureInstancePage_fixtures(ctx, field)
			case "pagination":
				return ec.fieldContext_FixtureInstancePage_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstancePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_channelMap(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_channelMap,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ChannelMap(ctx, fc.Args["projectId"].(string), fc.Args["universe"].(*int))
		},
		nil,
		ec.marshalNChannelMapResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_channelMap(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ChannelMapResult_projectId(ctx, field)
			case "universes":
				return ec.fieldContext_ChannelMapResult_universes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelMapResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_channelMap_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_suggestChannelAssignment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_suggestChannelAssignment,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SuggestChannelAssignment(ctx, fc.Args["input"].(ChannelAssignmentInput))
		},
		nil,
		ec.marshalNChannelAssignmentSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelAssignmentSuggestion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_suggestChannelAssignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "universe":
				return ec.fieldContext_ChannelAssignmentSuggestion_universe(ctx, field)
			case "assignments":
				return ec.fieldContext_ChannelAssignmentSuggestion_assignments(ctx, field)
			case "totalChannelsNeeded":
				return ec.fieldContext_ChannelAssignmentSuggestion_totalChannelsNeeded(ctx, field)
			case "availableChannelsRemaining":
				return ec.fieldContext_ChannelAssignmentSuggestion_availableChannelsRemaining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelAssignmentSuggestion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_suggestChannelAssignment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_scenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Scenes(ctx, fc.Args["projectId"].(string), fc.Args["page"].(*int), fc.Args["perPage"].(*int), fc.Args["filter"].(*SceneFilterInput), fc.Args["sortBy"].(*SceneSortField))
		},
		nil,
		ec.marshalNScenePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedScenePage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_scenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenes":
				return ec.fieldContext_ScenePage_scenes(ctx, field)
			case "pagination":
				return ec.fieldContext_ScenePage_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScenePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_scene,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Scene(ctx, fc.Args["id"].(string), fc.Args["includeFixtureValues"].(*bool))
		},
		nil,
		ec.marshalOScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_scene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneFixtures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneFixtures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneFixtures(ctx, fc.Args["sceneId"].(string))
		},
		nil,
		ec.marshalNSceneFixtureSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFixtureSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_sceneFixtures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureId":
				return ec.fieldContext_SceneFixtureSummary_fixtureId(ctx, field)
			case "fixtureName":
				return ec.fieldContext_SceneFixtureSummary_fixtureName(ctx, field)
			case "fixtureType":
				return ec.fieldContext_SceneFixtureSummary_fixtureType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneFixtureSummary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneFixtures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_searchScenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SearchScenes(ctx, fc.Args["projectId"].(string), fc.Args["query"].(string), fc.Args["filter"].(*SceneFilterInput), fc.Args["page"].(*int), fc.Args["perPage"].(*int))
		},
		nil,
		ec.marshalNScenePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedScenePage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_searchScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenes":
				return ec.fieldContext_ScenePage_scenes(ctx, field)
			case "pagination":
				return ec.fieldContext_ScenePage_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScenePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneBoards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneBoards,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneBoards(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_sceneBoards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneBoards_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneBoard,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneBoard(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_sceneBoard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneBoard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneBoardButton(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneBoardButton,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneBoardButton(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_sceneBoardButton(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneBoardButton_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureUsage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureUsage,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureUsage(ctx, fc.Args["fixtureId"].(string))
		},
		nil,
		ec.marshalNFixtureUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUsage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureUsage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureId":
				return ec.fieldContext_FixtureUsage_fixtureId(ctx, field)
			case "fixtureName":
				return ec.fieldContext_FixtureUsage_fixtureName(ctx, field)
			case "scenes":
				return ec.fieldContext_FixtureUsage_scenes(ctx, field)
			case "cues":
				return ec.fieldContext_FixtureUsage_cues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureUsage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureUsage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneUsage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneUsage,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneUsage(ctx, fc.Args["sceneId"].(string))
		},
		nil,
		ec.marshalNSceneUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUsage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_sceneUsage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sceneId":
				return ec.fieldContext_SceneUsage_sceneId(ctx, field)
			case "sceneName":
				return ec.fieldContext_SceneUsage_sceneName(ctx, field)
			case "cues":
				return ec.fieldContext_SceneUsage_cues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneUsage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneUsage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compareScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_compareScenes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CompareScenes(ctx, fc.Args["sceneId1"].(string), fc.Args["sceneId2"].(string))
		},
		nil,
		ec.marshalNSceneComparison2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneComparison,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_compareScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scene1":
				return ec.fieldContext_SceneComparison_scene1(ctx, field)
			case "scene2":
				return ec.fieldContext_SceneComparison_scene2(ctx, field)
			case "differences":
				return ec.fieldContext_SceneComparison_differences(ctx, field)
			case "identicalFixtureCount":
				return ec.fieldContext_SceneComparison_identicalFixtureCount(ctx, field)
			case "differentFixtureCount":
				return ec.fieldContext_SceneComparison_differentFixtureCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneComparison", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_compareScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cueLists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cueLists,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CueLists(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNCueListSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_cueLists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueListSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_CueListSummary_name(ctx, field)
			case "description":
				return ec.fieldContext_CueListSummary_description(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueListSummary_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueListSummary_totalDuration(ctx, field)
			case "loop":
				return ec.fieldContext_CueListSummary_loop(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueListSummary_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueListSummary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cueLists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cueList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cueList,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CueList(ctx, fc.Args["id"].(string), fc.Args["page"].(*int), fc.Args["perPage"].(*int), fc.Args["includeSceneDetails"].(*bool))
		},
		nil,
		ec.marshalOCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_cueList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cueList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cueListPlaybackStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cueListPlaybackStatus,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CueListPlaybackStatus(ctx, fc.Args["cueListId"].(string))
		},
		nil,
		ec.marshalOCueListPlaybackStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListPlaybackStatus,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_cueListPlaybackStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cueListId":
				return ec.fieldContext_CueListPlaybackStatus_cueListId(ctx, field)
			case "currentCueIndex":
				return ec.fieldContext_CueListPlaybackStatus_currentCueIndex(ctx, field)
			case "isPlaying":
				return ec.fieldContext_CueListPlaybackStatus_isPlaying(ctx, field)
			case "isFading":
				return ec.fieldContext_CueListPlaybackStatus_isFading(ctx, field)
			case "currentCue":
				return ec.fieldContext_CueListPlaybackStatus_currentCue(ctx, field)
			case "nextCue":
				return ec.fieldContext_CueListPlaybackStatus_nextCue(ctx, field)
			case "previousCue":
				return ec.fieldContext_CueListPlaybackStatus_previousCue(ctx, field)
			case "fadeProgress":
				return ec.fieldContext_CueListPlaybackStatus_fadeProgress(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_CueListPlaybackStatus_lastUpdated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueListPlaybackStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cueListPlaybackStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Cue(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_cue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchCues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_searchCues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SearchCues(ctx, fc.Args["cueListId"].(string), fc.Args["query"].(string), fc.Args["page"].(*int), fc.Args["perPage"].(*int))
		},
		nil,
		ec.marshalNCuePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCuePage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_searchCues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cues":
				return ec.fieldContext_CuePage_cues(ctx, field)
			case "pagination":
				return ec.fieldContext_CuePage_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CuePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchCues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_dmxOutput(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_dmxOutput,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().DmxOutput(ctx, fc.Args["universe"].(int))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_dmxOutput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_dmxOutput_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_allDmxOutput(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_allDmxOutput,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().AllDmxOutput(ctx)
		},
		nil,
		ec.marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_allDmxOutput(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "universe":
				return ec.fieldContext_UniverseOutput_universe(ctx, field)
			case "channels":
				return ec.fieldContext_UniverseOutput_channels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UniverseOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_previewSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_previewSession,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().PreviewSession(ctx, fc.Args["sessionId"].(string))
		},
		nil,
		ec.marshalOPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_previewSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PreviewSession_id(ctx, field)
			case "project":
				return ec.fieldContext_PreviewSession_project(ctx, field)
			case "user":
				return ec.fieldContext_PreviewSession_user(ctx, field)
			case "isActive":
				return ec.fieldContext_PreviewSession_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_PreviewSession_createdAt(ctx, field)
			case "dmxOutput":
				return ec.fieldContext_PreviewSession_dmxOutput(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_previewSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentActiveScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_currentActiveScene,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().CurrentActiveScene(ctx)
		},
		nil,
		ec.marshalOScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_currentActiveScene(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_settings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_settings,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Settings(ctx)
		},
		nil,
		ec.marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_settings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "key":
				return ec.fieldContext_Setting_key(ctx, field)
			case "value":
				return ec.fieldContext_Setting_value(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_setting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_setting,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Setting(ctx, fc.Args["key"].(string))
		},
		nil,
		ec.marshalOSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_setting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "key":
				return ec.fieldContext_Setting_key(ctx, field)
			case "value":
				return ec.fieldContext_Setting_value(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_setting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_systemInfo,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().SystemInfo(ctx)
		},
		nil,
		ec.marshalNSystemInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_systemInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artnetBroadcastAddress":
				return ec.fieldContext_SystemInfo_artnetBroadcastAddress(ctx, field)
			case "artnetEnabled":
				return ec.fieldContext_SystemInfo_artnetEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SystemInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_networkInterfaceOptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_networkInterfaceOptions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().NetworkInterfaceOptions(ctx)
		},
		nil,
		ec.marshalNNetworkInterfaceOption2githubcombbernsteinlacylightsgointernalgraphqlgeneratedNetworkInterfaceOption,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_networkInterfaceOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NetworkInterfaceOption_name(ctx, field)
			case "address":
				return ec.fieldContext_NetworkInterfaceOption_address(ctx, field)
			case "broadcast":
				return ec.fieldContext_NetworkInterfaceOption_broadcast(ctx, field)
			case "description":
				return ec.fieldContext_NetworkInterfaceOption_description(ctx, field)
			case "interfaceType":
				return ec.fieldContext_NetworkInterfaceOption_interfaceType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkInterfaceOption", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_wifiNetworks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_wifiNetworks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().WifiNetworks(ctx, fc.Args["rescan"].(*bool), fc.Args["deduplicate"].(*bool))
		},
		nil,
		ec.marshalNWiFiNetwork2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiNetwork,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_wifiNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ssid":
				return ec.fieldContext_WiFiNetwork_ssid(ctx, field)
			case "signalStrength":
				return ec.fieldContext_WiFiNetwork_signalStrength(ctx, field)
			case "frequency":
				return ec.fieldContext_WiFiNetwork_frequency(ctx, field)
			case "security":
				return ec.fieldContext_WiFiNetwork_security(ctx, field)
			case "inUse":
				return ec.fieldContext_WiFiNetwork_inUse(ctx, field)
			case "saved":
				return ec.fieldContext_WiFiNetwork_saved(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiNetwork", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wifiNetworks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wifiStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_wifiStatus,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().WifiStatus(ctx)
		},
		nil,
		ec.marshalNWiFiStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_wifiStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "available":
				return ec.fieldContext_WiFiStatus_available(ctx, field)
			case "enabled":
				return ec.fieldContext_WiFiStatus_enabled(ctx, field)
			case "connected":
				return ec.fieldContext_WiFiStatus_connected(ctx, field)
			case "ssid":
				return ec.fieldContext_WiFiStatus_ssid(ctx, field)
			case "signalStrength":
				return ec.fieldContext_WiFiStatus_signalStrength(ctx, field)
			case "ipAddress":
				return ec.fieldContext_WiFiStatus_ipAddress(ctx, field)
			case "macAddress":
				return ec.fieldContext_WiFiStatus_macAddress(ctx, field)
			case "frequency":
				return ec.fieldContext_WiFiStatus_frequency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_savedWifiNetworks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_savedWifiNetworks,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().SavedWifiNetworks(ctx)
		},
		nil,
		ec.marshalNWiFiNetwork2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiNetwork,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_savedWifiNetworks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ssid":
				return ec.fieldContext_WiFiNetwork_ssid(ctx, field)
			case "signalStrength":
				return ec.fieldContext_WiFiNetwork_signalStrength(ctx, field)
			case "frequency":
				return ec.fieldContext_WiFiNetwork_frequency(ctx, field)
			case "security":
				return ec.fieldContext_WiFiNetwork_security(ctx, field)
			case "inUse":
				return ec.fieldContext_WiFiNetwork_inUse(ctx, field)
			case "saved":
				return ec.fieldContext_WiFiNetwork_saved(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getQLCFixtureMappingSuggestions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getQLCFixtureMappingSuggestions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetQLCFixtureMappingSuggestions(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNQLCFixtureMappingResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMappingResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_getQLCFixtureMappingSuggestions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_QLCFixtureMappingResult_projectId(ctx, field)
			case "lacyLightsFixtures":
				return ec.fieldContext_QLCFixtureMappingResult_lacyLightsFixtures(ctx, field)
			case "suggestions":
				return ec.fieldContext_QLCFixtureMappingResult_suggestions(ctx, field)
			case "defaultMappings":
				return ec.fieldContext_QLCFixtureMappingResult_defaultMappings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QLCFixtureMappingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getQLCFixtureMappingSuggestions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_systemVersions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().SystemVersions(ctx)
		},
		nil,
		ec.marshalNSystemVersionInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemVersionInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_systemVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repositories":
				return ec.fieldContext_SystemVersionInfo_repositories(ctx, field)
			case "lastChecked":
				return ec.fieldContext_SystemVersionInfo_lastChecked(ctx, field)
			case "versionManagementSupported":
				return ec.fieldContext_SystemVersionInfo_versionManagementSupported(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SystemVersionInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_availableVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_availableVersions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AvailableVersions(ctx, fc.Args["repository"].(string))
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_availableVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_availableVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oflImportStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_oflImportStatus,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().OflImportStatus(ctx)
		},
		nil,
		ec.marshalNOFLImportStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_oflImportStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isImporting":
				return ec.fieldContext_OFLImportStatus_isImporting(ctx, field)
			case "phase":
				return ec.fieldContext_OFLImportStatus_phase(ctx, field)
			case "totalFixtures":
				return ec.fieldContext_OFLImportStatus_totalFixtures(ctx, field)
			case "importedCount":
				return ec.fieldContext_OFLImportStatus_importedCount(ctx, field)
			case "failedCount":
				return ec.fieldContext_OFLImportStatus_failedCount(ctx, field)
			case "skippedCount":
				return ec.fieldContext_OFLImportStatus_skippedCount(ctx, field)
			case "percentComplete":
				return ec.fieldContext_OFLImportStatus_percentComplete(ctx, field)
			case "currentFixture":
				return ec.fieldContext_OFLImportStatus_currentFixture(ctx, field)
			case "currentManufacturer":
				return ec.fieldContext_OFLImportStatus_currentManufacturer(ctx, field)
			case "estimatedSecondsRemaining":
				return ec.fieldContext_OFLImportStatus_estimatedSecondsRemaining(ctx, field)
			case "errorMessage":
				return ec.fieldContext_OFLImportStatus_errorMessage(ctx, field)
			case "startedAt":
				return ec.fieldContext_OFLImportStatus_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_OFLImportStatus_completedAt(ctx, field)
			case "oflVersion":
				return ec.fieldContext_OFLImportStatus_oflVersion(ctx, field)
			case "usingBundledData":
				return ec.fieldContext_OFLImportStatus_usingBundledData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLImportStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkOFLUpdates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_checkOFLUpdates,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().CheckOFLUpdates(ctx)
		},
		nil,
		ec.marshalNOFLUpdateCheckResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLUpdateCheckResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_checkOFLUpdates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "currentFixtureCount":
				return ec.fieldContext_OFLUpdateCheckResult_currentFixtureCount(ctx, field)
			case "oflFixtureCount":
				return ec.fieldContext_OFLUpdateCheckResult_oflFixtureCount(ctx, field)
			case "newFixtureCount":
				return ec.fieldContext_OFLUpdateCheckResult_newFixtureCount(ctx, field)
			case "changedFixtureCount":
				return ec.fieldContext_OFLUpdateCheckResult_changedFixtureCount(ctx, field)
			case "changedInUseCount":
				return ec.fieldContext_OFLUpdateCheckResult_changedInUseCount(ctx, field)
			case "fixtureUpdates":
				return ec.fieldContext_OFLUpdateCheckResult_fixtureUpdates(ctx, field)
			case "oflVersion":
				return ec.fieldContext_OFLUpdateCheckResult_oflVersion(ctx, field)
			case "checkedAt":
				return ec.fieldContext_OFLUpdateCheckResult_checkedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLUpdateCheckResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixturesByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixturesByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixturesByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fixturesByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_FixtureInstance_name(ctx, field)
			case "description":
				return ec.fieldContext_FixtureInstance_description(ctx, field)
			case "definitionId":
				return ec.fieldContext_FixtureInstance_definitionId(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureInstance_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureInstance_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureInstance_type(ctx, field)
			case "modeName":
				return ec.fieldContext_FixtureInstance_modeName(ctx, field)
			case "channelCount":
				return ec.fieldContext_FixtureInstance_channelCount(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureInstance_channels(ctx, field)
			case "project":
				return ec.fieldContext_FixtureInstance_project(ctx, field)
			case "universe":
				return ec.fieldContext_FixtureInstance_universe(ctx, field)
			case "startChannel":
				return ec.fieldContext_FixtureInstance_startChannel(ctx, field)
			case "tags":
				return ec.fieldContext_FixtureInstance_tags(ctx, field)
			case "projectOrder":
				return ec.fieldContext_FixtureInstance_projectOrder(ctx, field)
			case "layoutX":
				return ec.fieldContext_FixtureInstance_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_FixtureInstance_layoutY(ctx, field)
			case "layoutRotation":
				return ec.fieldContext_FixtureInstance_layoutRotation(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureInstance_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixturesByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scenesByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_scenesByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ScenesByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_scenesByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scenesByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cuesByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cuesByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CuesByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_cuesByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cue_id(ctx, field)
			case "name":
				return ec.fieldContext_Cue_name(ctx, field)
			case "cueNumber":
				return ec.fieldContext_Cue_cueNumber(ctx, field)
			case "scene":
				return ec.fieldContext_Cue_scene(ctx, field)
			case "cueList":
				return ec.fieldContext_Cue_cueList(ctx, field)
			case "fadeInTime":
				return ec.fieldContext_Cue_fadeInTime(ctx, field)
			case "fadeOutTime":
				return ec.fieldContext_Cue_fadeOutTime(ctx, field)
			case "followTime":
				return ec.fieldContext_Cue_followTime(ctx, field)
			case "easingType":
				return ec.fieldContext_Cue_easingType(ctx, field)
			case "notes":
				return ec.fieldContext_Cue_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cuesByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cueListsByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cueListsByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CueListsByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_cueListsByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CueList_id(ctx, field)
			case "name":
				return ec.fieldContext_CueList_name(ctx, field)
			case "description":
				return ec.fieldContext_CueList_description(ctx, field)
			case "loop":
				return ec.fieldContext_CueList_loop(ctx, field)
			case "project":
				return ec.fieldContext_CueList_project(ctx, field)
			case "cues":
				return ec.fieldContext_CueList_cues(ctx, field)
			case "cueCount":
				return ec.fieldContext_CueList_cueCount(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CueList_totalDuration(ctx, field)
			case "createdAt":
				return ec.fieldContext_CueList_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CueList_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cueListsByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sceneBoardsByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_sceneBoardsByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SceneBoardsByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_sceneBoardsByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sceneBoardsByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fixtureDefinitionsByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fixtureDefinitionsByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FixtureDefinitionsByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fixtureDefinitionsByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureDefinition_id(ctx, field)
			case "manufacturer":
				return ec.fieldContext_FixtureDefinition_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_FixtureDefinition_model(ctx, field)
			case "type":
				return ec.fieldContext_FixtureDefinition_type(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureDefinition_channels(ctx, field)
			case "modes":
				return ec.fieldContext_FixtureDefinition_modes(ctx, field)
			case "isBuiltIn":
				return ec.fieldContext_FixtureDefinition_isBuiltIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_FixtureDefinition_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fixtureDefinitionsByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectsByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_projectsByIds,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ProjectsByIds(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_projectsByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectsByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryVersion_repository(ctx context.Context, field graphql.CollectedField, obj *RepositoryVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepositoryVersion_repository,
		func(ctx context.Context) (any, error) {
			return obj.Repository, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepositoryVersion_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryVersion_installed(ctx context.Context, field graphql.CollectedField, obj *RepositoryVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepositoryVersion_installed,
		func(ctx context.Context) (any, error) {
			return obj.Installed, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepositoryVersion_installed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryVersion_latest(ctx context.Context, field graphql.CollectedField, obj *RepositoryVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepositoryVersion_latest,
		func(ctx context.Context) (any, error) {
			return obj.Latest, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepositoryVersion_latest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryVersion_updateAvailable(ctx context.Context, field graphql.CollectedField, obj *RepositoryVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepositoryVersion_updateAvailable,
		func(ctx context.Context) (any, error) {
			return obj.UpdateAvailable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepositoryVersion_updateAvailable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_id(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_name(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_description(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Scene_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_project(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Scene().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_fixtureValues(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_fixtureValues,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Scene().FixtureValues(ctx, obj)
		},
		nil,
		ec.marshalNFixtureValue2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_fixtureValues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FixtureValue_id(ctx, field)
			case "fixture":
				return ec.fieldContext_FixtureValue_fixture(ctx, field)
			case "channels":
				return ec.fieldContext_FixtureValue_channels(ctx, field)
			case "sceneOrder":
				return ec.fieldContext_FixtureValue_sceneOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FixtureValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Scene().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Scene) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Scene_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Scene().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Scene_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_id(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_name(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_description(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_project(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoard().Project(ctx, obj)
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_defaultFadeTime(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_defaultFadeTime,
		func(ctx context.Context) (any, error) {
			return obj.DefaultFadeTime, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_defaultFadeTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_gridSize(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_gridSize,
		func(ctx context.Context) (any, error) {
			return obj.GridSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_gridSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_canvasWidth(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_canvasWidth,
		func(ctx context.Context) (any, error) {
			return obj.CanvasWidth, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_canvasWidth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_canvasHeight(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_canvasHeight,
		func(ctx context.Context) (any, error) {
			return obj.CanvasHeight, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_canvasHeight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_buttons(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_buttons,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoard().Buttons(ctx, obj)
		},
		nil,
		ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_buttons(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoardButton_id(ctx, field)
			case "sceneBoard":
				return ec.fieldContext_SceneBoardButton_sceneBoard(ctx, field)
			case "scene":
				return ec.fieldContext_SceneBoardButton_scene(ctx, field)
			case "layoutX":
				return ec.fieldContext_SceneBoardButton_layoutX(ctx, field)
			case "layoutY":
				return ec.fieldContext_SceneBoardButton_layoutY(ctx, field)
			case "width":
				return ec.fieldContext_SceneBoardButton_width(ctx, field)
			case "height":
				return ec.fieldContext_SceneBoardButton_height(ctx, field)
			case "color":
				return ec.fieldContext_SceneBoardButton_color(ctx, field)
			case "label":
				return ec.fieldContext_SceneBoardButton_label(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoardButton_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoardButton_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoardButton", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoard().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoard_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoard) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoard_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoard().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoard_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoard",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_id(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_sceneBoard(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_sceneBoard,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoardButton().SceneBoard(ctx, obj)
		},
		nil,
		ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_sceneBoard(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneBoard_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneBoard_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneBoard_description(ctx, field)
			case "project":
				return ec.fieldContext_SceneBoard_project(ctx, field)
			case "defaultFadeTime":
				return ec.fieldContext_SceneBoard_defaultFadeTime(ctx, field)
			case "gridSize":
				return ec.fieldContext_SceneBoard_gridSize(ctx, field)
			case "canvasWidth":
				return ec.fieldContext_SceneBoard_canvasWidth(ctx, field)
			case "canvasHeight":
				return ec.fieldContext_SceneBoard_canvasHeight(ctx, field)
			case "buttons":
				return ec.fieldContext_SceneBoard_buttons(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneBoard_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneBoard_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneBoard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_scene(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_scene,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoardButton().Scene(ctx, obj)
		},
		nil,
		ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_scene(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "name":
				return ec.fieldContext_Scene_name(ctx, field)
			case "description":
				return ec.fieldContext_Scene_description(ctx, field)
			case "project":
				return ec.fieldContext_Scene_project(ctx, field)
			case "fixtureValues":
				return ec.fieldContext_Scene_fixtureValues(ctx, field)
			case "createdAt":
				return ec.fieldContext_Scene_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Scene_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_layoutX(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_layoutX,
		func(ctx context.Context) (any, error) {
			return obj.LayoutX, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_layoutX(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_layoutY(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_layoutY,
		func(ctx context.Context) (any, error) {
			return obj.LayoutY, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_layoutY(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_width(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_width,
		func(ctx context.Context) (any, error) {
			return obj.Width, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_height(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_height,
		func(ctx context.Context) (any, error) {
			return obj.Height, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_color(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_color,
		func(ctx context.Context) (any, error) {
			return obj.Color, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_label(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_label,
		func(ctx context.Context) (any, error) {
			return obj.Label, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoardButton().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneBoardButton_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SceneBoardButton) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneBoardButton_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SceneBoardButton().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneBoardButton_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneBoardButton",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneComparison_scene1(ctx context.Context, field graphql.CollectedField, obj *SceneComparison) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneComparison_scene1,
		func(ctx context.Context) (any, error) {
			return obj.Scene1, nil
		},
		nil,
		ec.marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneComparison_scene1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneComparison",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneSummary_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneSummary_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_SceneSummary_fixtureCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneSummary_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneSummary_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneComparison_scene2(ctx context.Context, field graphql.CollectedField, obj *SceneComparison) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneComparison_scene2,
		func(ctx context.Context) (any, error) {
			return obj.Scene2, nil
		},
		nil,
		ec.marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneComparison_scene2(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneComparison",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneSummary_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneSummary_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_SceneSummary_fixtureCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneSummary_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneSummary_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneComparison_differences(ctx context.Context, field graphql.CollectedField, obj *SceneComparison) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneComparison_differences,
		func(ctx context.Context) (any, error) {
			return obj.Differences, nil
		},
		nil,
		ec.marshalNSceneDifference2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneDifference,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneComparison_differences(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneComparison",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureId":
				return ec.fieldContext_SceneDifference_fixtureId(ctx, field)
			case "fixtureName":
				return ec.fieldContext_SceneDifference_fixtureName(ctx, field)
			case "differenceType":
				return ec.fieldContext_SceneDifference_differenceType(ctx, field)
			case "scene1Values":
				return ec.fieldContext_SceneDifference_scene1Values(ctx, field)
			case "scene2Values":
				return ec.fieldContext_SceneDifference_scene2Values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneDifference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneComparison_identicalFixtureCount(ctx context.Context, field graphql.CollectedField, obj *SceneComparison) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneComparison_identicalFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.IdenticalFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneComparison_identicalFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneComparison",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneComparison_differentFixtureCount(ctx context.Context, field graphql.CollectedField, obj *SceneComparison) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneComparison_differentFixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.DifferentFixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneComparison_differentFixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneComparison",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDifference_fixtureId(ctx context.Context, field graphql.CollectedField, obj *SceneDifference) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneDifference_fixtureId,
		func(ctx context.Context) (any, error) {
			return obj.FixtureID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneDifference_fixtureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDifference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDifference_fixtureName(ctx context.Context, field graphql.CollectedField, obj *SceneDifference) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneDifference_fixtureName,
		func(ctx context.Context) (any, error) {
			return obj.FixtureName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneDifference_fixtureName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDifference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDifference_differenceType(ctx context.Context, field graphql.CollectedField, obj *SceneDifference) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneDifference_differenceType,
		func(ctx context.Context) (any, error) {
			return obj.DifferenceType, nil
		},
		nil,
		ec.marshalNDifferenceType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedDifferenceType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneDifference_differenceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDifference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DifferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDifference_scene1Values(ctx context.Context, field graphql.CollectedField, obj *SceneDifference) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneDifference_scene1Values,
		func(ctx context.Context) (any, error) {
			return obj.Scene1Values, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneDifference_scene1Values(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDifference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDifference_scene2Values(ctx context.Context, field graphql.CollectedField, obj *SceneDifference) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneDifference_scene2Values,
		func(ctx context.Context) (any, error) {
			return obj.Scene2Values, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneDifference_scene2Values(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDifference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneFixtureSummary_fixtureId(ctx context.Context, field graphql.CollectedField, obj *SceneFixtureSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneFixtureSummary_fixtureId,
		func(ctx context.Context) (any, error) {
			return obj.FixtureID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneFixtureSummary_fixtureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneFixtureSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneFixtureSummary_fixtureName(ctx context.Context, field graphql.CollectedField, obj *SceneFixtureSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneFixtureSummary_fixtureName,
		func(ctx context.Context) (any, error) {
			return obj.FixtureName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneFixtureSummary_fixtureName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneFixtureSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneFixtureSummary_fixtureType(ctx context.Context, field graphql.CollectedField, obj *SceneFixtureSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneFixtureSummary_fixtureType,
		func(ctx context.Context) (any, error) {
			return obj.FixtureType, nil
		},
		nil,
		ec.marshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneFixtureSummary_fixtureType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneFixtureSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixtureType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScenePage_scenes(ctx context.Context, field graphql.CollectedField, obj *ScenePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ScenePage_scenes,
		func(ctx context.Context) (any, error) {
			return obj.Scenes, nil
		},
		nil,
		ec.marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ScenePage_scenes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScenePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SceneSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_SceneSummary_name(ctx, field)
			case "description":
				return ec.fieldContext_SceneSummary_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_SceneSummary_fixtureCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_SceneSummary_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SceneSummary_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SceneSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScenePage_pagination(ctx context.Context, field graphql.CollectedField, obj *ScenePage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ScenePage_pagination,
		func(ctx context.Context) (any, error) {
			return obj.Pagination, nil
		},
		nil,
		ec.marshalNPaginationInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedPaginationInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ScenePage_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScenePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "perPage":
				return ec.fieldContext_PaginationInfo_perPage(ctx, field)
			case "totalPages":
				return ec.fieldContext_PaginationInfo_totalPages(ctx, field)
			case "hasMore":
				return ec.fieldContext_PaginationInfo_hasMore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_id(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_name(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_description(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_fixtureCount(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_fixtureCount,
		func(ctx context.Context) (any, error) {
			return obj.FixtureCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_fixtureCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_createdAt(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneSummary_updatedAt(ctx context.Context, field graphql.CollectedField, obj *SceneSummary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneSummary_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneSummary_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneUsage_sceneId(ctx context.Context, field graphql.CollectedField, obj *SceneUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneUsage_sceneId,
		func(ctx context.Context) (any, error) {
			return obj.SceneID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneUsage_sceneId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneUsage_sceneName(ctx context.Context, field graphql.CollectedField, obj *SceneUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneUsage_sceneName,
		func(ctx context.Context) (any, error) {
			return obj.SceneName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneUsage_sceneName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneUsage_cues(ctx context.Context, field graphql.CollectedField, obj *SceneUsage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SceneUsage_cues,
		func(ctx context.Context) (any, error) {
			return obj.Cues, nil
		},
		nil,
		ec.marshalNCueUsageSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueUsageSummary,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SceneUsage_cues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cueId":
				return ec.fieldContext_CueUsageSummary_cueId(ctx, field)
			case "cueNumber":
				return ec.fieldContext_CueUsageSummary_cueNumber(ctx, field)
			case "cueName":
				return ec.fieldContext_CueUsageSummary_cueName(ctx, field)
			case "cueListId":
				return ec.fieldContext_CueUsageSummary_cueListId(ctx, field)
			case "cueListName":
				return ec.fieldContext_CueUsageSummary_cueListName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueUsageSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_id(ctx context.Context, field graphql.CollectedField, obj *models.Setting) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Setting_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Setting_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_key(ctx context.Context, field graphql.CollectedField, obj *models.Setting) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Setting_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Setting_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_value(ctx context.Context, field graphql.CollectedField, obj *models.Setting) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Setting_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Setting_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Setting) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Setting_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Setting().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Setting_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Setting) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Setting_updatedAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Setting().UpdatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Setting_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_dmxOutputChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_dmxOutputChanged,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().DmxOutputChanged(ctx, fc.Args["universe"].(*int))
		},
		nil,
		ec.marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_dmxOutputChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "universe":
				return ec.fieldContext_UniverseOutput_universe(ctx, field)
			case "channels":
				return ec.fieldContext_UniverseOutput_channels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UniverseOutput", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_dmxOutputChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_projectUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_projectUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().ProjectUpdated(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_projectUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "fixtureCount":
				return ec.fieldContext_Project_fixtureCount(ctx, field)
			case "sceneCount":
				return ec.fieldContext_Project_sceneCount(ctx, field)
			case "cueListCount":
				return ec.fieldContext_Project_cueListCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Project_updatedAt(ctx, field)
			case "fixtures":
				return ec.fieldContext_Project_fixtures(ctx, field)
			case "scenes":
				return ec.fieldContext_Project_scenes(ctx, field)
			case "cueLists":
				return ec.fieldContext_Project_cueLists(ctx, field)
			case "sceneBoards":
				return ec.fieldContext_Project_sceneBoards(ctx, field)
			case "users":
				return ec.fieldContext_Project_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_projectUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_previewSessionUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_previewSessionUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().PreviewSessionUpdated(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_previewSessionUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PreviewSession_id(ctx, field)
			case "project":
				return ec.fieldContext_PreviewSession_project(ctx, field)
			case "user":
				return ec.fieldContext_PreviewSession_user(ctx, field)
			case "isActive":
				return ec.fieldContext_PreviewSession_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_PreviewSession_createdAt(ctx, field)
			case "dmxOutput":
				return ec.fieldContext_PreviewSession_dmxOutput(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_previewSessionUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_cueListPlaybackUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_cueListPlaybackUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().CueListPlaybackUpdated(ctx, fc.Args["cueListId"].(string))
		},
		nil,
		ec.marshalNCueListPlaybackStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListPlaybackStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_cueListPlaybackUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cueListId":
				return ec.fieldContext_CueListPlaybackStatus_cueListId(ctx, field)
			case "currentCueIndex":
				return ec.fieldContext_CueListPlaybackStatus_currentCueIndex(ctx, field)
			case "isPlaying":
				return ec.fieldContext_CueListPlaybackStatus_isPlaying(ctx, field)
			case "isFading":
				return ec.fieldContext_CueListPlaybackStatus_isFading(ctx, field)
			case "currentCue":
				return ec.fieldContext_CueListPlaybackStatus_currentCue(ctx, field)
			case "nextCue":
				return ec.fieldContext_CueListPlaybackStatus_nextCue(ctx, field)
			case "previousCue":
				return ec.fieldContext_CueListPlaybackStatus_previousCue(ctx, field)
			case "fadeProgress":
				return ec.fieldContext_CueListPlaybackStatus_fadeProgress(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_CueListPlaybackStatus_lastUpdated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CueListPlaybackStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_cueListPlaybackUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_systemInfoUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_systemInfoUpdated,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Subscription().SystemInfoUpdated(ctx)
		},
		nil,
		ec.marshalNSystemInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_systemInfoUpdated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artnetBroadcastAddress":
				return ec.fieldContext_SystemInfo_artnetBroadcastAddress(ctx, field)
			case "artnetEnabled":
				return ec.fieldContext_SystemInfo_artnetEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SystemInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_wifiStatusUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_wifiStatusUpdated,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Subscription().WifiStatusUpdated(ctx)
		},
		nil,
		ec.marshalNWiFiStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_wifiStatusUpdated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "available":
				return ec.fieldContext_WiFiStatus_available(ctx, field)
			case "enabled":
				return ec.fieldContext_WiFiStatus_enabled(ctx, field)
			case "connected":
				return ec.fieldContext_WiFiStatus_connected(ctx, field)
			case "ssid":
				return ec.fieldContext_WiFiStatus_ssid(ctx, field)
			case "signalStrength":
				return ec.fieldContext_WiFiStatus_signalStrength(ctx, field)
			case "ipAddress":
				return ec.fieldContext_WiFiStatus_ipAddress(ctx, field)
			case "macAddress":
				return ec.fieldContext_WiFiStatus_macAddress(ctx, field)
			case "frequency":
				return ec.fieldContext_WiFiStatus_frequency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WiFiStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_oflImportProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_oflImportProgress,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Subscription().OflImportProgress(ctx)
		},
		nil,
		ec.marshalNOFLImportStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_oflImportProgress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isImporting":
				return ec.fieldContext_OFLImportStatus_isImporting(ctx, field)
			case "phase":
				return ec.fieldContext_OFLImportStatus_phase(ctx, field)
			case "totalFixtures":
				return ec.fieldContext_OFLImportStatus_totalFixtures(ctx, field)
			case "importedCount":
				return ec.fieldContext_OFLImportStatus_importedCount(ctx, field)
			case "failedCount":
				return ec.fieldContext_OFLImportStatus_failedCount(ctx, field)
			case "skippedCount":
				return ec.fieldContext_OFLImportStatus_skippedCount(ctx, field)
			case "percentComplete":
				return ec.fieldContext_OFLImportStatus_percentComplete(ctx, field)
			case "currentFixture":
				return ec.fieldContext_OFLImportStatus_currentFixture(ctx, field)
			case "currentManufacturer":
				return ec.fieldContext_OFLImportStatus_currentManufacturer(ctx, field)
			case "estimatedSecondsRemaining":
				return ec.fieldContext_OFLImportStatus_estimatedSecondsRemaining(ctx, field)
			case "errorMessage":
				return ec.fieldContext_OFLImportStatus_errorMessage(ctx, field)
			case "startedAt":
				return ec.fieldContext_OFLImportStatus_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_OFLImportStatus_completedAt(ctx, field)
			case "oflVersion":
				return ec.fieldContext_OFLImportStatus_oflVersion(ctx, field)
			case "usingBundledData":
				return ec.fieldContext_OFLImportStatus_usingBundledData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OFLImportStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemInfo_artnetBroadcastAddress(ctx context.Context, field graphql.CollectedField, obj *SystemInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SystemInfo_artnetBroadcastAddress,
		func(ctx context.Context) (any, error) {
			return obj.ArtnetBroadcastAddress, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SystemInfo_artnetBroadcastAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemInfo_artnetEnabled(ctx context.Context, field graphql.CollectedField, obj *SystemInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SystemInfo_artnetEnabled,
		func(ctx context.Context) (any, error) {
			return obj.ArtnetEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SystemInfo_artnetEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemVersionInfo_repositories(ctx context.Context, field graphql.CollectedField, obj *SystemVersionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SystemVersionInfo_repositories,
		func(ctx context.Context) (any, error) {
			return obj.Repositories, nil
		},
		nil,
		ec.marshalNRepositoryVersion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedRepositoryVersion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SystemVersionInfo_repositories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemVersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repository":
				return ec.fieldContext_RepositoryVersion_repository(ctx, field)
			case "installed":
				return ec.fieldContext_RepositoryVersion_installed(ctx, field)
			case "latest":
				return ec.fieldContext_RepositoryVersion_latest(ctx, field)
			case "updateAvailable":
				return ec.fieldContext_RepositoryVersion_updateAvailable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemVersionInfo_lastChecked(ctx context.Context, field graphql.CollectedField, obj *SystemVersionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SystemVersionInfo_lastChecked,
		func(ctx context.Context) (any, error) {
			return obj.LastChecked, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SystemVersionInfo_lastChecked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemVersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemVersionInfo_versionManagementSupported(ctx context.Context, field graphql.CollectedField, obj *SystemVersionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SystemVersionInfo_versionManagementSupported,
		func(ctx context.Context) (any, error) {
			return obj.VersionManagementSupported, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SystemVersionInfo_versionManagementSupported(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemVersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseChannelMap_universe(ctx context.Context, field graphql.CollectedField, obj *UniverseChannelMap) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseChannelMap_universe,
		func(ctx context.Context) (any, error) {
			return obj.Universe, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseChannelMap_universe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseChannelMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseChannelMap_fixtures(ctx context.Context, field graphql.CollectedField, obj *UniverseChannelMap) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseChannelMap_fixtures,
		func(ctx context.Context) (any, error) {
			return obj.Fixtures, nil
		},
		nil,
		ec.marshalNChannelMapFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapFixture,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseChannelMap_fixtures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseChannelMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChannelMapFixture_id(ctx, field)
			case "name":
				return ec.fieldContext_ChannelMapFixture_name(ctx, field)
			case "type":
				return ec.fieldContext_ChannelMapFixture_type(ctx, field)
			case "startChannel":
				return ec.fieldContext_ChannelMapFixture_startChannel(ctx, field)
			case "endChannel":
				return ec.fieldContext_ChannelMapFixture_endChannel(ctx, field)
			case "channelCount":
				return ec.fieldContext_ChannelMapFixture_channelCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelMapFixture", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseChannelMap_channelUsage(ctx context.Context, field graphql.CollectedField, obj *UniverseChannelMap) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseChannelMap_channelUsage,
		func(ctx context.Context) (any, error) {
			return obj.ChannelUsage, nil
		},
		nil,
		ec.marshalNChannelUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelUsage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseChannelMap_channelUsage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseChannelMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fixtureId":
				return ec.fieldContext_ChannelUsage_fixtureId(ctx, field)
			case "fixtureName":
				return ec.fieldContext_ChannelUsage_fixtureName(ctx, field)
			case "channelType":
				return ec.fieldContext_ChannelUsage_channelType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseChannelMap_availableChannels(ctx context.Context, field graphql.CollectedField, obj *UniverseChannelMap) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseChannelMap_availableChannels,
		func(ctx context.Context) (any, error) {
			return obj.AvailableChannels, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseChannelMap_availableChannels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseChannelMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseChannelMap_usedChannels(ctx context.Context, field graphql.CollectedField, obj *UniverseChannelMap) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseChannelMap_usedChannels,
		func(ctx context.Context) (any, error) {
			return obj.UsedChannels, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseChannelMap_usedChannels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseChannelMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseOutput_universe(ctx context.Context, field graphql.CollectedField, obj *UniverseOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseOutput_universe,
		func(ctx context.Context) (any, error) {
			return obj.Universe, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseOutput_universe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UniverseOutput_channels(ctx context.Context, field graphql.CollectedField, obj *UniverseOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UniverseOutput_channels,
		func(ctx context.Context) (any, error) {
			return obj.Channels, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UniverseOutput_channels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UniverseOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_success(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_success,
		func(ctx context.Context) (any, error) {
			return obj.Success, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_repository(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_repository,
		func(ctx context.Context) (any, error) {
			return obj.Repository, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_previousVersion(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_previousVersion,
		func(ctx context.Context) (any, error) {
			return obj.PreviousVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_previousVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_newVersion(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_newVersion,
		func(ctx context.Context) (any, error) {
			return obj.NewVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_newVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_message(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResult_error(ctx context.Context, field graphql.CollectedField, obj *UpdateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateResult_error,
		func(ctx context.Context) (any, error) {
			return obj.Error, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpdateResult_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_role,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().Role(ctx, obj)
		},
		nil,
		ec.marshalNUserRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUserRole,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiConnectionResult_success(ctx context.Context, field graphql.CollectedField, obj *WiFiConnectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiConnectionResult_success,
		func(ctx context.Context) (any, error) {
			return obj.Success, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiConnectionResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiConnectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiConnectionResult_message(ctx context.Context, field graphql.CollectedField, obj *WiFiConnectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiConnectionResult_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiConnectionResult_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiConnectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiConnectionResult_connected(ctx context.Context, field graphql.CollectedField, obj *WiFiConnectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiConnectionResult_connected,
		func(ctx context.Context) (any, error) {
			return obj.Connected, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiConnectionResult_connected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiConnectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_ssid(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_ssid,
		func(ctx context.Context) (any, error) {
			return obj.Ssid, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_ssid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_signalStrength(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_signalStrength,
		func(ctx context.Context) (any, error) {
			return obj.SignalStrength, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_signalStrength(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_frequency(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_frequency,
		func(ctx context.Context) (any, error) {
			return obj.Frequency, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_frequency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_security(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_security,
		func(ctx context.Context) (any, error) {
			return obj.Security, nil
		},
		nil,
		ec.marshalNWiFiSecurityType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiSecurityType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_security(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WiFiSecurityType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_inUse(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_inUse,
		func(ctx context.Context) (any, error) {
			return obj.InUse, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_inUse(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiNetwork_saved(ctx context.Context, field graphql.CollectedField, obj *WiFiNetwork) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiNetwork_saved,
		func(ctx context.Context) (any, error) {
			return obj.Saved, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiNetwork_saved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_available(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_available,
		func(ctx context.Context) (any, error) {
			return obj.Available, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_enabled(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_connected(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_connected,
		func(ctx context.Context) (any, error) {
			return obj.Connected, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_connected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_ssid(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_ssid,
		func(ctx context.Context) (any, error) {
			return obj.Ssid, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_ssid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_signalStrength(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_signalStrength,
		func(ctx context.Context) (any, error) {
			return obj.SignalStrength, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_signalStrength(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_ipAddress(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_ipAddress,
		func(ctx context.Context) (any, error) {
			return obj.IPAddress, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_ipAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_macAddress(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_macAddress,
		func(ctx context.Context) (any, error) {
			return obj.MacAddress, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_macAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WiFiStatus_frequency(ctx context.Context, field graphql.CollectedField, obj *WiFiStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WiFiStatus_frequency,
		func(ctx context.Context) (any, error) {
			return obj.Frequency, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WiFiStatus_frequency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WiFiStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBulkCueCreateInput(ctx context.Context, obj any) (BulkCueCreateInput, error) {
	var it BulkCueCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cues"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cues":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cues"))
			data, err := ec.unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cues = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkCueListCreateInput(ctx context.Context, obj any) (BulkCueListCreateInput, error) {
	var it BulkCueListCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cueLists"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cueLists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueLists"))
			data, err := ec.unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueLists = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkCueListUpdateInput(ctx context.Context, obj any) (BulkCueListUpdateInput, error) {
	var it BulkCueListUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cueLists"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cueLists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueLists"))
			data, err := ec.unmarshalNCueListUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueLists = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkCueUpdateInput(ctx context.Context, obj any) (BulkCueUpdateInput, error) {
	var it BulkCueUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cueIds", "fadeInTime", "fadeOutTime", "followTime", "easingType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cueIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueIds"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueIds = data
		case "fadeInTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeInTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeInTime = graphql.OmittableOf(data)
		case "fadeOutTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeOutTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeOutTime = graphql.OmittableOf(data)
		case "followTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("followTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FollowTime = graphql.OmittableOf(data)
		case "easingType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("easingType"))
			data, err := ec.unmarshalOEasingType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedEasingType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EasingType = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkFixtureCreateInput(ctx context.Context, obj any) (BulkFixtureCreateInput, error) {
	var it BulkFixtureCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtures"))
			data, err := ec.unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fixtures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkFixtureDefinitionCreateInput(ctx context.Context, obj any) (BulkFixtureDefinitionCreateInput, error) {
	var it BulkFixtureDefinitionCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"definitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "definitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definitions"))
			data, err := ec.unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkFixtureDefinitionUpdateInput(ctx context.Context, obj any) (BulkFixtureDefinitionUpdateInput, error) {
	var it BulkFixtureDefinitionUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"definitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "definitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definitions"))
			data, err := ec.unmarshalNFixtureDefinitionUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkFixtureUpdateInput(ctx context.Context, obj any) (BulkFixtureUpdateInput, error) {
	var it BulkFixtureUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtures"))
			data, err := ec.unmarshalNFixtureUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fixtures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkProjectCreateInput(ctx context.Context, obj any) (BulkProjectCreateInput, error) {
	var it BulkProjectCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projects"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projects"))
			data, err := ec.unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Projects = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkProjectUpdateInput(ctx context.Context, obj any) (BulkProjectUpdateInput, error) {
	var it BulkProjectUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projects"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projects"))
			data, err := ec.unmarshalNProjectUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.Projects = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneBoardButtonCreateInput(ctx context.Context, obj any) (BulkSceneBoardButtonCreateInput, error) {
	var it BulkSceneBoardButtonCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buttons"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buttons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buttons"))
			data, err := ec.unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Buttons = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneBoardButtonUpdateInput(ctx context.Context, obj any) (BulkSceneBoardButtonUpdateInput, error) {
	var it BulkSceneBoardButtonUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buttons"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buttons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buttons"))
			data, err := ec.unmarshalNSceneBoardButtonUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.Buttons = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneBoardCreateInput(ctx context.Context, obj any) (BulkSceneBoardCreateInput, error) {
	var it BulkSceneBoardCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sceneBoards"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sceneBoards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneBoards"))
			data, err := ec.unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneBoards = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneBoardUpdateInput(ctx context.Context, obj any) (BulkSceneBoardUpdateInput, error) {
	var it BulkSceneBoardUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sceneBoards"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sceneBoards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneBoards"))
			data, err := ec.unmarshalNSceneBoardUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneBoards = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneCreateInput(ctx context.Context, obj any) (BulkSceneCreateInput, error) {
	var it BulkSceneCreateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"scenes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "scenes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scenes"))
			data, err := ec.unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scenes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkSceneUpdateInput(ctx context.Context, obj any) (BulkSceneUpdateInput, error) {
	var it BulkSceneUpdateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"scenes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "scenes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scenes"))
			data, err := ec.unmarshalNSceneUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUpdateItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scenes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelAssignmentInput(ctx context.Context, obj any) (ChannelAssignmentInput, error) {
	var it ChannelAssignmentInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["universe"]; !present {
		asMap["universe"] = 1
	}
	if _, present := asMap["startingChannel"]; !present {
		asMap["startingChannel"] = 1
	}

	fieldsInOrder := [...]string{"projectId", "universe", "startingChannel", "fixtureSpecs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "universe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universe"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Universe = graphql.OmittableOf(data)
		case "startingChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startingChannel"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartingChannel = graphql.OmittableOf(data)
		case "fixtureSpecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureSpecs"))
			data, err := ec.unmarshalNFixtureSpecInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureSpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureSpecs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelFadeBehaviorInput(ctx context.Context, obj any) (ChannelFadeBehaviorInput, error) {
	var it ChannelFadeBehaviorInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"channelId", "fadeBehavior"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "channelId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChannelID = data
		case "fadeBehavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeBehavior"))
			data, err := ec.unmarshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeBehavior = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelValueInput(ctx context.Context, obj any) (ChannelValueInput, error) {
	var it ChannelValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"offset", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChannelDefinitionInput(ctx context.Context, obj any) (CreateChannelDefinitionInput, error) {
	var it CreateChannelDefinitionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "offset", "minValue", "maxValue", "defaultValue", "fadeBehavior", "isDiscrete"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "minValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minValue"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinValue = data
		case "maxValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxValue"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxValue = data
		case "defaultValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultValue"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultValue = data
		case "fadeBehavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeBehavior"))
			data, err := ec.unmarshalOFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeBehavior = graphql.OmittableOf(data)
		case "isDiscrete":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isDiscrete"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsDiscrete = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCueInput(ctx context.Context, obj any) (CreateCueInput, error) {
	var it CreateCueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cueNumber", "cueListId", "sceneId", "fadeInTime", "fadeOutTime", "followTime", "easingType", "notes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cueNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueNumber"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueNumber = data
		case "cueListId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueListId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueListID = data
		case "sceneId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneID = data
		case "fadeInTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeInTime"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeInTime = data
		case "fadeOutTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fadeOutTime"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FadeOutTime = data
		case "followTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("followTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FollowTime = graphql.OmittableOf(data)
		case "easingType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("easingType"))
			data, err := ec.unmarshalOEasingType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedEasingType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EasingType = graphql.OmittableOf(data)
		case "notes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notes = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCueListInput(ctx context.Context, obj any) (CreateCueListInput, error) {
	var it CreateCueListInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "loop", "projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "loop":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loop"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Loop = graphql.OmittableOf(data)
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateFixtureDefinitionInput(ctx context.Context, obj any) (CreateFixtureDefinitionInput, error) {
	var it CreateFixtureDefinitionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manufacturer", "model", "type", "channels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "channels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channels"))
			data, err := ec.unmarshalNCreateChannelDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateChannelDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateFixtureInstanceInput(ctx context.Context, obj any) (CreateFixtureInstanceInput, error) {
	var it CreateFixtureInstanceInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "definitionId", "modeId", "projectId", "universe", "startChannel", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "definitionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definitionId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefinitionID = data
		case "modeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modeId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModeID = graphql.OmittableOf(data)
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "universe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universe"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Universe = data
		case "startChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startChannel"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartChannel = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj any) (CreateProjectInput, error) {
	var it CreateProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSceneBoardButtonInput(ctx context.Context, obj any) (CreateSceneBoardButtonInput, error) {
	var it CreateSceneBoardButtonInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["width"]; !present {
		asMap["width"] = 200
	}
	if _, present := asMap["height"]; !present {
		asMap["height"] = 120
	}

	fieldsInOrder := [...]string{"sceneBoardId", "sceneId", "layoutX", "layoutY", "width", "height", "color", "label"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sceneBoardId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneBoardId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneBoardID = data
		case "sceneId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneID = data
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = data
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = graphql.OmittableOf(data)
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = graphql.OmittableOf(data)
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = graphql.OmittableOf(data)
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSceneBoardInput(ctx context.Context, obj any) (CreateSceneBoardInput, error) {
	var it CreateSceneBoardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["defaultFadeTime"]; !present {
		asMap["defaultFadeTime"] = 3.000000
	}
	if _, present := asMap["gridSize"]; !present {
		asMap["gridSize"] = 50
	}
	if _, present := asMap["canvasWidth"]; !present {
		asMap["canvasWidth"] = 2000
	}
	if _, present := asMap["canvasHeight"]; !present {
		asMap["canvasHeight"] = 2000
	}

	fieldsInOrder := [...]string{"name", "description", "projectId", "defaultFadeTime", "gridSize", "canvasWidth", "canvasHeight"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "defaultFadeTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultFadeTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultFadeTime = graphql.OmittableOf(data)
		case "gridSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gridSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GridSize = graphql.OmittableOf(data)
		case "canvasWidth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasWidth"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasWidth = graphql.OmittableOf(data)
		case "canvasHeight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasHeight"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasHeight = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSceneInput(ctx context.Context, obj any) (CreateSceneInput, error) {
	var it CreateSceneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "projectId", "fixtureValues"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "fixtureValues":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureValues"))
			data, err := ec.unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureValues = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCueListUpdateItem(ctx context.Context, obj any) (CueListUpdateItem, error) {
	var it CueListUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cueListId", "name", "description", "loop"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cueListId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueListId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueListID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "loop":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loop"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Loop = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCueOrderInput(ctx context.Context, obj any) (CueOrderInput, error) {
	var it CueOrderInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cueId", "cueNumber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cueId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueID = data
		case "cueNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cueNumber"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CueNumber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExportOptionsInput(ctx context.Context, obj any) (ExportOptionsInput, error) {
	var it ExportOptionsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "includeFixtures", "includeScenes", "includeCueLists"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "includeFixtures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeFixtures"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeFixtures = graphql.OmittableOf(data)
		case "includeScenes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeScenes"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeScenes = graphql.OmittableOf(data)
		case "includeCueLists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCueLists"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCueLists = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureDefinitionFilter(ctx context.Context, obj any) (FixtureDefinitionFilter, error) {
	var it FixtureDefinitionFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manufacturer", "model", "type", "isBuiltIn", "channelTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = graphql.OmittableOf(data)
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = graphql.OmittableOf(data)
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = graphql.OmittableOf(data)
		case "isBuiltIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isBuiltIn"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsBuiltIn = graphql.OmittableOf(data)
		case "channelTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelTypes"))
			data, err := ec.unmarshalOChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChannelTypes = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureDefinitionUpdateItem(ctx context.Context, obj any) (FixtureDefinitionUpdateItem, error) {
	var it FixtureDefinitionUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"definitionId", "manufacturer", "model", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "definitionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definitionId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefinitionID = data
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = graphql.OmittableOf(data)
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = graphql.OmittableOf(data)
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureFilterInput(ctx context.Context, obj any) (FixtureFilterInput, error) {
	var it FixtureFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "universe", "tags", "manufacturer", "model"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = graphql.OmittableOf(data)
		case "universe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universe"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Universe = graphql.OmittableOf(data)
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = graphql.OmittableOf(data)
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureMappingInput(ctx context.Context, obj any) (FixtureMappingInput, error) {
	var it FixtureMappingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lacyLightsKey", "qlcManufacturer", "qlcModel", "qlcMode"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lacyLightsKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lacyLightsKey"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LacyLightsKey = data
		case "qlcManufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qlcManufacturer"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QlcManufacturer = data
		case "qlcModel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qlcModel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QlcModel = data
		case "qlcMode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qlcMode"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QlcMode = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureOrderInput(ctx context.Context, obj any) (FixtureOrderInput, error) {
	var it FixtureOrderInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtureId", "order"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureID = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixturePositionInput(ctx context.Context, obj any) (FixturePositionInput, error) {
	var it FixturePositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtureId", "layoutX", "layoutY", "layoutRotation"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureID = data
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = data
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = data
		case "layoutRotation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutRotation"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutRotation = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureSpecInput(ctx context.Context, obj any) (FixtureSpecInput, error) {
	var it FixtureSpecInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "manufacturer", "model", "mode", "channelCount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = graphql.OmittableOf(data)
		case "channelCount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelCount"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChannelCount = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureUpdateItem(ctx context.Context, obj any) (FixtureUpdateItem, error) {
	var it FixtureUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtureId", "name", "description", "universe", "startChannel", "tags", "layoutX", "layoutY", "layoutRotation"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "universe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universe"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Universe = graphql.OmittableOf(data)
		case "startChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startChannel"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartChannel = graphql.OmittableOf(data)
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = graphql.OmittableOf(data)
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = graphql.OmittableOf(data)
		case "layoutRotation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutRotation"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutRotation = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFixtureValueInput(ctx context.Context, obj any) (FixtureValueInput, error) {
	var it FixtureValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fixtureId", "channels", "sceneOrder"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fixtureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureID = data
		case "channels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channels"))
			data, err := ec.unmarshalNChannelValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channels = data
		case "sceneOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneOrder = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImportOFLFixtureInput(ctx context.Context, obj any) (ImportOFLFixtureInput, error) {
	var it ImportOFLFixtureInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manufacturer", "oflFixtureJson", "replace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = data
		case "oflFixtureJson":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oflFixtureJson"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OflFixtureJSON = data
		case "replace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("replace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Replace = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImportOptionsInput(ctx context.Context, obj any) (ImportOptionsInput, error) {
	var it ImportOptionsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mode", "targetProjectId", "projectName", "fixtureConflictStrategy", "importBuiltInFixtures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalNImportMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "targetProjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetProjectId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetProjectID = graphql.OmittableOf(data)
		case "projectName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectName = graphql.OmittableOf(data)
		case "fixtureConflictStrategy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureConflictStrategy"))
			data, err := ec.unmarshalOFixtureConflictStrategy2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureConflictStrategy(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureConflictStrategy = graphql.OmittableOf(data)
		case "importBuiltInFixtures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importBuiltInFixtures"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImportBuiltInFixtures = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOFLImportOptionsInput(ctx context.Context, obj any) (OFLImportOptionsInput, error) {
	var it OFLImportOptionsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["forceReimport"]; !present {
		asMap["forceReimport"] = false
	}
	if _, present := asMap["updateInUseFixtures"]; !present {
		asMap["updateInUseFixtures"] = false
	}
	if _, present := asMap["preferBundled"]; !present {
		asMap["preferBundled"] = false
	}

	fieldsInOrder := [...]string{"forceReimport", "updateInUseFixtures", "manufacturers", "preferBundled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "forceReimport":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forceReimport"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForceReimport = graphql.OmittableOf(data)
		case "updateInUseFixtures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateInUseFixtures"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateInUseFixtures = graphql.OmittableOf(data)
		case "manufacturers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturers = graphql.OmittableOf(data)
		case "preferBundled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferBundled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferBundled = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectUpdateItem(ctx context.Context, obj any) (ProjectUpdateItem, error) {
	var it ProjectUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneBoardButtonPositionInput(ctx context.Context, obj any) (SceneBoardButtonPositionInput, error) {
	var it SceneBoardButtonPositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buttonId", "layoutX", "layoutY"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buttonId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buttonId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ButtonID = data
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = data
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneBoardButtonUpdateItem(ctx context.Context, obj any) (SceneBoardButtonUpdateItem, error) {
	var it SceneBoardButtonUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buttonId", "layoutX", "layoutY", "width", "height", "color", "label"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buttonId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buttonId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ButtonID = data
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = graphql.OmittableOf(data)
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = graphql.OmittableOf(data)
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = graphql.OmittableOf(data)
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = graphql.OmittableOf(data)
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = graphql.OmittableOf(data)
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneBoardUpdateItem(ctx context.Context, obj any) (SceneBoardUpdateItem, error) {
	var it SceneBoardUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sceneBoardId", "name", "description", "defaultFadeTime", "gridSize", "canvasWidth", "canvasHeight"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sceneBoardId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneBoardId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneBoardID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "defaultFadeTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultFadeTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultFadeTime = graphql.OmittableOf(data)
		case "gridSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gridSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GridSize = graphql.OmittableOf(data)
		case "canvasWidth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasWidth"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasWidth = graphql.OmittableOf(data)
		case "canvasHeight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasHeight"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasHeight = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneFilterInput(ctx context.Context, obj any) (SceneFilterInput, error) {
	var it SceneFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"nameContains", "usesFixture"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = graphql.OmittableOf(data)
		case "usesFixture":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usesFixture"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsesFixture = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneUpdateItem(ctx context.Context, obj any) (SceneUpdateItem, error) {
	var it SceneUpdateItem
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sceneId", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sceneId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sceneId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateFixtureInstanceInput(ctx context.Context, obj any) (UpdateFixtureInstanceInput, error) {
	var it UpdateFixtureInstanceInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "definitionId", "modeId", "universe", "startChannel", "tags", "projectOrder", "layoutX", "layoutY", "layoutRotation"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "definitionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definitionId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefinitionID = graphql.OmittableOf(data)
		case "modeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modeId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModeID = graphql.OmittableOf(data)
		case "universe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universe"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Universe = graphql.OmittableOf(data)
		case "startChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startChannel"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartChannel = graphql.OmittableOf(data)
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		case "projectOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectOrder = graphql.OmittableOf(data)
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = graphql.OmittableOf(data)
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = graphql.OmittableOf(data)
		case "layoutRotation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutRotation"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutRotation = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSceneBoardButtonInput(ctx context.Context, obj any) (UpdateSceneBoardButtonInput, error) {
	var it UpdateSceneBoardButtonInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layoutX", "layoutY", "width", "height", "color", "label"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layoutX":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutX"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutX = graphql.OmittableOf(data)
		case "layoutY":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layoutY"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LayoutY = graphql.OmittableOf(data)
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = graphql.OmittableOf(data)
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = graphql.OmittableOf(data)
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = graphql.OmittableOf(data)
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSceneBoardInput(ctx context.Context, obj any) (UpdateSceneBoardInput, error) {
	var it UpdateSceneBoardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "defaultFadeTime", "gridSize", "canvasWidth", "canvasHeight"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "defaultFadeTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultFadeTime"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultFadeTime = graphql.OmittableOf(data)
		case "gridSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gridSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GridSize = graphql.OmittableOf(data)
		case "canvasWidth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasWidth"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasWidth = graphql.OmittableOf(data)
		case "canvasHeight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canvasHeight"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanvasHeight = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSceneInput(ctx context.Context, obj any) (UpdateSceneInput, error) {
	var it UpdateSceneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "fixtureValues"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "fixtureValues":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixtureValues"))
			data, err := ec.unmarshalOFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixtureValues = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSettingInput(ctx context.Context, obj any) (UpdateSettingInput, error) {
	var it UpdateSettingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var bulkDeleteResultImplementors = []string{"BulkDeleteResult"}

func (ec *executionContext) _BulkDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *BulkDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bulkDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BulkDeleteResult")
		case "deletedCount":
			out.Values[i] = ec._BulkDeleteResult_deletedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedIds":
			out.Values[i] = ec._BulkDeleteResult_deletedIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelAssignmentSuggestionImplementors = []string{"ChannelAssignmentSuggestion"}

func (ec *executionContext) _ChannelAssignmentSuggestion(ctx context.Context, sel ast.SelectionSet, obj *ChannelAssignmentSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelAssignmentSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelAssignmentSuggestion")
		case "universe":
			out.Values[i] = ec._ChannelAssignmentSuggestion_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignments":
			out.Values[i] = ec._ChannelAssignmentSuggestion_assignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalChannelsNeeded":
			out.Values[i] = ec._ChannelAssignmentSuggestion_totalChannelsNeeded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "availableChannelsRemaining":
			out.Values[i] = ec._ChannelAssignmentSuggestion_availableChannelsRemaining(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelDefinitionImplementors = []string{"ChannelDefinition"}

func (ec *executionContext) _ChannelDefinition(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelDefinition")
		case "id":
			out.Values[i] = ec._ChannelDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ChannelDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChannelDefinition_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "offset":
			out.Values[i] = ec._ChannelDefinition_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minValue":
			out.Values[i] = ec._ChannelDefinition_minValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxValue":
			out.Values[i] = ec._ChannelDefinition_maxValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "defaultValue":
			out.Values[i] = ec._ChannelDefinition_defaultValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fadeBehavior":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChannelDefinition_fadeBehavior(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isDiscrete":
			out.Values[i] = ec._ChannelDefinition_isDiscrete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelMapFixtureImplementors = []string{"ChannelMapFixture"}

func (ec *executionContext) _ChannelMapFixture(ctx context.Context, sel ast.SelectionSet, obj *ChannelMapFixture) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelMapFixtureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelMapFixture")
		case "id":
			out.Values[i] = ec._ChannelMapFixture_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChannelMapFixture_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ChannelMapFixture_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startChannel":
			out.Values[i] = ec._ChannelMapFixture_startChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endChannel":
			out.Values[i] = ec._ChannelMapFixture_endChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelCount":
			out.Values[i] = ec._ChannelMapFixture_channelCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelMapResultImplementors = []string{"ChannelMapResult"}

func (ec *executionContext) _ChannelMapResult(ctx context.Context, sel ast.SelectionSet, obj *ChannelMapResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelMapResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelMapResult")
		case "projectId":
			out.Values[i] = ec._ChannelMapResult_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "universes":
			out.Values[i] = ec._ChannelMapResult_universes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelUsageImplementors = []string{"ChannelUsage"}

func (ec *executionContext) _ChannelUsage(ctx context.Context, sel ast.SelectionSet, obj *ChannelUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelUsageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelUsage")
		case "fixtureId":
			out.Values[i] = ec._ChannelUsage_fixtureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureName":
			out.Values[i] = ec._ChannelUsage_fixtureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelType":
			out.Values[i] = ec._ChannelUsage_channelType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var channelValueImplementors = []string{"ChannelValue"}

func (ec *executionContext) _ChannelValue(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelValue")
		case "offset":
			out.Values[i] = ec._ChannelValue_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._ChannelValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cueImplementors = []string{"Cue"}

func (ec *executionContext) _Cue(ctx context.Context, sel ast.SelectionSet, obj *models.Cue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Cue")
		case "id":
			out.Values[i] = ec._Cue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Cue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cueNumber":
			out.Values[i] = ec._Cue_cueNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "scene":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Cue_scene(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cueList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Cue_cueList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fadeInTime":
			out.Values[i] = ec._Cue_fadeInTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fadeOutTime":
			out.Values[i] = ec._Cue_fadeOutTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "followTime":
			out.Values[i] = ec._Cue_followTime(ctx, field, obj)
		case "easingType":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Cue_easingType(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "notes":
			out.Values[i] = ec._Cue_notes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cueListImplementors = []string{"CueList"}

func (ec *executionContext) _CueList(ctx context.Context, sel ast.SelectionSet, obj *models.CueList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cueListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CueList")
		case "id":
			out.Values[i] = ec._CueList_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._CueList_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._CueList_description(ctx, field, obj)
		case "loop":
			out.Values[i] = ec._CueList_loop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cues":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_cues(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cueCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_cueCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalDuration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_totalDuration(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CueList_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cueListPlaybackStatusImplementors = []string{"CueListPlaybackStatus"}

func (ec *executionContext) _CueListPlaybackStatus(ctx context.Context, sel ast.SelectionSet, obj *CueListPlaybackStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cueListPlaybackStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CueListPlaybackStatus")
		case "cueListId":
			out.Values[i] = ec._CueListPlaybackStatus_cueListId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentCueIndex":
			out.Values[i] = ec._CueListPlaybackStatus_currentCueIndex(ctx, field, obj)
		case "isPlaying":
			out.Values[i] = ec._CueListPlaybackStatus_isPlaying(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isFading":
			out.Values[i] = ec._CueListPlaybackStatus_isFading(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentCue":
			out.Values[i] = ec._CueListPlaybackStatus_currentCue(ctx, field, obj)
		case "nextCue":
			out.Values[i] = ec._CueListPlaybackStatus_nextCue(ctx, field, obj)
		case "previousCue":
			out.Values[i] = ec._CueListPlaybackStatus_previousCue(ctx, field, obj)
		case "fadeProgress":
			out.Values[i] = ec._CueListPlaybackStatus_fadeProgress(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._CueListPlaybackStatus_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cueListSummaryImplementors = []string{"CueListSummary"}

func (ec *executionContext) _CueListSummary(ctx context.Context, sel ast.SelectionSet, obj *CueListSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cueListSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CueListSummary")
		case "id":
			out.Values[i] = ec._CueListSummary_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CueListSummary_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CueListSummary_description(ctx, field, obj)
		case "cueCount":
			out.Values[i] = ec._CueListSummary_cueCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalDuration":
			out.Values[i] = ec._CueListSummary_totalDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loop":
			out.Values[i] = ec._CueListSummary_loop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._CueListSummary_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cuePageImplementors = []string{"CuePage"}

func (ec *executionContext) _CuePage(ctx context.Context, sel ast.SelectionSet, obj *CuePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cuePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CuePage")
		case "cues":
			out.Values[i] = ec._CuePage_cues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._CuePage_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cueUsageSummaryImplementors = []string{"CueUsageSummary"}

func (ec *executionContext) _CueUsageSummary(ctx context.Context, sel ast.SelectionSet, obj *CueUsageSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cueUsageSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CueUsageSummary")
		case "cueId":
			out.Values[i] = ec._CueUsageSummary_cueId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueNumber":
			out.Values[i] = ec._CueUsageSummary_cueNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueName":
			out.Values[i] = ec._CueUsageSummary_cueName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListId":
			out.Values[i] = ec._CueUsageSummary_cueListId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListName":
			out.Values[i] = ec._CueUsageSummary_cueListName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var exportResultImplementors = []string{"ExportResult"}

func (ec *executionContext) _ExportResult(ctx context.Context, sel ast.SelectionSet, obj *ExportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, exportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExportResult")
		case "projectId":
			out.Values[i] = ec._ExportResult_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projectName":
			out.Values[i] = ec._ExportResult_projectName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jsonContent":
			out.Values[i] = ec._ExportResult_jsonContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stats":
			out.Values[i] = ec._ExportResult_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var exportStatsImplementors = []string{"ExportStats"}

func (ec *executionContext) _ExportStats(ctx context.Context, sel ast.SelectionSet, obj *ExportStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, exportStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExportStats")
		case "fixtureDefinitionsCount":
			out.Values[i] = ec._ExportStats_fixtureDefinitionsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureInstancesCount":
			out.Values[i] = ec._ExportStats_fixtureInstancesCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scenesCount":
			out.Values[i] = ec._ExportStats_scenesCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListsCount":
			out.Values[i] = ec._ExportStats_cueListsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cuesCount":
			out.Values[i] = ec._ExportStats_cuesCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureChannelAssignmentImplementors = []string{"FixtureChannelAssignment"}

func (ec *executionContext) _FixtureChannelAssignment(ctx context.Context, sel ast.SelectionSet, obj *FixtureChannelAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureChannelAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureChannelAssignment")
		case "fixtureName":
			out.Values[i] = ec._FixtureChannelAssignment_fixtureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manufacturer":
			out.Values[i] = ec._FixtureChannelAssignment_manufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._FixtureChannelAssignment_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mode":
			out.Values[i] = ec._FixtureChannelAssignment_mode(ctx, field, obj)
		case "startChannel":
			out.Values[i] = ec._FixtureChannelAssignment_startChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endChannel":
			out.Values[i] = ec._FixtureChannelAssignment_endChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelCount":
			out.Values[i] = ec._FixtureChannelAssignment_channelCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelRange":
			out.Values[i] = ec._FixtureChannelAssignment_channelRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureDefinitionImplementors = []string{"FixtureDefinition"}

func (ec *executionContext) _FixtureDefinition(ctx context.Context, sel ast.SelectionSet, obj *models.FixtureDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureDefinition")
		case "id":
			out.Values[i] = ec._FixtureDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "manufacturer":
			out.Values[i] = ec._FixtureDefinition_manufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "model":
			out.Values[i] = ec._FixtureDefinition_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureDefinition_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "channels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureDefinition_channels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "modes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureDefinition_modes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isBuiltIn":
			out.Values[i] = ec._FixtureDefinition_isBuiltIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureDefinition_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureInstanceImplementors = []string{"FixtureInstance"}

func (ec *executionContext) _FixtureInstance(ctx context.Context, sel ast.SelectionSet, obj *models.FixtureInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureInstance")
		case "id":
			out.Values[i] = ec._FixtureInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._FixtureInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._FixtureInstance_description(ctx, field, obj)
		case "definitionId":
			out.Values[i] = ec._FixtureInstance_definitionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "manufacturer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_manufacturer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "model":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_model(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "modeName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_modeName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "channelCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_channelCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "channels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_channels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "universe":
			out.Values[i] = ec._FixtureInstance_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startChannel":
			out.Values[i] = ec._FixtureInstance_startChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectOrder":
			out.Values[i] = ec._FixtureInstance_projectOrder(ctx, field, obj)
		case "layoutX":
			out.Values[i] = ec._FixtureInstance_layoutX(ctx, field, obj)
		case "layoutY":
			out.Values[i] = ec._FixtureInstance_layoutY(ctx, field, obj)
		case "layoutRotation":
			out.Values[i] = ec._FixtureInstance_layoutRotation(ctx, field, obj)
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureInstance_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureInstancePageImplementors = []string{"FixtureInstancePage"}

func (ec *executionContext) _FixtureInstancePage(ctx context.Context, sel ast.SelectionSet, obj *FixtureInstancePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureInstancePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureInstancePage")
		case "fixtures":
			out.Values[i] = ec._FixtureInstancePage_fixtures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._FixtureInstancePage_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureMappingImplementors = []string{"FixtureMapping"}

func (ec *executionContext) _FixtureMapping(ctx context.Context, sel ast.SelectionSet, obj *FixtureMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureMapping")
		case "lacyLightsKey":
			out.Values[i] = ec._FixtureMapping_lacyLightsKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "qlcManufacturer":
			out.Values[i] = ec._FixtureMapping_qlcManufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "qlcModel":
			out.Values[i] = ec._FixtureMapping_qlcModel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "qlcMode":
			out.Values[i] = ec._FixtureMapping_qlcMode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureMappingSuggestionImplementors = []string{"FixtureMappingSuggestion"}

func (ec *executionContext) _FixtureMappingSuggestion(ctx context.Context, sel ast.SelectionSet, obj *FixtureMappingSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureMappingSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureMappingSuggestion")
		case "fixture":
			out.Values[i] = ec._FixtureMappingSuggestion_fixture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestions":
			out.Values[i] = ec._FixtureMappingSuggestion_suggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureModeImplementors = []string{"FixtureMode"}

func (ec *executionContext) _FixtureMode(ctx context.Context, sel ast.SelectionSet, obj *models.FixtureMode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureModeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureMode")
		case "id":
			out.Values[i] = ec._FixtureMode_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._FixtureMode_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shortName":
			out.Values[i] = ec._FixtureMode_shortName(ctx, field, obj)
		case "channelCount":
			out.Values[i] = ec._FixtureMode_channelCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "channels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureMode_channels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureUsageImplementors = []string{"FixtureUsage"}

func (ec *executionContext) _FixtureUsage(ctx context.Context, sel ast.SelectionSet, obj *FixtureUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureUsageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureUsage")
		case "fixtureId":
			out.Values[i] = ec._FixtureUsage_fixtureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureName":
			out.Values[i] = ec._FixtureUsage_fixtureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scenes":
			out.Values[i] = ec._FixtureUsage_scenes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cues":
			out.Values[i] = ec._FixtureUsage_cues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fixtureValueImplementors = []string{"FixtureValue"}

func (ec *executionContext) _FixtureValue(ctx context.Context, sel ast.SelectionSet, obj *models.FixtureValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fixtureValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FixtureValue")
		case "id":
			out.Values[i] = ec._FixtureValue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fixture":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureValue_fixture(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "channels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FixtureValue_channels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sceneOrder":
			out.Values[i] = ec._FixtureValue_sceneOrder(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importResultImplementors = []string{"ImportResult"}

func (ec *executionContext) _ImportResult(ctx context.Context, sel ast.SelectionSet, obj *ImportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportResult")
		case "projectId":
			out.Values[i] = ec._ImportResult_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stats":
			out.Values[i] = ec._ImportResult_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._ImportResult_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importStatsImplementors = []string{"ImportStats"}

func (ec *executionContext) _ImportStats(ctx context.Context, sel ast.SelectionSet, obj *ImportStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportStats")
		case "fixtureDefinitionsCreated":
			out.Values[i] = ec._ImportStats_fixtureDefinitionsCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureInstancesCreated":
			out.Values[i] = ec._ImportStats_fixtureInstancesCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scenesCreated":
			out.Values[i] = ec._ImportStats_scenesCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListsCreated":
			out.Values[i] = ec._ImportStats_cueListsCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cuesCreated":
			out.Values[i] = ec._ImportStats_cuesCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var instanceChannelImplementors = []string{"InstanceChannel"}

func (ec *executionContext) _InstanceChannel(ctx context.Context, sel ast.SelectionSet, obj *models.InstanceChannel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, instanceChannelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstanceChannel")
		case "id":
			out.Values[i] = ec._InstanceChannel_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "offset":
			out.Values[i] = ec._InstanceChannel_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._InstanceChannel_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InstanceChannel_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "minValue":
			out.Values[i] = ec._InstanceChannel_minValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxValue":
			out.Values[i] = ec._InstanceChannel_maxValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "defaultValue":
			out.Values[i] = ec._InstanceChannel_defaultValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fadeBehavior":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InstanceChannel_fadeBehavior(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isDiscrete":
			out.Values[i] = ec._InstanceChannel_isDiscrete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lacyLightsFixtureImplementors = []string{"LacyLightsFixture"}

func (ec *executionContext) _LacyLightsFixture(ctx context.Context, sel ast.SelectionSet, obj *LacyLightsFixture) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lacyLightsFixtureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LacyLightsFixture")
		case "manufacturer":
			out.Values[i] = ec._LacyLightsFixture_manufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._LacyLightsFixture_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modeChannelImplementors = []string{"ModeChannel"}

func (ec *executionContext) _ModeChannel(ctx context.Context, sel ast.SelectionSet, obj *models.ModeChannel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modeChannelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModeChannel")
		case "id":
			out.Values[i] = ec._ModeChannel_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "offset":
			out.Values[i] = ec._ModeChannel_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "channel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModeChannel_channel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateProjects":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateProjects(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateProjects":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateProjects(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteProjects":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteProjects(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFixtureDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFixtureDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importOFLFixture":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_importOFLFixture(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFixtureDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFixtureDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFixtureDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFixtureDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateFixtureDefinitions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateFixtureDefinitions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateFixtureDefinitions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateFixtureDefinitions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteFixtureDefinitions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteFixtureDefinitions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFixtureInstance":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFixtureInstance(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFixtureInstance":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFixtureInstance(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateFixtures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateFixtures(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateFixtures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateFixtures(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFixtureInstance":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFixtureInstance(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteFixtures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteFixtures(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateInstanceChannelFadeBehavior":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateInstanceChannelFadeBehavior(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateInstanceChannelsFadeBehavior":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateInstanceChannelsFadeBehavior(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reorderProjectFixtures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reorderProjectFixtures(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reorderSceneFixtures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reorderSceneFixtures(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFixturePositions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFixturePositions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duplicateScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_duplicateScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cloneScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cloneScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateScenes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateScenes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateScenes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateScenes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteScenes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteScenes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addFixturesToScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addFixturesToScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeFixturesFromScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeFixturesFromScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateScenePartial":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateScenePartial(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSceneBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSceneBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSceneBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSceneBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSceneBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSceneBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateSceneBoards":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateSceneBoards(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateSceneBoards":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateSceneBoards(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteSceneBoards":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteSceneBoards(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addSceneToBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addSceneToBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSceneBoardButton":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSceneBoardButton(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeSceneFromBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeSceneFromBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSceneBoardButtonPositions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSceneBoardButtonPositions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateSceneBoardButtons":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateSceneBoardButtons(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateSceneBoardButtons":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateSceneBoardButtons(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteSceneBoardButtons":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteSceneBoardButtons(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activateSceneFromBoard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_activateSceneFromBoard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createCueList":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCueList(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCueList":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCueList(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCueList":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCueList(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateCueLists":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateCueLists(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateCueLists":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateCueLists(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteCueLists":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteCueLists(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reorderCues":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reorderCues(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateCues":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateCues(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkUpdateCues":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkUpdateCues(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteCues":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteCues(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startPreviewSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startPreviewSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "commitPreviewSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_commitPreviewSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelPreviewSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelPreviewSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatePreviewChannel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePreviewChannel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "initializePreviewWithScene":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_initializePreviewWithScene(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setChannelValue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setChannelValue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setSceneLive":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setSceneLive(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "playCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_playCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fadeToBlack":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_fadeToBlack(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCueList":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startCueList(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_nextCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_previousCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goToCue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_goToCue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stopCueList":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_stopCueList(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exportProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exportProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_importProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importProjectFromQLC":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_importProjectFromQLC(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exportProjectToQLC":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exportProjectToQLC(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectWiFi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_connectWiFi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disconnectWiFi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disconnectWiFi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setWiFiEnabled":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setWiFiEnabled(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "forgetWiFiNetwork":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_forgetWiFiNetwork(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRepository":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRepository(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAllRepositories":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAllRepositories(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerOFLImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_triggerOFLImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelOFLImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelOFLImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkInterfaceOptionImplementors = []string{"NetworkInterfaceOption"}

func (ec *executionContext) _NetworkInterfaceOption(ctx context.Context, sel ast.SelectionSet, obj *NetworkInterfaceOption) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkInterfaceOptionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkInterfaceOption")
		case "name":
			out.Values[i] = ec._NetworkInterfaceOption_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._NetworkInterfaceOption_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "broadcast":
			out.Values[i] = ec._NetworkInterfaceOption_broadcast(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._NetworkInterfaceOption_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaceType":
			out.Values[i] = ec._NetworkInterfaceOption_interfaceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oFLFixtureUpdateImplementors = []string{"OFLFixtureUpdate"}

func (ec *executionContext) _OFLFixtureUpdate(ctx context.Context, sel ast.SelectionSet, obj *OFLFixtureUpdate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oFLFixtureUpdateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OFLFixtureUpdate")
		case "fixtureKey":
			out.Values[i] = ec._OFLFixtureUpdate_fixtureKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manufacturer":
			out.Values[i] = ec._OFLFixtureUpdate_manufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._OFLFixtureUpdate_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeType":
			out.Values[i] = ec._OFLFixtureUpdate_changeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isInUse":
			out.Values[i] = ec._OFLFixtureUpdate_isInUse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "instanceCount":
			out.Values[i] = ec._OFLFixtureUpdate_instanceCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentHash":
			out.Values[i] = ec._OFLFixtureUpdate_currentHash(ctx, field, obj)
		case "newHash":
			out.Values[i] = ec._OFLFixtureUpdate_newHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oFLImportResultImplementors = []string{"OFLImportResult"}

func (ec *executionContext) _OFLImportResult(ctx context.Context, sel ast.SelectionSet, obj *OFLImportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oFLImportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OFLImportResult")
		case "success":
			out.Values[i] = ec._OFLImportResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stats":
			out.Values[i] = ec._OFLImportResult_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._OFLImportResult_errorMessage(ctx, field, obj)
		case "oflVersion":
			out.Values[i] = ec._OFLImportResult_oflVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oFLImportStatsImplementors = []string{"OFLImportStats"}

func (ec *executionContext) _OFLImportStats(ctx context.Context, sel ast.SelectionSet, obj *OFLImportStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oFLImportStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OFLImportStats")
		case "totalProcessed":
			out.Values[i] = ec._OFLImportStats_totalProcessed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successfulImports":
			out.Values[i] = ec._OFLImportStats_successfulImports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedImports":
			out.Values[i] = ec._OFLImportStats_failedImports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skippedDuplicates":
			out.Values[i] = ec._OFLImportStats_skippedDuplicates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedFixtures":
			out.Values[i] = ec._OFLImportStats_updatedFixtures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "durationSeconds":
			out.Values[i] = ec._OFLImportStats_durationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oFLImportStatusImplementors = []string{"OFLImportStatus"}

func (ec *executionContext) _OFLImportStatus(ctx context.Context, sel ast.SelectionSet, obj *OFLImportStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oFLImportStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OFLImportStatus")
		case "isImporting":
			out.Values[i] = ec._OFLImportStatus_isImporting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phase":
			out.Values[i] = ec._OFLImportStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalFixtures":
			out.Values[i] = ec._OFLImportStatus_totalFixtures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importedCount":
			out.Values[i] = ec._OFLImportStatus_importedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedCount":
			out.Values[i] = ec._OFLImportStatus_failedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skippedCount":
			out.Values[i] = ec._OFLImportStatus_skippedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "percentComplete":
			out.Values[i] = ec._OFLImportStatus_percentComplete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentFixture":
			out.Values[i] = ec._OFLImportStatus_currentFixture(ctx, field, obj)
		case "currentManufacturer":
			out.Values[i] = ec._OFLImportStatus_currentManufacturer(ctx, field, obj)
		case "estimatedSecondsRemaining":
			out.Values[i] = ec._OFLImportStatus_estimatedSecondsRemaining(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._OFLImportStatus_errorMessage(ctx, field, obj)
		case "startedAt":
			out.Values[i] = ec._OFLImportStatus_startedAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._OFLImportStatus_completedAt(ctx, field, obj)
		case "oflVersion":
			out.Values[i] = ec._OFLImportStatus_oflVersion(ctx, field, obj)
		case "usingBundledData":
			out.Values[i] = ec._OFLImportStatus_usingBundledData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oFLUpdateCheckResultImplementors = []string{"OFLUpdateCheckResult"}

func (ec *executionContext) _OFLUpdateCheckResult(ctx context.Context, sel ast.SelectionSet, obj *OFLUpdateCheckResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oFLUpdateCheckResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OFLUpdateCheckResult")
		case "currentFixtureCount":
			out.Values[i] = ec._OFLUpdateCheckResult_currentFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oflFixtureCount":
			out.Values[i] = ec._OFLUpdateCheckResult_oflFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newFixtureCount":
			out.Values[i] = ec._OFLUpdateCheckResult_newFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changedFixtureCount":
			out.Values[i] = ec._OFLUpdateCheckResult_changedFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changedInUseCount":
			out.Values[i] = ec._OFLUpdateCheckResult_changedInUseCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureUpdates":
			out.Values[i] = ec._OFLUpdateCheckResult_fixtureUpdates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oflVersion":
			out.Values[i] = ec._OFLUpdateCheckResult_oflVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedAt":
			out.Values[i] = ec._OFLUpdateCheckResult_checkedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginationInfoImplementors = []string{"PaginationInfo"}

func (ec *executionContext) _PaginationInfo(ctx context.Context, sel ast.SelectionSet, obj *PaginationInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginationInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginationInfo")
		case "total":
			out.Values[i] = ec._PaginationInfo_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "page":
			out.Values[i] = ec._PaginationInfo_page(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "perPage":
			out.Values[i] = ec._PaginationInfo_perPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalPages":
			out.Values[i] = ec._PaginationInfo_totalPages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasMore":
			out.Values[i] = ec._PaginationInfo_hasMore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var previewSessionImplementors = []string{"PreviewSession"}

func (ec *executionContext) _PreviewSession(ctx context.Context, sel ast.SelectionSet, obj *models.PreviewSession) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, previewSessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreviewSession")
		case "id":
			out.Values[i] = ec._PreviewSession_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewSession_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewSession_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isActive":
			out.Values[i] = ec._PreviewSession_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewSession_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dmxOutput":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewSession_dmxOutput(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *models.Project) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Project_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Project_description(ctx, field, obj)
		case "fixtureCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_fixtureCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sceneCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_sceneCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cueListCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_cueListCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fixtures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_fixtures(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_scenes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cueLists":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_cueLists(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sceneBoards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_sceneBoards(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectUserImplementors = []string{"ProjectUser"}

func (ec *executionContext) _ProjectUser(ctx context.Context, sel ast.SelectionSet, obj *models.ProjectUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectUser")
		case "id":
			out.Values[i] = ec._ProjectUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectUser_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectUser_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "role":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectUser_role(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "joinedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectUser_joinedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qLCExportResultImplementors = []string{"QLCExportResult"}

func (ec *executionContext) _QLCExportResult(ctx context.Context, sel ast.SelectionSet, obj *QLCExportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qLCExportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QLCExportResult")
		case "projectName":
			out.Values[i] = ec._QLCExportResult_projectName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "xmlContent":
			out.Values[i] = ec._QLCExportResult_xmlContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureCount":
			out.Values[i] = ec._QLCExportResult_fixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sceneCount":
			out.Values[i] = ec._QLCExportResult_sceneCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListCount":
			out.Values[i] = ec._QLCExportResult_cueListCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qLCFixtureDefinitionImplementors = []string{"QLCFixtureDefinition"}

func (ec *executionContext) _QLCFixtureDefinition(ctx context.Context, sel ast.SelectionSet, obj *QLCFixtureDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qLCFixtureDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QLCFixtureDefinition")
		case "manufacturer":
			out.Values[i] = ec._QLCFixtureDefinition_manufacturer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._QLCFixtureDefinition_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._QLCFixtureDefinition_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modes":
			out.Values[i] = ec._QLCFixtureDefinition_modes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qLCFixtureMappingResultImplementors = []string{"QLCFixtureMappingResult"}

func (ec *executionContext) _QLCFixtureMappingResult(ctx context.Context, sel ast.SelectionSet, obj *QLCFixtureMappingResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qLCFixtureMappingResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QLCFixtureMappingResult")
		case "projectId":
			out.Values[i] = ec._QLCFixtureMappingResult_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lacyLightsFixtures":
			out.Values[i] = ec._QLCFixtureMappingResult_lacyLightsFixtures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestions":
			out.Values[i] = ec._QLCFixtureMappingResult_suggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultMappings":
			out.Values[i] = ec._QLCFixtureMappingResult_defaultMappings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qLCFixtureModeImplementors = []string{"QLCFixtureMode"}

func (ec *executionContext) _QLCFixtureMode(ctx context.Context, sel ast.SelectionSet, obj *QLCFixtureMode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qLCFixtureModeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QLCFixtureMode")
		case "name":
			out.Values[i] = ec._QLCFixtureMode_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelCount":
			out.Values[i] = ec._QLCFixtureMode_channelCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qLCImportResultImplementors = []string{"QLCImportResult"}

func (ec *executionContext) _QLCImportResult(ctx context.Context, sel ast.SelectionSet, obj *QLCImportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qLCImportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QLCImportResult")
		case "project":
			out.Values[i] = ec._QLCImportResult_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "originalFileName":
			out.Values[i] = ec._QLCImportResult_originalFileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureCount":
			out.Values[i] = ec._QLCImportResult_fixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sceneCount":
			out.Values[i] = ec._QLCImportResult_sceneCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cueListCount":
			out.Values[i] = ec._QLCImportResult_cueListCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._QLCImportResult_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "projects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureDefinitions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureDefinition":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureDefinition(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureInstances(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureInstance":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureInstance(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchFixtures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchFixtures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "channelMap":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_channelMap(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "suggestChannelAssignment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_suggestChannelAssignment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scenes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scene":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scene(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneFixtures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneFixtures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchScenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchScenes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneBoards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneBoards(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneBoard":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneBoard(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneBoardButton":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneBoardButton(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureUsage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureUsage(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneUsage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneUsage(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compareScenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compareScenes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cueLists":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cueLists(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cueList":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cueList(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cueListPlaybackStatus":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cueListPlaybackStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cue":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cue(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchCues":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchCues(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dmxOutput":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dmxOutput(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allDmxOutput":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allDmxOutput(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "previewSession":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_previewSession(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "currentActiveScene":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentActiveScene(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "settings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_settings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "setting":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_setting(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemInfo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemInfo(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "networkInterfaceOptions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_networkInterfaceOptions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wifiNetworks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wifiNetworks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wifiStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wifiStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "savedWifiNetworks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_savedWifiNetworks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getQLCFixtureMappingSuggestions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getQLCFixtureMappingSuggestions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "availableVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_availableVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oflImportStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oflImportStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkOFLUpdates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkOFLUpdates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixturesByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixturesByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scenesByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scenesByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cuesByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cuesByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cueListsByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cueListsByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sceneBoardsByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sceneBoardsByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fixtureDefinitionsByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fixtureDefinitionsByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectsByIds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectsByIds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryVersionImplementors = []string{"RepositoryVersion"}

func (ec *executionContext) _RepositoryVersion(ctx context.Context, sel ast.SelectionSet, obj *RepositoryVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryVersion")
		case "repository":
			out.Values[i] = ec._RepositoryVersion_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "installed":
			out.Values[i] = ec._RepositoryVersion_installed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latest":
			out.Values[i] = ec._RepositoryVersion_latest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAvailable":
			out.Values[i] = ec._RepositoryVersion_updateAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneImplementors = []string{"Scene"}

func (ec *executionContext) _Scene(ctx context.Context, sel ast.SelectionSet, obj *models.Scene) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Scene")
		case "id":
			out.Values[i] = ec._Scene_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Scene_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Scene_description(ctx, field, obj)
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fixtureValues":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_fixtureValues(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneBoardImplementors = []string{"SceneBoard"}

func (ec *executionContext) _SceneBoard(ctx context.Context, sel ast.SelectionSet, obj *models.SceneBoard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneBoardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneBoard")
		case "id":
			out.Values[i] = ec._SceneBoard_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._SceneBoard_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._SceneBoard_description(ctx, field, obj)
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoard_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "defaultFadeTime":
			out.Values[i] = ec._SceneBoard_defaultFadeTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gridSize":
			out.Values[i] = ec._SceneBoard_gridSize(ctx, field, obj)
		case "canvasWidth":
			out.Values[i] = ec._SceneBoard_canvasWidth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canvasHeight":
			out.Values[i] = ec._SceneBoard_canvasHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buttons":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoard_buttons(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoard_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoard_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneBoardButtonImplementors = []string{"SceneBoardButton"}

func (ec *executionContext) _SceneBoardButton(ctx context.Context, sel ast.SelectionSet, obj *models.SceneBoardButton) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneBoardButtonImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneBoardButton")
		case "id":
			out.Values[i] = ec._SceneBoardButton_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sceneBoard":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoardButton_sceneBoard(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scene":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoardButton_scene(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "layoutX":
			out.Values[i] = ec._SceneBoardButton_layoutX(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "layoutY":
			out.Values[i] = ec._SceneBoardButton_layoutY(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "width":
			out.Values[i] = ec._SceneBoardButton_width(ctx, field, obj)
		case "height":
			out.Values[i] = ec._SceneBoardButton_height(ctx, field, obj)
		case "color":
			out.Values[i] = ec._SceneBoardButton_color(ctx, field, obj)
		case "label":
			out.Values[i] = ec._SceneBoardButton_label(ctx, field, obj)
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoardButton_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneBoardButton_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneComparisonImplementors = []string{"SceneComparison"}

func (ec *executionContext) _SceneComparison(ctx context.Context, sel ast.SelectionSet, obj *SceneComparison) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneComparisonImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneComparison")
		case "scene1":
			out.Values[i] = ec._SceneComparison_scene1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scene2":
			out.Values[i] = ec._SceneComparison_scene2(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "differences":
			out.Values[i] = ec._SceneComparison_differences(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "identicalFixtureCount":
			out.Values[i] = ec._SceneComparison_identicalFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "differentFixtureCount":
			out.Values[i] = ec._SceneComparison_differentFixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneDifferenceImplementors = []string{"SceneDifference"}

func (ec *executionContext) _SceneDifference(ctx context.Context, sel ast.SelectionSet, obj *SceneDifference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneDifferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneDifference")
		case "fixtureId":
			out.Values[i] = ec._SceneDifference_fixtureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureName":
			out.Values[i] = ec._SceneDifference_fixtureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "differenceType":
			out.Values[i] = ec._SceneDifference_differenceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scene1Values":
			out.Values[i] = ec._SceneDifference_scene1Values(ctx, field, obj)
		case "scene2Values":
			out.Values[i] = ec._SceneDifference_scene2Values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneFixtureSummaryImplementors = []string{"SceneFixtureSummary"}

func (ec *executionContext) _SceneFixtureSummary(ctx context.Context, sel ast.SelectionSet, obj *SceneFixtureSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneFixtureSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneFixtureSummary")
		case "fixtureId":
			out.Values[i] = ec._SceneFixtureSummary_fixtureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureName":
			out.Values[i] = ec._SceneFixtureSummary_fixtureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtureType":
			out.Values[i] = ec._SceneFixtureSummary_fixtureType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scenePageImplementors = []string{"ScenePage"}

func (ec *executionContext) _ScenePage(ctx context.Context, sel ast.SelectionSet, obj *ScenePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scenePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScenePage")
		case "scenes":
			out.Values[i] = ec._ScenePage_scenes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._ScenePage_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneSummaryImplementors = []string{"SceneSummary"}

func (ec *executionContext) _SceneSummary(ctx context.Context, sel ast.SelectionSet, obj *SceneSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneSummary")
		case "id":
			out.Values[i] = ec._SceneSummary_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._SceneSummary_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._SceneSummary_description(ctx, field, obj)
		case "fixtureCount":
			out.Values[i] = ec._SceneSummary_fixtureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SceneSummary_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._SceneSummary_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneUsageImplementors = []string{"SceneUsage"}

func (ec *executionContext) _SceneUsage(ctx context.Context, sel ast.SelectionSet, obj *SceneUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneUsageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneUsage")
		case "sceneId":
			out.Values[i] = ec._SceneUsage_sceneId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sceneName":
			out.Values[i] = ec._SceneUsage_sceneName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cues":
			out.Values[i] = ec._SceneUsage_cues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var settingImplementors = []string{"Setting"}

func (ec *executionContext) _Setting(ctx context.Context, sel ast.SelectionSet, obj *models.Setting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, settingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Setting")
		case "id":
			out.Values[i] = ec._Setting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "key":
			out.Values[i] = ec._Setting_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._Setting_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Setting_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Setting_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "dmxOutputChanged":
		return ec._Subscription_dmxOutputChanged(ctx, fields[0])
	case "projectUpdated":
		return ec._Subscription_projectUpdated(ctx, fields[0])
	case "previewSessionUpdated":
		return ec._Subscription_previewSessionUpdated(ctx, fields[0])
	case "cueListPlaybackUpdated":
		return ec._Subscription_cueListPlaybackUpdated(ctx, fields[0])
	case "systemInfoUpdated":
		return ec._Subscription_systemInfoUpdated(ctx, fields[0])
	case "wifiStatusUpdated":
		return ec._Subscription_wifiStatusUpdated(ctx, fields[0])
	case "oflImportProgress":
		return ec._Subscription_oflImportProgress(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var systemInfoImplementors = []string{"SystemInfo"}

func (ec *executionContext) _SystemInfo(ctx context.Context, sel ast.SelectionSet, obj *SystemInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, systemInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SystemInfo")
		case "artnetBroadcastAddress":
			out.Values[i] = ec._SystemInfo_artnetBroadcastAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "artnetEnabled":
			out.Values[i] = ec._SystemInfo_artnetEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var systemVersionInfoImplementors = []string{"SystemVersionInfo"}

func (ec *executionContext) _SystemVersionInfo(ctx context.Context, sel ast.SelectionSet, obj *SystemVersionInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, systemVersionInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SystemVersionInfo")
		case "repositories":
			out.Values[i] = ec._SystemVersionInfo_repositories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastChecked":
			out.Values[i] = ec._SystemVersionInfo_lastChecked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionManagementSupported":
			out.Values[i] = ec._SystemVersionInfo_versionManagementSupported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var universeChannelMapImplementors = []string{"UniverseChannelMap"}

func (ec *executionContext) _UniverseChannelMap(ctx context.Context, sel ast.SelectionSet, obj *UniverseChannelMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, universeChannelMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UniverseChannelMap")
		case "universe":
			out.Values[i] = ec._UniverseChannelMap_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fixtures":
			out.Values[i] = ec._UniverseChannelMap_fixtures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channelUsage":
			out.Values[i] = ec._UniverseChannelMap_channelUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "availableChannels":
			out.Values[i] = ec._UniverseChannelMap_availableChannels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usedChannels":
			out.Values[i] = ec._UniverseChannelMap_usedChannels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var universeOutputImplementors = []string{"UniverseOutput"}

func (ec *executionContext) _UniverseOutput(ctx context.Context, sel ast.SelectionSet, obj *UniverseOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, universeOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UniverseOutput")
		case "universe":
			out.Values[i] = ec._UniverseOutput_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channels":
			out.Values[i] = ec._UniverseOutput_channels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateResultImplementors = []string{"UpdateResult"}

func (ec *executionContext) _UpdateResult(ctx context.Context, sel ast.SelectionSet, obj *UpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateResult")
		case "success":
			out.Values[i] = ec._UpdateResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repository":
			out.Values[i] = ec._UpdateResult_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousVersion":
			out.Values[i] = ec._UpdateResult_previousVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newVersion":
			out.Values[i] = ec._UpdateResult_newVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UpdateResult_message(ctx, field, obj)
		case "error":
			out.Values[i] = ec._UpdateResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
		case "role":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_role(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wiFiConnectionResultImplementors = []string{"WiFiConnectionResult"}

func (ec *executionContext) _WiFiConnectionResult(ctx context.Context, sel ast.SelectionSet, obj *WiFiConnectionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wiFiConnectionResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WiFiConnectionResult")
		case "success":
			out.Values[i] = ec._WiFiConnectionResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._WiFiConnectionResult_message(ctx, field, obj)
		case "connected":
			out.Values[i] = ec._WiFiConnectionResult_connected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wiFiNetworkImplementors = []string{"WiFiNetwork"}

func (ec *executionContext) _WiFiNetwork(ctx context.Context, sel ast.SelectionSet, obj *WiFiNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wiFiNetworkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WiFiNetwork")
		case "ssid":
			out.Values[i] = ec._WiFiNetwork_ssid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signalStrength":
			out.Values[i] = ec._WiFiNetwork_signalStrength(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "frequency":
			out.Values[i] = ec._WiFiNetwork_frequency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "security":
			out.Values[i] = ec._WiFiNetwork_security(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inUse":
			out.Values[i] = ec._WiFiNetwork_inUse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saved":
			out.Values[i] = ec._WiFiNetwork_saved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wiFiStatusImplementors = []string{"WiFiStatus"}

func (ec *executionContext) _WiFiStatus(ctx context.Context, sel ast.SelectionSet, obj *WiFiStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wiFiStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WiFiStatus")
		case "available":
			out.Values[i] = ec._WiFiStatus_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._WiFiStatus_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connected":
			out.Values[i] = ec._WiFiStatus_connected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ssid":
			out.Values[i] = ec._WiFiStatus_ssid(ctx, field, obj)
		case "signalStrength":
			out.Values[i] = ec._WiFiStatus_signalStrength(ctx, field, obj)
		case "ipAddress":
			out.Values[i] = ec._WiFiStatus_ipAddress(ctx, field, obj)
		case "macAddress":
			out.Values[i] = ec._WiFiStatus_macAddress(ctx, field, obj)
		case "frequency":
			out.Values[i] = ec._WiFiStatus_frequency(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBulkCueCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueCreateInput(ctx context.Context, v any) (BulkCueCreateInput, error) {
	res, err := ec.unmarshalInputBulkCueCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkCueListCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueListCreateInput(ctx context.Context, v any) (BulkCueListCreateInput, error) {
	res, err := ec.unmarshalInputBulkCueListCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkCueListUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueListUpdateInput(ctx context.Context, v any) (BulkCueListUpdateInput, error) {
	res, err := ec.unmarshalInputBulkCueListUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkCueUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkCueUpdateInput(ctx context.Context, v any) (BulkCueUpdateInput, error) {
	res, err := ec.unmarshalInputBulkCueUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult(ctx context.Context, sel ast.SelectionSet, v BulkDeleteResult) graphql.Marshaler {
	return ec._BulkDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBulkDeleteResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkDeleteResult(ctx context.Context, sel ast.SelectionSet, v *BulkDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BulkDeleteResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBulkFixtureCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureCreateInput(ctx context.Context, v any) (BulkFixtureCreateInput, error) {
	res, err := ec.unmarshalInputBulkFixtureCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkFixtureDefinitionCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureDefinitionCreateInput(ctx context.Context, v any) (BulkFixtureDefinitionCreateInput, error) {
	res, err := ec.unmarshalInputBulkFixtureDefinitionCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkFixtureDefinitionUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureDefinitionUpdateInput(ctx context.Context, v any) (BulkFixtureDefinitionUpdateInput, error) {
	res, err := ec.unmarshalInputBulkFixtureDefinitionUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkFixtureUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkFixtureUpdateInput(ctx context.Context, v any) (BulkFixtureUpdateInput, error) {
	res, err := ec.unmarshalInputBulkFixtureUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkProjectCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkProjectCreateInput(ctx context.Context, v any) (BulkProjectCreateInput, error) {
	res, err := ec.unmarshalInputBulkProjectCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkProjectUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkProjectUpdateInput(ctx context.Context, v any) (BulkProjectUpdateInput, error) {
	res, err := ec.unmarshalInputBulkProjectUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneBoardButtonCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardButtonCreateInput(ctx context.Context, v any) (BulkSceneBoardButtonCreateInput, error) {
	res, err := ec.unmarshalInputBulkSceneBoardButtonCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneBoardButtonUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardButtonUpdateInput(ctx context.Context, v any) (BulkSceneBoardButtonUpdateInput, error) {
	res, err := ec.unmarshalInputBulkSceneBoardButtonUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneBoardCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardCreateInput(ctx context.Context, v any) (BulkSceneBoardCreateInput, error) {
	res, err := ec.unmarshalInputBulkSceneBoardCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneBoardUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneBoardUpdateInput(ctx context.Context, v any) (BulkSceneBoardUpdateInput, error) {
	res, err := ec.unmarshalInputBulkSceneBoardUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneCreateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneCreateInput(ctx context.Context, v any) (BulkSceneCreateInput, error) {
	res, err := ec.unmarshalInputBulkSceneCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkSceneUpdateInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedBulkSceneUpdateInput(ctx context.Context, v any) (BulkSceneUpdateInput, error) {
	res, err := ec.unmarshalInputBulkSceneUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChannelAssignmentInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelAssignmentInput(ctx context.Context, v any) (ChannelAssignmentInput, error) {
	res, err := ec.unmarshalInputChannelAssignmentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelAssignmentSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelAssignmentSuggestion(ctx context.Context, sel ast.SelectionSet, v ChannelAssignmentSuggestion) graphql.Marshaler {
	return ec._ChannelAssignmentSuggestion(ctx, sel, &v)
}

func (ec *executionContext) marshalNChannelAssignmentSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelAssignmentSuggestion(ctx context.Context, sel ast.SelectionSet, v *ChannelAssignmentSuggestion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelAssignmentSuggestion(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition(ctx context.Context, sel ast.SelectionSet, v models.ChannelDefinition) graphql.Marshaler {
	return ec._ChannelDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChannelDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelDefinition(ctx context.Context, sel ast.SelectionSet, v *models.ChannelDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelFadeBehaviorInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelFadeBehaviorInput(ctx context.Context, v any) ([]*ChannelFadeBehaviorInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ChannelFadeBehaviorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelFadeBehaviorInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelFadeBehaviorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNChannelFadeBehaviorInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelFadeBehaviorInput(ctx context.Context, v any) (*ChannelFadeBehaviorInput, error) {
	res, err := ec.unmarshalInputChannelFadeBehaviorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelMapFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapFixture(ctx context.Context, sel ast.SelectionSet, v []*ChannelMapFixture) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelMapFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapFixture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChannelMapFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapFixture(ctx context.Context, sel ast.SelectionSet, v *ChannelMapFixture) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelMapFixture(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelMapResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapResult(ctx context.Context, sel ast.SelectionSet, v ChannelMapResult) graphql.Marshaler {
	return ec._ChannelMapResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNChannelMapResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelMapResult(ctx context.Context, sel ast.SelectionSet, v *ChannelMapResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelMapResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx context.Context, v any) (ChannelType, error) {
	var res ChannelType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx context.Context, sel ast.SelectionSet, v ChannelType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNChannelUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelUsage(ctx context.Context, sel ast.SelectionSet, v []*ChannelUsage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOChannelUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelUsage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNChannelValue2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelValue(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelValue2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChannelValue2githubcombbernsteinlacylightsgointernaldatabasemodelsChannelValue(ctx context.Context, sel ast.SelectionSet, v *models.ChannelValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelValueInput(ctx context.Context, v any) ([]*ChannelValueInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ChannelValueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelValueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNChannelValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelValueInput(ctx context.Context, v any) (*ChannelValueInput, error) {
	res, err := ec.unmarshalInputChannelValueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateChannelDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateChannelDefinitionInput(ctx context.Context, v any) ([]*CreateChannelDefinitionInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateChannelDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateChannelDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateChannelDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateChannelDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateChannelDefinitionInput(ctx context.Context, v any) (*CreateChannelDefinitionInput, error) {
	res, err := ec.unmarshalInputCreateChannelDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput(ctx context.Context, v any) (CreateCueInput, error) {
	res, err := ec.unmarshalInputCreateCueInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput(ctx context.Context, v any) ([]*CreateCueInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateCueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateCueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueInput(ctx context.Context, v any) (*CreateCueInput, error) {
	res, err := ec.unmarshalInputCreateCueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput(ctx context.Context, v any) (CreateCueListInput, error) {
	res, err := ec.unmarshalInputCreateCueListInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput(ctx context.Context, v any) ([]*CreateCueListInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateCueListInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateCueListInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateCueListInput(ctx context.Context, v any) (*CreateCueListInput, error) {
	res, err := ec.unmarshalInputCreateCueListInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput(ctx context.Context, v any) (CreateFixtureDefinitionInput, error) {
	res, err := ec.unmarshalInputCreateFixtureDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput(ctx context.Context, v any) ([]*CreateFixtureDefinitionInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateFixtureDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateFixtureDefinitionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureDefinitionInput(ctx context.Context, v any) (*CreateFixtureDefinitionInput, error) {
	res, err := ec.unmarshalInputCreateFixtureDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput(ctx context.Context, v any) (CreateFixtureInstanceInput, error) {
	res, err := ec.unmarshalInputCreateFixtureInstanceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput(ctx context.Context, v any) ([]*CreateFixtureInstanceInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateFixtureInstanceInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateFixtureInstanceInput(ctx context.Context, v any) (*CreateFixtureInstanceInput, error) {
	res, err := ec.unmarshalInputCreateFixtureInstanceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput(ctx context.Context, v any) (CreateProjectInput, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput(ctx context.Context, v any) ([]*CreateProjectInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateProjectInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateProjectInput(ctx context.Context, v any) (*CreateProjectInput, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput(ctx context.Context, v any) (CreateSceneBoardButtonInput, error) {
	res, err := ec.unmarshalInputCreateSceneBoardButtonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput(ctx context.Context, v any) ([]*CreateSceneBoardButtonInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateSceneBoardButtonInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardButtonInput(ctx context.Context, v any) (*CreateSceneBoardButtonInput, error) {
	res, err := ec.unmarshalInputCreateSceneBoardButtonInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput(ctx context.Context, v any) (CreateSceneBoardInput, error) {
	res, err := ec.unmarshalInputCreateSceneBoardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput(ctx context.Context, v any) ([]*CreateSceneBoardInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateSceneBoardInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneBoardInput(ctx context.Context, v any) (*CreateSceneBoardInput, error) {
	res, err := ec.unmarshalInputCreateSceneBoardInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput(ctx context.Context, v any) (CreateSceneInput, error) {
	res, err := ec.unmarshalInputCreateSceneInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput(ctx context.Context, v any) ([]*CreateSceneInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CreateSceneInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCreateSceneInput(ctx context.Context, v any) (*CreateSceneInput, error) {
	res, err := ec.unmarshalInputCreateSceneInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue(ctx context.Context, sel ast.SelectionSet, v models.Cue) graphql.Marshaler {
	return ec._Cue(ctx, sel, &v)
}

func (ec *executionContext) marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue(ctx context.Context, sel ast.SelectionSet, v []*models.Cue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue(ctx context.Context, sel ast.SelectionSet, v *models.Cue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Cue(ctx, sel, v)
}

func (ec *executionContext) marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList(ctx context.Context, sel ast.SelectionSet, v models.CueList) graphql.Marshaler {
	return ec._CueList(ctx, sel, &v)
}

func (ec *executionContext) marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList(ctx context.Context, sel ast.SelectionSet, v []*models.CueList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList(ctx context.Context, sel ast.SelectionSet, v *models.CueList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CueList(ctx, sel, v)
}

func (ec *executionContext) marshalNCueListPlaybackStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListPlaybackStatus(ctx context.Context, sel ast.SelectionSet, v CueListPlaybackStatus) graphql.Marshaler {
	return ec._CueListPlaybackStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNCueListPlaybackStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListPlaybackStatus(ctx context.Context, sel ast.SelectionSet, v *CueListPlaybackStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CueListPlaybackStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNCueListSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListSummary(ctx context.Context, sel ast.SelectionSet, v []*CueListSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCueListSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCueListSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListSummary(ctx context.Context, sel ast.SelectionSet, v *CueListSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CueListSummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCueListUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListUpdateItem(ctx context.Context, v any) ([]*CueListUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CueListUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCueListUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCueListUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListUpdateItem(ctx context.Context, v any) (*CueListUpdateItem, error) {
	res, err := ec.unmarshalInputCueListUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCueOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueOrderInput(ctx context.Context, v any) ([]*CueOrderInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*CueOrderInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCueOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueOrderInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCueOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueOrderInput(ctx context.Context, v any) (*CueOrderInput, error) {
	res, err := ec.unmarshalInputCueOrderInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCuePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCuePage(ctx context.Context, sel ast.SelectionSet, v CuePage) graphql.Marshaler {
	return ec._CuePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNCuePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCuePage(ctx context.Context, sel ast.SelectionSet, v *CuePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CuePage(ctx, sel, v)
}

func (ec *executionContext) marshalNCueUsageSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueUsageSummary(ctx context.Context, sel ast.SelectionSet, v []*CueUsageSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCueUsageSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueUsageSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCueUsageSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueUsageSummary(ctx context.Context, sel ast.SelectionSet, v *CueUsageSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CueUsageSummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDifferenceType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedDifferenceType(ctx context.Context, v any) (DifferenceType, error) {
	var res DifferenceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDifferenceType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedDifferenceType(ctx context.Context, sel ast.SelectionSet, v DifferenceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportResult(ctx context.Context, sel ast.SelectionSet, v ExportResult) graphql.Marshaler {
	return ec._ExportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportResult(ctx context.Context, sel ast.SelectionSet, v *ExportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNExportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportStats(ctx context.Context, sel ast.SelectionSet, v ExportStats) graphql.Marshaler {
	return ec._ExportStats(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx context.Context, v any) (FadeBehavior, error) {
	var res FadeBehavior
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx context.Context, sel ast.SelectionSet, v FadeBehavior) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFixtureChannelAssignment2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureChannelAssignment(ctx context.Context, sel ast.SelectionSet, v []*FixtureChannelAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureChannelAssignment2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureChannelAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureChannelAssignment2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureChannelAssignment(ctx context.Context, sel ast.SelectionSet, v *FixtureChannelAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureChannelAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v models.FixtureDefinition) graphql.Marshaler {
	return ec._FixtureDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v []*models.FixtureDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v *models.FixtureDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFixtureDefinitionUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionUpdateItem(ctx context.Context, v any) ([]*FixtureDefinitionUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureDefinitionUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureDefinitionUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixtureDefinitionUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionUpdateItem(ctx context.Context, v any) (*FixtureDefinitionUpdateItem, error) {
	res, err := ec.unmarshalInputFixtureDefinitionUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance(ctx context.Context, sel ast.SelectionSet, v models.FixtureInstance) graphql.Marshaler {
	return ec._FixtureInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance(ctx context.Context, sel ast.SelectionSet, v []*models.FixtureInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance(ctx context.Context, sel ast.SelectionSet, v *models.FixtureInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNFixtureInstancePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureInstancePage(ctx context.Context, sel ast.SelectionSet, v FixtureInstancePage) graphql.Marshaler {
	return ec._FixtureInstancePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFixtureInstancePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureInstancePage(ctx context.Context, sel ast.SelectionSet, v *FixtureInstancePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureInstancePage(ctx, sel, v)
}

func (ec *executionContext) marshalNFixtureMapping2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMapping(ctx context.Context, sel ast.SelectionSet, v []*FixtureMapping) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureMapping2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMapping(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureMapping2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMapping(ctx context.Context, sel ast.SelectionSet, v *FixtureMapping) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureMapping(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFixtureMappingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingInput(ctx context.Context, v any) (*FixtureMappingInput, error) {
	res, err := ec.unmarshalInputFixtureMappingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixtureMappingSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingSuggestion(ctx context.Context, sel ast.SelectionSet, v []*FixtureMappingSuggestion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureMappingSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingSuggestion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureMappingSuggestion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingSuggestion(ctx context.Context, sel ast.SelectionSet, v *FixtureMappingSuggestion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureMappingSuggestion(ctx, sel, v)
}

func (ec *executionContext) marshalNFixtureMode2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureMode(ctx context.Context, sel ast.SelectionSet, v []*models.FixtureMode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureMode2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureMode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureMode2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureMode(ctx context.Context, sel ast.SelectionSet, v *models.FixtureMode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureMode(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFixtureOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureOrderInput(ctx context.Context, v any) ([]*FixtureOrderInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureOrderInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureOrderInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixtureOrderInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureOrderInput(ctx context.Context, v any) (*FixtureOrderInput, error) {
	res, err := ec.unmarshalInputFixtureOrderInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFixturePositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixturePositionInput(ctx context.Context, v any) ([]*FixturePositionInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixturePositionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixturePositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixturePositionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixturePositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixturePositionInput(ctx context.Context, v any) (*FixturePositionInput, error) {
	res, err := ec.unmarshalInputFixturePositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFixtureSpecInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureSpecInput(ctx context.Context, v any) ([]*FixtureSpecInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureSpecInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureSpecInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureSpecInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixtureSpecInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureSpecInput(ctx context.Context, v any) (*FixtureSpecInput, error) {
	res, err := ec.unmarshalInputFixtureSpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx context.Context, v any) (FixtureType, error) {
	var res FixtureType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx context.Context, sel ast.SelectionSet, v FixtureType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFixtureUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUpdateItem(ctx context.Context, v any) ([]*FixtureUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixtureUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUpdateItem(ctx context.Context, v any) (*FixtureUpdateItem, error) {
	res, err := ec.unmarshalInputFixtureUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixtureUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUsage(ctx context.Context, sel ast.SelectionSet, v FixtureUsage) graphql.Marshaler {
	return ec._FixtureUsage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFixtureUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureUsage(ctx context.Context, sel ast.SelectionSet, v *FixtureUsage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureUsage(ctx, sel, v)
}

func (ec *executionContext) marshalNFixtureValue2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureValue(ctx context.Context, sel ast.SelectionSet, v []*models.FixtureValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFixtureValue2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFixtureValue2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureValue(ctx context.Context, sel ast.SelectionSet, v *models.FixtureValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FixtureValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx context.Context, v any) ([]*FixtureValueInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureValueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx context.Context, v any) (*FixtureValueInput, error) {
	res, err := ec.unmarshalInputFixtureValueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImportMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportMode(ctx context.Context, v any) (ImportMode, error) {
	var res ImportMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImportMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportMode(ctx context.Context, sel ast.SelectionSet, v ImportMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImportOFLFixtureInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportOFLFixtureInput(ctx context.Context, v any) (ImportOFLFixtureInput, error) {
	res, err := ec.unmarshalInputImportOFLFixtureInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNImportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportOptionsInput(ctx context.Context, v any) (ImportOptionsInput, error) {
	res, err := ec.unmarshalInputImportOptionsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportResult(ctx context.Context, sel ast.SelectionSet, v ImportResult) graphql.Marshaler {
	return ec._ImportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportResult(ctx context.Context, sel ast.SelectionSet, v *ImportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNImportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedImportStats(ctx context.Context, sel ast.SelectionSet, v ImportStats) graphql.Marshaler {
	return ec._ImportStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel(ctx context.Context, sel ast.SelectionSet, v models.InstanceChannel) graphql.Marshaler {
	return ec._InstanceChannel(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel(ctx context.Context, sel ast.SelectionSet, v []*models.InstanceChannel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInstanceChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsInstanceChannel(ctx context.Context, sel ast.SelectionSet, v *models.InstanceChannel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InstanceChannel(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture(ctx context.Context, sel ast.SelectionSet, v LacyLightsFixture) graphql.Marshaler {
	return ec._LacyLightsFixture(ctx, sel, &v)
}

func (ec *executionContext) marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture(ctx context.Context, sel ast.SelectionSet, v []*LacyLightsFixture) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLacyLightsFixture2githubcombbernsteinlacylightsgointernalgraphqlgeneratedLacyLightsFixture(ctx context.Context, sel ast.SelectionSet, v *LacyLightsFixture) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LacyLightsFixture(ctx, sel, v)
}

func (ec *executionContext) marshalNModeChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsModeChannel(ctx context.Context, sel ast.SelectionSet, v []*models.ModeChannel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModeChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsModeChannel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNModeChannel2githubcombbernsteinlacylightsgointernaldatabasemodelsModeChannel(ctx context.Context, sel ast.SelectionSet, v *models.ModeChannel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModeChannel(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkInterfaceOption2githubcombbernsteinlacylightsgointernalgraphqlgeneratedNetworkInterfaceOption(ctx context.Context, sel ast.SelectionSet, v []*NetworkInterfaceOption) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkInterfaceOption2githubcombbernsteinlacylightsgointernalgraphqlgeneratedNetworkInterfaceOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNetworkInterfaceOption2githubcombbernsteinlacylightsgointernalgraphqlgeneratedNetworkInterfaceOption(ctx context.Context, sel ast.SelectionSet, v *NetworkInterfaceOption) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkInterfaceOption(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOFLFixtureChangeType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureChangeType(ctx context.Context, v any) (OFLFixtureChangeType, error) {
	var res OFLFixtureChangeType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOFLFixtureChangeType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureChangeType(ctx context.Context, sel ast.SelectionSet, v OFLFixtureChangeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOFLFixtureUpdate2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureUpdate(ctx context.Context, sel ast.SelectionSet, v []*OFLFixtureUpdate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOFLFixtureUpdate2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureUpdate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOFLFixtureUpdate2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLFixtureUpdate(ctx context.Context, sel ast.SelectionSet, v *OFLFixtureUpdate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OFLFixtureUpdate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOFLImportPhase2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportPhase(ctx context.Context, v any) (OFLImportPhase, error) {
	var res OFLImportPhase
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOFLImportPhase2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportPhase(ctx context.Context, sel ast.SelectionSet, v OFLImportPhase) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOFLImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportResult(ctx context.Context, sel ast.SelectionSet, v OFLImportResult) graphql.Marshaler {
	return ec._OFLImportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNOFLImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportResult(ctx context.Context, sel ast.SelectionSet, v *OFLImportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OFLImportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNOFLImportStats2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStats(ctx context.Context, sel ast.SelectionSet, v OFLImportStats) graphql.Marshaler {
	return ec._OFLImportStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNOFLImportStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStatus(ctx context.Context, sel ast.SelectionSet, v OFLImportStatus) graphql.Marshaler {
	return ec._OFLImportStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNOFLImportStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportStatus(ctx context.Context, sel ast.SelectionSet, v *OFLImportStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OFLImportStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNOFLUpdateCheckResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLUpdateCheckResult(ctx context.Context, sel ast.SelectionSet, v OFLUpdateCheckResult) graphql.Marshaler {
	return ec._OFLUpdateCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNOFLUpdateCheckResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLUpdateCheckResult(ctx context.Context, sel ast.SelectionSet, v *OFLUpdateCheckResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OFLUpdateCheckResult(ctx, sel, v)
}

func (ec *executionContext) marshalNPaginationInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedPaginationInfo(ctx context.Context, sel ast.SelectionSet, v PaginationInfo) graphql.Marshaler {
	return ec._PaginationInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession(ctx context.Context, sel ast.SelectionSet, v models.PreviewSession) graphql.Marshaler {
	return ec._PreviewSession(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession(ctx context.Context, sel ast.SelectionSet, v *models.PreviewSession) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PreviewSession(ctx, sel, v)
}

func (ec *executionContext) marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject(ctx context.Context, sel ast.SelectionSet, v models.Project) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject(ctx context.Context, sel ast.SelectionSet, v []*models.Project) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject(ctx context.Context, sel ast.SelectionSet, v *models.Project) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectRole(ctx context.Context, v any) (ProjectRole, error) {
	var res ProjectRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectRole(ctx context.Context, sel ast.SelectionSet, v ProjectRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProjectUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectUpdateItem(ctx context.Context, v any) ([]*ProjectUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ProjectUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNProjectUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedProjectUpdateItem(ctx context.Context, v any) (*ProjectUpdateItem, error) {
	res, err := ec.unmarshalInputProjectUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectUser2githubcombbernsteinlacylightsgointernaldatabasemodelsProjectUser(ctx context.Context, sel ast.SelectionSet, v []*models.ProjectUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectUser2githubcombbernsteinlacylightsgointernaldatabasemodelsProjectUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectUser2githubcombbernsteinlacylightsgointernaldatabasemodelsProjectUser(ctx context.Context, sel ast.SelectionSet, v *models.ProjectUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectUser(ctx, sel, v)
}

func (ec *executionContext) marshalNQLCExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCExportResult(ctx context.Context, sel ast.SelectionSet, v QLCExportResult) graphql.Marshaler {
	return ec._QLCExportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQLCExportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCExportResult(ctx context.Context, sel ast.SelectionSet, v *QLCExportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QLCExportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNQLCFixtureDefinition2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v []*QLCFixtureDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNQLCFixtureDefinition2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNQLCFixtureDefinition2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v *QLCFixtureDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QLCFixtureDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalNQLCFixtureMappingResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMappingResult(ctx context.Context, sel ast.SelectionSet, v QLCFixtureMappingResult) graphql.Marshaler {
	return ec._QLCFixtureMappingResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQLCFixtureMappingResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMappingResult(ctx context.Context, sel ast.SelectionSet, v *QLCFixtureMappingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QLCFixtureMappingResult(ctx, sel, v)
}

func (ec *executionContext) marshalNQLCFixtureMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMode(ctx context.Context, sel ast.SelectionSet, v []*QLCFixtureMode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNQLCFixtureMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNQLCFixtureMode2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCFixtureMode(ctx context.Context, sel ast.SelectionSet, v *QLCFixtureMode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QLCFixtureMode(ctx, sel, v)
}

func (ec *executionContext) marshalNQLCImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCImportResult(ctx context.Context, sel ast.SelectionSet, v QLCImportResult) graphql.Marshaler {
	return ec._QLCImportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQLCImportResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedQLCImportResult(ctx context.Context, sel ast.SelectionSet, v *QLCImportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QLCImportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryVersion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedRepositoryVersion(ctx context.Context, sel ast.SelectionSet, v []*RepositoryVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryVersion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedRepositoryVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRepositoryVersion2githubcombbernsteinlacylightsgointernalgraphqlgeneratedRepositoryVersion(ctx context.Context, sel ast.SelectionSet, v *RepositoryVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene(ctx context.Context, sel ast.SelectionSet, v models.Scene) graphql.Marshaler {
	return ec._Scene(ctx, sel, &v)
}

func (ec *executionContext) marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene(ctx context.Context, sel ast.SelectionSet, v []*models.Scene) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene(ctx context.Context, sel ast.SelectionSet, v *models.Scene) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Scene(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard(ctx context.Context, sel ast.SelectionSet, v models.SceneBoard) graphql.Marshaler {
	return ec._SceneBoard(ctx, sel, &v)
}

func (ec *executionContext) marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard(ctx context.Context, sel ast.SelectionSet, v []*models.SceneBoard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard(ctx context.Context, sel ast.SelectionSet, v *models.SceneBoard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneBoard(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton(ctx context.Context, sel ast.SelectionSet, v models.SceneBoardButton) graphql.Marshaler {
	return ec._SceneBoardButton(ctx, sel, &v)
}

func (ec *executionContext) marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton(ctx context.Context, sel ast.SelectionSet, v []*models.SceneBoardButton) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton(ctx context.Context, sel ast.SelectionSet, v *models.SceneBoardButton) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneBoardButton(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSceneBoardButtonPositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonPositionInput(ctx context.Context, v any) ([]*SceneBoardButtonPositionInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SceneBoardButtonPositionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSceneBoardButtonPositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonPositionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSceneBoardButtonPositionInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonPositionInput(ctx context.Context, v any) (*SceneBoardButtonPositionInput, error) {
	res, err := ec.unmarshalInputSceneBoardButtonPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneBoardButtonUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonUpdateItem(ctx context.Context, v any) ([]*SceneBoardButtonUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SceneBoardButtonUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSceneBoardButtonUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSceneBoardButtonUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardButtonUpdateItem(ctx context.Context, v any) (*SceneBoardButtonUpdateItem, error) {
	res, err := ec.unmarshalInputSceneBoardButtonUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneBoardUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardUpdateItem(ctx context.Context, v any) ([]*SceneBoardUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SceneBoardUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSceneBoardUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSceneBoardUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneBoardUpdateItem(ctx context.Context, v any) (*SceneBoardUpdateItem, error) {
	res, err := ec.unmarshalInputSceneBoardUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSceneComparison2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneComparison(ctx context.Context, sel ast.SelectionSet, v SceneComparison) graphql.Marshaler {
	return ec._SceneComparison(ctx, sel, &v)
}

func (ec *executionContext) marshalNSceneComparison2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneComparison(ctx context.Context, sel ast.SelectionSet, v *SceneComparison) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneComparison(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneDifference2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneDifference(ctx context.Context, sel ast.SelectionSet, v []*SceneDifference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneDifference2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneDifference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneDifference2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneDifference(ctx context.Context, sel ast.SelectionSet, v *SceneDifference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneDifference(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneFixtureSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFixtureSummary(ctx context.Context, sel ast.SelectionSet, v []*SceneFixtureSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneFixtureSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFixtureSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneFixtureSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFixtureSummary(ctx context.Context, sel ast.SelectionSet, v *SceneFixtureSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneFixtureSummary(ctx, sel, v)
}

func (ec *executionContext) marshalNScenePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedScenePage(ctx context.Context, sel ast.SelectionSet, v ScenePage) graphql.Marshaler {
	return ec._ScenePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNScenePage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedScenePage(ctx context.Context, sel ast.SelectionSet, v *ScenePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScenePage(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary(ctx context.Context, sel ast.SelectionSet, v SceneSummary) graphql.Marshaler {
	return ec._SceneSummary(ctx, sel, &v)
}

func (ec *executionContext) marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary(ctx context.Context, sel ast.SelectionSet, v []*SceneSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneSummary2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSummary(ctx context.Context, sel ast.SelectionSet, v *SceneSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneSummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSceneUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUpdateItem(ctx context.Context, v any) ([]*SceneUpdateItem, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SceneUpdateItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSceneUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUpdateItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSceneUpdateItem2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUpdateItem(ctx context.Context, v any) (*SceneUpdateItem, error) {
	res, err := ec.unmarshalInputSceneUpdateItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSceneUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUsage(ctx context.Context, sel ast.SelectionSet, v SceneUsage) graphql.Marshaler {
	return ec._SceneUsage(ctx, sel, &v)
}

func (ec *executionContext) marshalNSceneUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneUsage(ctx context.Context, sel ast.SelectionSet, v *SceneUsage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneUsage(ctx, sel, v)
}

func (ec *executionContext) marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting(ctx context.Context, sel ast.SelectionSet, v models.Setting) graphql.Marshaler {
	return ec._Setting(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting(ctx context.Context, sel ast.SelectionSet, v []*models.Setting) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting(ctx context.Context, sel ast.SelectionSet, v *models.Setting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Setting(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSystemInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemInfo(ctx context.Context, sel ast.SelectionSet, v SystemInfo) graphql.Marshaler {
	return ec._SystemInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNSystemInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemInfo(ctx context.Context, sel ast.SelectionSet, v *SystemInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SystemInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNSystemVersionInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemVersionInfo(ctx context.Context, sel ast.SelectionSet, v SystemVersionInfo) graphql.Marshaler {
	return ec._SystemVersionInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNSystemVersionInfo2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSystemVersionInfo(ctx context.Context, sel ast.SelectionSet, v *SystemVersionInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SystemVersionInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNUniverseChannelMap2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseChannelMap(ctx context.Context, sel ast.SelectionSet, v []*UniverseChannelMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUniverseChannelMap2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseChannelMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverseChannelMap2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseChannelMap(ctx context.Context, sel ast.SelectionSet, v *UniverseChannelMap) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UniverseChannelMap(ctx, sel, v)
}

func (ec *executionContext) marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput(ctx context.Context, sel ast.SelectionSet, v UniverseOutput) graphql.Marshaler {
	return ec._UniverseOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput(ctx context.Context, sel ast.SelectionSet, v []*UniverseOutput) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverseOutput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUniverseOutput(ctx context.Context, sel ast.SelectionSet, v *UniverseOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UniverseOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateFixtureInstanceInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateFixtureInstanceInput(ctx context.Context, v any) (UpdateFixtureInstanceInput, error) {
	res, err := ec.unmarshalInputUpdateFixtureInstanceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult(ctx context.Context, sel ast.SelectionSet, v UpdateResult) graphql.Marshaler {
	return ec._UpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult(ctx context.Context, sel ast.SelectionSet, v []*UpdateResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUpdateResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateResult(ctx context.Context, sel ast.SelectionSet, v *UpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateSceneBoardButtonInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneBoardButtonInput(ctx context.Context, v any) (UpdateSceneBoardButtonInput, error) {
	res, err := ec.unmarshalInputUpdateSceneBoardButtonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSceneBoardInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneBoardInput(ctx context.Context, v any) (UpdateSceneBoardInput, error) {
	res, err := ec.unmarshalInputUpdateSceneBoardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSceneInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSceneInput(ctx context.Context, v any) (UpdateSceneInput, error) {
	res, err := ec.unmarshalInputUpdateSceneInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSettingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUpdateSettingInput(ctx context.Context, v any) (UpdateSettingInput, error) {
	res, err := ec.unmarshalInputUpdateSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcombbernsteinlacylightsgointernaldatabasemodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcombbernsteinlacylightsgointernaldatabasemodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUserRole(ctx context.Context, v any) (UserRole, error) {
	var res UserRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserRole2githubcombbernsteinlacylightsgointernalgraphqlgeneratedUserRole(ctx context.Context, sel ast.SelectionSet, v UserRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWiFiConnectionResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiConnectionResult(ctx context.Context, sel ast.SelectionSet, v WiFiConnectionResult) graphql.Marshaler {
	return ec._WiFiConnectionResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNWiFiConnectionResult2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiConnectionResult(ctx context.Context, sel ast.SelectionSet, v *WiFiConnectionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WiFiConnectionResult(ctx, sel, v)
}

func (ec *executionContext) marshalNWiFiNetwork2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiNetwork(ctx context.Context, sel ast.SelectionSet, v []*WiFiNetwork) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWiFiNetwork2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWiFiNetwork2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiNetwork(ctx context.Context, sel ast.SelectionSet, v *WiFiNetwork) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WiFiNetwork(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWiFiSecurityType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiSecurityType(ctx context.Context, v any) (WiFiSecurityType, error) {
	var res WiFiSecurityType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWiFiSecurityType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiSecurityType(ctx context.Context, sel ast.SelectionSet, v WiFiSecurityType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWiFiStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiStatus(ctx context.Context, sel ast.SelectionSet, v WiFiStatus) graphql.Marshaler {
	return ec._WiFiStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNWiFiStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedWiFiStatus(ctx context.Context, sel ast.SelectionSet, v *WiFiStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WiFiStatus(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx context.Context, v any) ([]ChannelType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]ChannelType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx context.Context, sel ast.SelectionSet, v []ChannelType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelUsage2githubcombbernsteinlacylightsgointernalgraphqlgeneratedChannelUsage(ctx context.Context, sel ast.SelectionSet, v *ChannelUsage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChannelUsage(ctx, sel, v)
}

func (ec *executionContext) marshalOCue2githubcombbernsteinlacylightsgointernaldatabasemodelsCue(ctx context.Context, sel ast.SelectionSet, v *models.Cue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Cue(ctx, sel, v)
}

func (ec *executionContext) marshalOCueList2githubcombbernsteinlacylightsgointernaldatabasemodelsCueList(ctx context.Context, sel ast.SelectionSet, v *models.CueList) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CueList(ctx, sel, v)
}

func (ec *executionContext) marshalOCueListPlaybackStatus2githubcombbernsteinlacylightsgointernalgraphqlgeneratedCueListPlaybackStatus(ctx context.Context, sel ast.SelectionSet, v *CueListPlaybackStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CueListPlaybackStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEasingType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedEasingType(ctx context.Context, v any) (*EasingType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(EasingType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEasingType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedEasingType(ctx context.Context, sel ast.SelectionSet, v *EasingType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOExportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedExportOptionsInput(ctx context.Context, v any) (*ExportOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputExportOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx context.Context, v any) (*FadeBehavior, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FadeBehavior)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFadeBehavior2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFadeBehavior(ctx context.Context, sel ast.SelectionSet, v *FadeBehavior) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFixtureConflictStrategy2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureConflictStrategy(ctx context.Context, v any) (*FixtureConflictStrategy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FixtureConflictStrategy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFixtureConflictStrategy2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureConflictStrategy(ctx context.Context, sel ast.SelectionSet, v *FixtureConflictStrategy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFixtureDefinition2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureDefinition(ctx context.Context, sel ast.SelectionSet, v *models.FixtureDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FixtureDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFixtureDefinitionFilter2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureDefinitionFilter(ctx context.Context, v any) (*FixtureDefinitionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFixtureDefinitionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFixtureFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureFilterInput(ctx context.Context, v any) (*FixtureFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFixtureFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFixtureInstance2githubcombbernsteinlacylightsgointernaldatabasemodelsFixtureInstance(ctx context.Context, sel ast.SelectionSet, v *models.FixtureInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FixtureInstance(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFixtureMappingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingInput(ctx context.Context, v any) ([]*FixtureMappingInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureMappingInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureMappingInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureMappingInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx context.Context, v any) (*FixtureType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FixtureType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFixtureType2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureType(ctx context.Context, sel ast.SelectionSet, v *FixtureType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx context.Context, v any) ([]*FixtureValueInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*FixtureValueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFixtureValueInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedFixtureValueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOOFLImportOptionsInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedOFLImportOptionsInput(ctx context.Context, v any) (*OFLImportOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOFLImportOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPreviewSession2githubcombbernsteinlacylightsgointernaldatabasemodelsPreviewSession(ctx context.Context, sel ast.SelectionSet, v *models.PreviewSession) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PreviewSession(ctx, sel, v)
}

func (ec *executionContext) marshalOProject2githubcombbernsteinlacylightsgointernaldatabasemodelsProject(ctx context.Context, sel ast.SelectionSet, v *models.Project) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOScene2githubcombbernsteinlacylightsgointernaldatabasemodelsScene(ctx context.Context, sel ast.SelectionSet, v *models.Scene) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Scene(ctx, sel, v)
}

func (ec *executionContext) marshalOSceneBoard2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoard(ctx context.Context, sel ast.SelectionSet, v *models.SceneBoard) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SceneBoard(ctx, sel, v)
}

func (ec *executionContext) marshalOSceneBoardButton2githubcombbernsteinlacylightsgointernaldatabasemodelsSceneBoardButton(ctx context.Context, sel ast.SelectionSet, v *models.SceneBoardButton) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SceneBoardButton(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSceneFilterInput2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneFilterInput(ctx context.Context, v any) (*SceneFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSceneFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSceneSortField2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSortField(ctx context.Context, v any) (*SceneSortField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SceneSortField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSceneSortField2githubcombbernsteinlacylightsgointernalgraphqlgeneratedSceneSortField(ctx context.Context, sel ast.SelectionSet, v *SceneSortField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSetting2githubcombbernsteinlacylightsgointernaldatabasemodelsSetting(ctx context.Context, sel ast.SelectionSet, v *models.Setting) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Setting(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
